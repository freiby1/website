<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<title>Страница группы</title>
	<script type="module" src="online-status.js"></script>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet" />
	<link rel="stylesheet" href="styles.css">
	<link rel="preload" href="https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js" as="script"
		crossorigin="anonymous">
	<link rel="preload" href="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js" as="script"
		crossorigin="anonymous">
	<link rel="preload" href="https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js" as="script"
		crossorigin="anonymous">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>

	<style>
		.group-container {
			max-width: 1200px;
			margin: 20px auto;
			padding: 0 20px;
			overflow: hidden;
		}

		.group-header {
			position: relative;
			border-radius: 10px;
			overflow: hidden;
			margin-bottom: 30px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			background-color: #f8f8f8;
		}

		.dark-mode .group-header {
			background-color: #2d2d2d;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
		}

		.group-cover {
			height: 250px;
			background-color: #eee;
			position: relative;
			overflow: hidden;
		}

		.dark-mode .group-cover {
			background-color: #3d3d3d;
		}

		.group-cover img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.group-info {
			padding: 20px;
			position: relative;
			display: flex;
			align-items: center;
		}

		.group-avatar {
			width: 120px;
			height: 120px;
			border-radius: 50%;
			overflow: hidden;
			margin-right: 20px;
			background-color: #eee;
			border: 4px solid #fff;
			margin-top: -60px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			flex-shrink: 0;
		}

		.dark-mode .group-avatar {
			background-color: #3d3d3d;
			border-color: #2d2d2d;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
		}

		.group-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.group-details {
			flex: 1;
		}

		.group-name {
			font-size: 28px;
			font-weight: 600;
			margin-bottom: 10px;
			color: #333;
		}

		.dark-mode .group-name {
			color: #f5f5f5;
		}

		.group-description {
			font-size: 16px;
			color: #666;
			margin-bottom: 15px;
			line-height: 1.5;
		}

		.dark-mode .group-description {
			color: #bbb;
		}

		.group-meta {
			display: flex;
			align-items: center;
			font-size: 14px;
			color: #888;
		}

		.dark-mode .group-meta {
			color: #999;
		}

		.group-meta-item {
			display: flex;
			align-items: center;
			margin-right: 20px;
		}

		.group-meta-item i {
			margin-right: 5px;
		}

		.group-actions {
			display: flex;
			justify-content: flex-end;
			margin-left: auto;
		}

		.group-btn {
			display: inline-block;
			padding: 8px 15px;
			background-color: #4a76a8;
			color: white;
			border: none;
			border-radius: 5px;
			font-size: 14px;
			font-weight: 500;
			cursor: pointer;
			transition: background-color 0.3s;
			margin-left: 10px;
		}

		.group-btn:hover {
			background-color: #3a5b80;
		}

		.dark-mode .group-btn {
			background-color: #5a86b8;
		}

		.dark-mode .group-btn:hover {
			background-color: #4a76a8;
		}

		.group-btn.secondary {
			background-color: transparent;
			color: #4a76a8;
			border: 1px solid #4a76a8;
		}

		.group-btn.secondary:hover {
			background-color: rgba(74, 118, 168, 0.1);
		}

		.dark-mode .group-btn.secondary {
			color: #5a86b8;
			border-color: #5a86b8;
		}

		.dark-mode .group-btn.secondary:hover {
			background-color: rgba(90, 134, 184, 0.1);
		}

		.group-content {
			display: flex;
			gap: 30px;
		}

		.group-main {
			flex: 1;
		}

		.group-sidebar {
			width: 300px;
			flex-shrink: 0;
		}

		.content-section {
			background-color: #fff;
			border-radius: 10px;
			margin-bottom: 20px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		}

		.dark-mode .content-section {
			background-color: #2d2d2d;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
		}

		.section-title {
			font-size: 18px;
			font-weight: 600;
			margin-bottom: 15px;
			color: #333;
			border-bottom: 1px solid #eee;
			padding-bottom: 10px;
			text-align: left; /* Выравнивание по левому краю */
			display: flex;
			align-items: baseline; /* Выравниваем элементы по базовой линии */
		}

		.section-title .members-count {
			font-size: 18px;
			font-weight: normal;
			margin-left: 5px;
		}

		.dark-mode .section-title {
			color: #f5f5f5;
			border-bottom-color: #444;
		}

		.members-list {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
			gap: 15px;
		}

		.member-item {
			text-align: center;
			cursor: pointer;
		}

		.member-avatar {
			width: 60px;
			height: 60px;
			border-radius: 50%;
			overflow: hidden;
			margin: 0 auto 5px;
			background-color: #eee;
		}

		.dark-mode .member-avatar {
			background-color: #3d3d3d;
		}

		.member-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.member-name {
			font-size: 12px;
			color: #333;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.dark-mode .member-name {
			color: #ddd;
		}

		.member-role {
			font-size: 11px;
			color: #888;
		}

		.dark-mode .member-role {
			color: #999;
		}

		.posts-list {
			display: flex;
			flex-direction: column;
			gap: 20px;
		}

		.loading-indicator {
			text-align: center;
			padding: 50px 0;
			color: #888;
			font-size: 16px;
		}

		.dark-mode .loading-indicator {
			color: #999;
		}

		.loading-indicator i {
			margin-right: 10px;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			0% {
				transform: rotate(0deg);
			}
			100% {
				transform: rotate(360deg);
			}
		}

		.error-message {
			text-align: center;
			padding: 50px 0;
			color: #e74c3c;
			font-size: 16px;
		}

		.dark-mode .error-message {
			color: #ff6b6b;
		}

		.error-message i {
			margin-right: 10px;
		}

		@media (max-width: 992px) {
			.group-content {
				flex-direction: column;
			}

			.group-sidebar {
				width: 100%;
				order: -1; /* Размещаем сайдбар перед основным контентом */
			}
			
			.group-main {
				order: 1; /* Размещаем основной контент после сайдбара */
			}
		}

		@media (max-width: 768px) {
			.group-info {
				flex-direction: column;
				align-items: center;
				text-align: center;
			}

			.group-avatar {
				margin-right: 0;
				margin-bottom: 20px;
			}

			.group-meta {
				justify-content: center;
				flex-wrap: wrap;
			}

			.group-actions {
				margin-left: 0;
				margin-top: 20px;
				justify-content: center;
			}
		}

		.empty-state {
			text-align: center;
			padding: 50px 0;
			color: #888;
			font-size: 16px;
		}

		.dark-mode .empty-state {
			color: #999;
		}

		.empty-state i {
			margin-right: 10px;
		}

		/* Стили для модального окна редактирования */
		.modal-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: rgba(0, 0, 0, 0.5);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 1000;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s, visibility 0.3s;
		}

		.modal-overlay.active {
			opacity: 1;
			visibility: visible;
		}

		.modal-container {
			background-color: #fff;
			border-radius: 10px;
			width: 90%;
			max-width: 600px;
			max-height: 90vh;
			overflow-y: auto;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
			position: relative;
			display: flex;
			flex-direction: column;
		}

		.dark-mode .modal-container {
			background-color: #2d2d2d;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
		}

		.modal-header {
			padding: 15px 20px;
			border-bottom: 1px solid #eee;
			display: flex;
			justify-content: space-between;
			align-items: center;
			position: sticky;
			top: 0;
			background-color: inherit;
			z-index: 10;
		}

		.dark-mode .modal-header {
			border-bottom-color: #444;
		}

		.modal-title {
			font-size: 18px;
			font-weight: 600;
			color: #333;
		}

		.dark-mode .modal-title {
			color: #f5f5f5;
		}

		.modal-close {
			background: none;
			border: none;
			color: #888;
			font-size: 20px;
			cursor: pointer;
		}

		.dark-mode .modal-close {
			color: #bbb;
		}

		.modal-body {
			padding: 20px;
			flex: 1;
			overflow-y: auto;
		}

		.form-group {
			margin-bottom: 20px;
		}

		.form-label {
			display: block;
			margin-bottom: 8px;
			font-weight: 500;
			color: #333;
		}

		.dark-mode .form-label {
			color: #f5f5f5;
		}

		.form-input {
			width: 100%;
			padding: 10px 12px;
			border: 1px solid #ddd;
			border-radius: 5px;
			font-size: 14px;
			color: #333;
		}

		.dark-mode .form-input {
			background-color: #3d3d3d;
			border-color: #555;
			color: #f5f5f5;
		}

		.form-input:focus {
			border-color: #4a76a8;
			outline: none;
		}

		.dark-mode .form-input:focus {
			border-color: #5a86b8;
		}

		.form-textarea {
			min-height: 100px;
			resize: vertical;
		}

		.modal-footer {
			padding: 15px 20px;
			border-top: 1px solid #eee;
			display: flex;
			justify-content: flex-end;
			gap: 10px;
			position: sticky;
			bottom: 0;
			background-color: inherit;
			z-index: 10;
		}

		.dark-mode .modal-footer {
			border-top-color: #444;
		}

		.modal-btn {
			padding: 8px 15px;
			border-radius: 5px;
			font-size: 14px;
			font-weight: 500;
			cursor: pointer;
			transition: background-color 0.3s;
		}

		.modal-btn.primary {
			background-color: #4a76a8;
			color: white;
			border: none;
		}

		.modal-btn.primary:hover {
			background-color: #3a5b80;
		}

		.dark-mode .modal-btn.primary {
			background-color: #5a86b8;
		}

		.dark-mode .modal-btn.primary:hover {
			background-color: #4a76a8;
		}

		.modal-btn.secondary {
			background-color: transparent;
			color: #4a76a8;
			border: 1px solid #4a76a8;
		}

		.modal-btn.secondary:hover {
			background-color: rgba(74, 118, 168, 0.1);
		}

		.dark-mode .modal-btn.secondary {
			color: #5a86b8;
			border-color: #5a86b8;
		}

		.dark-mode .modal-btn.secondary:hover {
			background-color: rgba(90, 134, 184, 0.1);
		}

		.image-upload {
			display: flex;
			flex-direction: column;
			align-items: center;
			margin-top: 10px;
		}

		.image-preview {
			width: 100%;
			height: 150px;
			background-color: #f5f5f5;
			border: 2px dashed #ddd;
			border-radius: 5px;
			display: flex;
			align-items: center;
			justify-content: center;
			overflow: hidden;
			cursor: pointer;
		}

		.dark-mode .image-preview {
			background-color: #3d3d3d;
			border-color: #555;
		}

		.image-preview img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.image-preview i {
			font-size: 40px;
			color: #aaa;
		}

		.dark-mode .image-preview i {
			color: #888;
		}

		.upload-hint {
			margin-top: 5px;
			font-size: 12px;
			color: #888;
		}

		.dark-mode .upload-hint {
			color: #aaa;
		}

		.avatar-preview {
			width: 120px;
			height: 120px;
			border-radius: 50%;
			margin: 0 auto;
		}

		#avatar-crop-container, #cover-crop-container {
			max-width: 100%;
			height: 300px;
			overflow: hidden;
			margin-bottom: 15px;
		}

		.crop-controls {
			display: flex;
			justify-content: space-between;
			margin-top: 15px;
		}

		.crop-btn {
			padding: 8px 15px;
			border-radius: 5px;
			font-size: 14px;
			font-weight: 500;
			cursor: pointer;
			transition: background-color 0.3s;
		}

		.crop-btn.save {
			background-color: #4a76a8;
			color: white;
			border: none;
		}

		.crop-btn.cancel {
			background-color: transparent;
			color: #666;
			border: 1px solid #ddd;
		}

		.dark-mode .crop-btn.save {
			background-color: #5a86b8;
		}

		.dark-mode .crop-btn.cancel {
			color: #bbb;
			border-color: #555;
		}

		/* Стили для блока удаления группы */
		.delete-group-section {
			margin-top: 30px;
			padding-top: 20px;
			border-top: 1px solid #eee;
		}

		.dark-mode .delete-group-section {
			border-top-color: #444;
		}

		.delete-group-title {
			color: #e74c3c;
			font-size: 16px;
			font-weight: 600;
			margin-bottom: 15px;
		}

		.dark-mode .delete-group-title {
			color: #ff6b6b;
		}

		.delete-group-instructions {
			font-size: 14px;
			color: #666;
			margin-bottom: 15px;
			line-height: 1.5;
		}

		.dark-mode .delete-group-instructions {
			color: #bbb;
		}

		.delete-group-confirmation {
			margin-bottom: 15px;
		}

		.delete-btn {
			background-color: #e74c3c;
			color: white;
			border: none;
			padding: 8px 15px;
			border-radius: 5px;
			font-size: 14px;
			font-weight: 500;
			cursor: pointer;
			transition: background-color 0.3s;
		}

		.delete-btn:hover {
			background-color: #c0392b;
		}

		.delete-btn:disabled {
			background-color: #e74c3c80;
			cursor: not-allowed;
		}

		.dark-mode .delete-btn {
			background-color: #ff6b6b;
		}

		.dark-mode .delete-btn:hover {
			background-color: #e74c3c;
		}

		.dark-mode .delete-btn:disabled {
			background-color: #ff6b6b80;
		}

		/* Добавим стили для модального окна участников и табов */
		.members-modal-tabs {
			display: flex;
			margin-bottom: 20px;
			border-bottom: 1px solid #ddd;
		}

		.dark-mode .members-modal-tabs {
			border-bottom-color: #444;
		}

		.tab-button {
			padding: 10px 15px;
			background: none;
			border: none;
			border-bottom: 2px solid transparent;
			font-size: 14px;
			font-weight: 500;
			color: #666;
			cursor: pointer;
			transition: all 0.3s;
			margin-right: 10px;
		}

		.dark-mode .tab-button {
			color: #bbb;
		}

		.tab-button.active {
			color: #4a76a8;
			border-bottom-color: #4a76a8;
		}

		.dark-mode .tab-button.active {
			color: #5a86b8;
			border-bottom-color: #5a86b8;
		}

		.tab-content {
			display: none;
		}

		.tab-content.active {
			display: block;
		}

		.members-modal-list {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
			gap: 20px;
		}

		.members-modal-item {
			display: flex;
			flex-direction: column;
			align-items: center;
			cursor: pointer;
			transition: transform 0.2s;
		}

		.members-modal-item:hover {
			transform: translateY(-5px);
		}

		.members-modal-avatar {
			width: 80px;
			height: 80px;
			border-radius: 50%;
			overflow: hidden;
			margin-bottom: 8px;
			background-color: #eee;
		}

		.dark-mode .members-modal-avatar {
			background-color: #3d3d3d;
		}

		.members-modal-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.members-modal-name {
			font-size: 14px;
			font-weight: 500;
			color: #333;
			text-align: center;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.dark-mode .members-modal-name {
			color: #ddd;
		}

		.members-modal-role {
			font-size: 12px;
			color: #888;
			text-align: center;
		}

		.dark-mode .members-modal-role {
			color: #999;
		}

		.empty-tab-message {
			text-align: center;
			color: #888;
			padding: 30px 0;
		}

		.dark-mode .empty-tab-message {
			color: #999;
		}

		/* Стили для постов и создания постов */
		.post-item {
			background-color: #fff;
			border-radius: 10px;
			padding: 20px;
			margin-bottom: 20px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		}

		.dark-mode .post-item {
			background-color: #2d2d2d;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
		}

		.post-header {
			display: flex;
			align-items: center;
			margin-bottom: 15px;
		}

		.post-author-avatar {
			width: 50px;
			height: 50px;
			border-radius: 50%;
			overflow: hidden;
			margin-right: 15px;
			background-color: #eee;
		}

		.dark-mode .post-author-avatar {
			background-color: #3d3d3d;
		}

		.post-author-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.post-info {
			flex: 1;
		}

		.post-author-name {
			font-weight: 600;
			color: #333;
			margin-bottom: 3px;
		}

		.dark-mode .post-author-name {
			color: #f5f5f5;
		}

		.post-date {
			font-size: 12px;
			color: #888;
		}

		.dark-mode .post-date {
			color: #999;
		}

		.post-content {
			margin-bottom: 15px;
			color: #333;
			line-height: 1.5;
		}

		.dark-mode .post-content {
			color: #ddd;
		}

		.post-image {
			width: 100%;
			max-height: 400px;
			object-fit: contain;
			border-radius: 8px;
			margin-bottom: 15px;
		}

		.post-actions {
			display: flex;
			align-items: center;
			border-top: 1px solid #eee;
			padding-top: 15px;
			color: #666;
		}

		.dark-mode .post-actions {
			border-top-color: #333;
		}

		.post-action-btn {
			display: flex;
			align-items: center;
			background: none;
			border: none;
			color: #666;
			font-size: 14px;
			padding: 5px 10px;
			margin-right: 15px;
			cursor: pointer;
			transition: color 0.3s;
		}

		.dark-mode .post-action-btn {
			color: #bbb;
		}

		.post-action-btn:hover {
			color: #4a76a8;
		}

		.dark-mode .post-action-btn:hover {
			color: #5a86b8;
		}

		.post-action-btn i {
			margin-right: 5px;
		}

		.create-post-container {
			display: flex;
			justify-content: flex-end;
			margin-bottom: 20px;
		}

		.create-post-btn, .propose-post-btn {
			display: inline-flex;
			align-items: center;
			padding: 8px 15px;
			background-color: #4a76a8;
			color: white;
			border: none;
			border-radius: 5px;
			font-size: 14px;
			font-weight: 500;
			cursor: pointer;
			transition: background-color 0.3s;
			margin-left: 10px;
		}

		.create-post-btn:hover, .propose-post-btn:hover {
			background-color: #3a5b80;
		}

		.dark-mode .create-post-btn, .dark-mode .propose-post-btn {
			background-color: #5a86b8;
		}

		.dark-mode .create-post-btn:hover, .dark-mode .propose-post-btn:hover {
			background-color: #4a76a8;
		}

		.create-post-btn i, .propose-post-btn i {
			margin-right: 5px;
		}

		.post-image-preview {
			width: 100%;
			height: 200px;
			background-color: #f5f5f5;
			border: 2px dashed #ddd;
			border-radius: 5px;
			display: flex;
			align-items: center;
			justify-content: center;
			overflow: hidden;
			cursor: pointer;
			margin-top: 10px;
		}

		.dark-mode .post-image-preview {
			background-color: #3d3d3d;
			border-color: #555;
		}

		.post-image-preview img {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		.post-image-preview i {
			font-size: 40px;
			color: #aaa;
		}

		.dark-mode .post-image-preview i {
			color: #888;
		}

		.post-tabs {
			display: flex;
			margin-bottom: 20px;
			border-bottom: 1px solid #ddd;
		}

		.dark-mode .post-tabs {
			border-bottom-color: #444;
		}

		.post-tab {
			padding: 10px 15px;
			background: none;
			border: none;
			border-bottom: 2px solid transparent;
			font-size: 14px;
			font-weight: 500;
			color: #666;
			cursor: pointer;
			transition: all 0.3s;
			margin-right: 10px;
		}

		.dark-mode .post-tab {
			color: #bbb;
		}

		.post-tab.active {
			color: #4a76a8;
			border-bottom-color: #4a76a8;
		}

		.dark-mode .post-tab.active {
			color: #5a86b8;
			border-bottom-color: #5a86b8;
		}

		.pending-post-item {
			border-left: 3px solid #f39c12;
		}

		.dark-mode .pending-post-item {
			border-left-color: #f5b041;
		}

		.pending-post-status {
			display: flex;
			justify-content: space-between;
			margin-top: 10px;
			padding-top: 10px;
			border-top: 1px solid #eee;
		}

		.dark-mode .pending-post-status {
			border-top-color: #444;
		}

		.approve-btn, .reject-btn {
			padding: 5px 10px;
			border-radius: 4px;
			font-size: 13px;
			font-weight: 500;
			cursor: pointer;
		}

		.approve-btn {
			background-color: #2ecc71;
			color: white;
			border: none;
		}

		.approve-btn:hover {
			background-color: #27ae60;
		}

		.reject-btn {
			background-color: #e74c3c;
			color: white;
			border: none;
		}

		.reject-btn:hover {
			background-color: #c0392b;
		}

		.pending-badge {
			display: inline-block;
			background-color: #f39c12;
			color: white;
			font-size: 12px;
			padding: 2px 8px;
			border-radius: 10px;
			margin-left: 10px;
		}

		.dark-mode .pending-badge {
			background-color: #f5b041;
			color: #333;
		}

		/* Стили для блока создания поста */
		.create-post-inline {
			display: flex;
			align-items: flex-start;
			padding: 15px;
			background-color: #fff;
			border-radius: 10px;
			margin-bottom: 20px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		}

		.dark-mode .create-post-inline {
			background-color: #2d2d2d;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
		}

		.create-post-inline .post-author-avatar {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			overflow: hidden;
			margin-right: 15px;
			background-color: #eee;
			flex-shrink: 0;
		}

		.dark-mode .create-post-inline .post-author-avatar {
			background-color: #3d3d3d;
		}

		.create-post-inline .post-author-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.post-input-area {
			flex: 1;
			display: flex;
			flex-direction: column;
		}

		#inline-post-content {
			width: 100%;
			padding: 10px 15px;
			border: 1px solid #ddd;
			border-radius: 20px;
			font-size: 14px;
			resize: none;
			min-height: 40px; /* Примерная высота как у поля ввода */
			line-height: 1.4;
			margin-bottom: 10px;
			background-color: #f0f2f5;
			color: #333;
			transition: min-height 0.2s ease;
		}

		.dark-mode #inline-post-content {
			background-color: #3a3b3c;
			border-color: #444;
			color: #e4e6eb;
		}

		#inline-post-content::placeholder {
			color: #666;
		}

		.dark-mode #inline-post-content::placeholder {
			color: #aaa;
		}

		#inline-post-content:focus {
			outline: none;
			border-color: #aaa;
			min-height: 80px; /* Увеличиваем высоту при фокусе */
		}

		.dark-mode #inline-post-content:focus {
			border-color: #666;
		}

		.post-inline-actions {
			display: flex;
			justify-content: flex-end;
			align-items: center;
		}

		.post-inline-attach-btn,
		.post-inline-send-btn {
			background: none;
			border: none;
			color: #4a76a8; /* Цвет как у основных кнопок */
			font-size: 14px; /* Размер шрифта как у других кнопок */
			font-weight: 500; /* Сделать текст жирнее */
			cursor: pointer;
			padding: 8px 15px; /* Добавим отступы */
			border-radius: 20px; /* Скруглим углы */
			background-color: #e7f3ff; /* Легкий фон для акцента */
			margin-left: 10px;
			transition: background-color 0.3s, color 0.3s;
			display: inline-flex; /* Для выравнивания иконки и текста */
			align-items: center;
		}

		.dark-mode .post-inline-attach-btn,
		.dark-mode .post-inline-send-btn {
			color: #5a86b8;
			background-color: #3a3b3c;
		}

		.post-inline-attach-btn:hover,
		.post-inline-send-btn:hover {
			background-color: #d0e7ff; /* Чуть темнее фон при наведении */
		}

		.dark-mode .post-inline-attach-btn:hover,
		.dark-mode .post-inline-send-btn:hover {
			background-color: #4f4f4f;
		}

		.post-inline-send-btn:disabled {
			background-color: #f0f2f5;
			color: #bdc1c6;
			cursor: not-allowed;
		}

		.dark-mode .post-inline-send-btn:disabled {
			background-color: #242526;
			color: #555;
		}

		.post-inline-send-btn i {
			margin-right: 5px; /* Отступ между иконкой и текстом */
		}

		.post-author-avatar, .post-author-name {
			transition: opacity 0.2s ease;
		}

		.post-author-avatar {
			cursor: pointer;
		}

		.post-author-name .author-link {
			cursor: pointer;
			transition: opacity 0.2s ease;
			display: inline-block; /* Чтобы эффект наведения не распространялся на весь блок */
			font-size: 12px;
			color: #888;
		}

		.post-author-name .author-name-text {
			display: inline-block; /* Чтобы эффект наведения не распространялся на другие элементы */
			cursor: pointer;
		}

		.post-author-avatar:hover, 
		.post-author-name .author-name-text:hover {
			opacity: 0.8;
		}

		.post-author-name .author-link:hover {
			opacity: 0.8;
		}

		.post-comments-section {
			display: none;
			margin-top: 10px;
			border-top: 1px solid #eee;
			padding-top: 10px;
		}
		
		.dark-mode .post-comments-section {
			border-top-color: #444;
		}
		
		.post-comments-section.active {
			display: block;
		}
		
		.comments-list {
			display: flex;
			flex-direction: column;
			gap: 15px;
			margin-bottom: 15px;
		}
		
		.comment {
			display: flex;
			gap: 10px;
			padding: 5px;
			border-radius: 10px;
			transition: background-color 0.3s;
		}
		
		.comment-avatar-link {
			text-decoration: none;
			flex-shrink: 0;
		}
		
		.comment-avatar {
			width: 36px;
			height: 36px;
			border-radius: 50%;
			object-fit: cover;
		}
		
		.comment-main {
			flex-grow: 1;
		}
		
		.comment-header {
			display: flex;
			align-items: center;
			margin-bottom: 5px;
		}
		
		.comment-author {
			font-weight: 500;
			color: #333;
			margin-right: 10px;
			text-decoration: none;
		}
		
		.dark-mode .comment-author {
			color: #f5f5f5;
		}
		
		.comment-date {
			font-size: 12px;
			color: #888;
		}
		
		.dark-mode .comment-date {
			color: #999;
		}
		
		.reply-info {
			font-size: 12px;
			color: #888;
			margin-bottom: 5px;
			padding: 2px 5px;
			background-color: rgba(0, 0, 0, 0.03);
			border-radius: 4px;
			display: inline-block;
			cursor: pointer;
		}
		
		.dark-mode .reply-info {
			color: #aaa;
			background-color: rgba(255, 255, 255, 0.05);
		}
		
		.reply-author {
			color: #4a76a8;
			font-weight: 500;
		}
		
		.dark-mode .reply-author {
			color: #5a86b8;
		}
		
		.reply-info-divider {
			margin: 0 5px;
			color: #ccc;
		}
		
		.dark-mode .reply-info-divider {
			color: #666;
		}
		
		.comment-content {
			margin-bottom: 8px;
			white-space: pre-wrap;
			word-break: break-word;
		}
		
		.comment-images {
			display: grid;
			gap: 5px;
			margin-bottom: 8px;
			grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
		}
		
		.comment-images.count-1 {
			grid-template-columns: minmax(0, 300px);
		}
		
		.comment-image-item {
			cursor: pointer;
			border-radius: 8px;
			overflow: hidden;
			aspect-ratio: 1;
			padding-bottom: 60%;
		}
		
		.comment-image-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}
		
		.comment-image-item .video-container {
			position: relative;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
		
		.comment-image-item .video-container video {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}
		
		.comment-image-item .video-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.2);
			display: flex;
			justify-content: center;
			align-items: center;
			cursor: pointer;
		}
		
		.comment-image-item .video-overlay::before {
			content: '\f144';
			font-family: 'Font Awesome 5 Free';
			font-size: 24px;
			color: #fff;
			opacity: 0.8;
		}
		
		.comment-votes {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 5px;
		}
		
		.reply-btn {
			background: none;
			border: none;
			color: #4a76a8;
			font-size: 12px;
			cursor: pointer;
			padding: 0;
			display: flex;
			align-items: center;
			gap: 5px;
		}
		
		.dark-mode .reply-btn {
			color: #5a86b8;
		}
		
		.reply-btn.delete {
			color: #e53935;
		}
		
		.dark-mode .reply-btn.delete {
			color: #f44336;
		}
		
		.reply-btn i {
			font-size: 12px;
		}
		
		.reply-form {
			display: none;
			gap: 10px;
			margin-top: 10px;
			margin-bottom: 5px;
		}
		
		.reply-form.active {
			display: flex;
		}
		
		.comment-replies {
			margin-left: 10px;
			margin-top: 10px;
			border-left: none;
			padding-left: 15px;
			display: flex;
			flex-direction: column;
			gap: 15px;
		}
		
		.dark-mode .comment-replies {
			border-left-color: #444;
		}
		
		.no-comments {
			color: #888;
			text-align: center;
			padding: 20px 0;
			font-style: italic;
		}
		
		.dark-mode .no-comments {
			color: #aaa;
		}

		.post-comments-section.always-visible {
			display: block;
		}
		
		/* Стили для скрытых ответов */
		.hidden-replies {
			overflow: hidden;
			max-height: 0;
			opacity: 0;
			transition: max-height 0.5s ease-in, opacity 0.3s ease-in;
		}
		
		.hidden-replies.expanded {
			max-height: none;
			opacity: 1;
			transition: max-height 0.5s ease-out, opacity 0.3s ease-out;
			border-left: 1px solid #eee;
			margin-left: -16px;
			padding-left: 15px;
		}
		
		.dark-mode .hidden-replies.expanded {
			border-left-color: #444;
		}
		
		/* Добавляем стили для анимации комментариев внутри скрытого контейнера */
		.hidden-replies .comment {
			opacity: 0;
			transform: translateY(10px);
			transition: opacity 0.3s ease-in, transform 0.3s ease-in;
		}
		
		.hidden-replies.expanded .comment {
			opacity: 1;
			transform: translateY(0);
			transition: opacity 0.3s ease-out, transform 0.3s ease-out;
		}
		
		/* Стили для кнопки "Показать ответы" */
		.show-more-replies {
			margin-top: 0.5rem;
			padding: 0.25rem 0.5rem;
			font-size: 0.85em;
			background: var(--bg-color, #f5f5f5);
			color: #4a76a8;
			border: 1px solid #e0e0e0;
			border-radius: 4px;
			cursor: pointer;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: auto;
			transition: background-color 0.2s;
			width: 250px;
		}
		
		.show-more-replies:hover {
			background: rgba(0, 0, 0, 0.03);
		}
		
		.show-more-replies i {
			margin-right: 0.5rem;
		}
		
		.dark-mode .show-more-replies {
			background: #333;
			color: #5a86b8;
			border-color: #444;
		}
		
		.dark-mode .show-more-replies:hover {
			background: #444;
		}
		
		/* Добавляем анимацию подсветки новых комментариев */
		@keyframes newCommentHighlight {
			0% {
				background: rgba(74, 118, 168, 0.2);
			}
			100% {
				background: transparent;
			}
		}
		
		/* Улучшаем подсветку при прокрутке к комментарию */
		@keyframes highlightComment {
			0% {
				background: transparent;
			}
			20% {
				background: rgba(74, 118, 168, 0.2);
			}
			80% {
				background: rgba(74, 118, 168, 0.2);
			}
			100% {
				background: transparent;
			}
		}
		
		.dark-mode .comment.new-comment {
			animation-name: darkModeNewCommentHighlight;
		}
		
		@keyframes darkModeNewCommentHighlight {
			0% {
				background: rgba(90, 134, 184, 0.2);
			}
			100% {
				background: transparent;
			}
		}
		
		/* Стили для загрузки изображений */
		.image-upload-container {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-top: 5px;
		}
		
		.image-upload-button {
			background: none;
			border: none;
			color: #4a76a8;
			font-size: 12px;
			cursor: pointer;
			padding: 5px 10px;
			border-radius: 4px;
			display: flex;
			align-items: center;
			gap: 5px;
			transition: background-color 0.2s;
		}
		
		.image-upload-button:hover {
			background-color: rgba(74, 118, 168, 0.1);
		}
		
		.dark-mode .image-upload-button {
			color: #5a86b8;
		}
		
		.dark-mode .image-upload-button:hover {
			background-color: rgba(90, 134, 184, 0.2);
		}
		
		.image-upload-input {
			display: none;
		}
		
		.image-counter {
			font-size: 12px;
			color: #888;
		}
		
		.dark-mode .image-counter {
			color: #aaa;
		}
		
		.image-preview-container {
			display: none;
			margin-top: 10px;
			width: 100%;
		}
		
		.image-gallery {
			display: grid;
			grid-template-columns: repeat(5, 1fr);
			gap: 5px;
			margin-bottom: 5px;
		}
		
		.image-preview-item {
			position: relative;
			width: 100%;
			aspect-ratio: 1;
			border-radius: 4px;
			overflow: hidden;
		}
		
		.image-preview-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			display: block;
		}
		
		.remove-image-btn {
			position: absolute;
			top: 2px;
			right: 2px;
			width: 20px;
			height: 20px;
			background-color: rgba(0, 0, 0, 0.5);
			color: white;
			border: none;
			border-radius: 50%;
			display: flex;
			justify-content: center;
			align-items: center;
			cursor: pointer;
			font-size: 10px;
			transition: background-color 0.2s ease;
			z-index: 2;
		}
		
		.remove-image-btn:hover {
			background-color: rgba(255, 0, 0, 0.8);
		}
		
		.upload-spinner, .upload-error {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: rgba(0, 0, 0, 0.4);
			z-index: 1;
		}
		
		.upload-error {
			background-color: rgba(255, 0, 0, 0.4);
		}
		
		.upload-spinner i, .upload-error i {
			color: white;
			font-size: 20px;
		}
		
		.image-preview-item.uploading img {
			opacity: 0.7;
		}
		
		.clear-all-images {
			background: none;
			border: none;
			color: #e53935;
			font-size: 12px;
			cursor: pointer;
			padding: 5px;
			border-radius: 4px;
			display: flex;
			align-items: center;
			gap: 5px;
			margin-left: auto;
		}
		
		.dark-mode .clear-all-images {
			color: #f44336;
		}
		
		.clear-all-images:hover {
			background-color: rgba(229, 57, 53, 0.1);
		}
		
		/* Стили для изображений в комментариях */
		.comment-images {
			display: grid;
			gap: 5px;
			margin: 5px 0;
			grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
		}
		
		.comment-images.count-1 {
			grid-template-columns: minmax(0, 250px);
		}
		
		.comment-image-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			transition: transform 0.2s;
		}
		
		.comment-image-item .video-container {
			position: relative;
			width: 100%;
			height: 100%;
			overflow: hidden;
		}
		
		.comment-image-item .video-container video {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}
		
		.comment-image-item .video-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.2);
			display: flex;
			justify-content: center;
			align-items: center;
			cursor: pointer;
		}
		
		.comment-image-item .video-overlay::before {
			content: '\f144';
			font-family: 'Font Awesome 5 Free';
			font-size: 24px;
			color: #fff;
			opacity: 0.8;
		}
		
		.comment-image-item:hover img {
			transform: scale(1.05);
		}
		
		.dark-mode .post-comments-section .delete-comment-button:hover {
			color: #e57373;
		}
		
		.image-nav-button {
			width: 50px;
			height: 50px;
			background-color: rgba(0, 0, 0, 0.5);
			border: none;
			border-radius: 50%;
			color: #fff;
			font-size: 20px;
			display: flex;
			justify-content: center;
			align-items: center;
			cursor: pointer;
			pointer-events: auto;
			transition: background-color 0.3s ease;
		}
		
		.image-nav-button:hover {
			background-color: rgba(0, 0, 0, 0.8);
		}
		
		.image-counter-indicator {
			position: absolute;
			bottom: 15px;
			left: 50%;
			transform: translateX(-50%);
			background-color: rgba(0, 0, 0, 0.6);
			color: #fff;
			padding: 5px 10px;
			border-radius: 15px;
			font-size: 14px;
			z-index: 1;
		}
		
		.dark-mode .image-modal {
			background-color: rgba(0, 0, 0, 0.9);
		}
		
		/* Стили для анимации загрузки */
		.modal-image-container.loading::after {
			content: '';
			position: absolute;
			width: 50px;
			height: 50px;
			border: 5px solid rgba(255, 255, 255, 0.3);
			border-top: 5px solid #fff;
			border-radius: 50%;
			animation: spin 1s linear infinite;
		}
		
		@keyframes spin {
			0% { transform: rotate(0deg); }
			100% { transform: rotate(360deg); }
		}
		
		/* Стили для галереи изображений в постах */
		.post-images {
			margin: 10px 0;
			display: revert;
			flex-wrap: wrap;
			gap: 5px;
		}
		
		.post-images-gallery {
			display: grid;
			grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
			grid-gap: 5px;
			margin: 10px 0;
		}
		
		.post-images-gallery.count-1 {
			grid-template-columns: minmax(0, 300px);
		}
		
		.post-images-gallery.count-2 {
			grid-template-columns: repeat(2, 1fr);
		}
		
		.post-images-gallery.count-3 {
			grid-template-columns: repeat(3, 1fr);
		}
		
		.post-images-gallery.count-4 {
			grid-template-columns: repeat(2, 1fr);
		}
		
		.post-images-gallery.count-5,
		.post-images-gallery.count-6 {
			grid-template-columns: repeat(3, 1fr);
		}
		
		.post-image-item {
			position: relative;
			overflow: hidden;
			border-radius: 8px;
			max-width: 500px;
		}
		
		.post-image-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			transition: transform 0.3s ease;
			cursor: pointer;
		}
		
		.post-image-item video {
			width: 100%;
			height: 100%;
			object-fit: cover;
			transition: transform 0.3s ease;
			cursor: pointer;
		}
		
		.post-image-item .video-container {
			position: relative;
			width: 100%;
			height: 100%;
			overflow: hidden;
			border-radius: 8px;
		}
		
		.post-image-item .video-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0,0,0,0.2);
			display: flex;
			justify-content: center;
			align-items: center;
			cursor: pointer;
		}
		
		.post-image-item .video-overlay::before {
			content: '\f144';
			font-family: 'Font Awesome 5 Free';
			font-size: 32px;
			color: #fff;
			opacity: 0.8;
		}
		
		.post-image-item:hover img {
			transform: scale(1.05);
		}
		
		/* Стили для модального окна просмотра изображений */
		.image-modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.8);
			z-index: 1000;
			justify-content: center;
			align-items: center;
			padding: 20px;
			box-sizing: border-box;
		}
		
		.dark-mode .image-modal {
			background: rgba(0, 0, 0, 0.9);
		}
		
		.light-mode .image-modal {
			background: rgba(0, 0, 0, 0.7);
		}
		
		.image-modal.active {
			display: flex;
		}
		
		.modal-content {
			display: flex;
			width: 100%;
			max-width: 1200px;
			height: 90vh;
			position: relative;
			background: var(--bg-color);
			border-radius: 8px;
			overflow: hidden;
		}
		
		.modal-image-container {
			flex: 2;
			display: flex;
			justify-content: center;
			align-items: center;
			max-height: 100%;
			overflow: hidden;
			min-width: 0;
			position: relative;
		}
		
		.modal-image {
			max-width: 100%;
			max-height: 100%;
			object-fit: contain;
		}
		
		.modal-video {
			max-width: 100%;
			max-height: 80vh;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
			background-color: #000;
		}
		
		.close-modal {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 40px;
			height: 40px;
			background: rgba(0, 0, 0, 0.5);
			border-radius: 50%;
			display: flex;
			justify-content: center;
			align-items: center;
			color: white;
			font-size: 30px;
			cursor: pointer;
			z-index: 1001;
			transition: background 0.3s ease;
		}
		
		.dark-mode .close-modal {
			background: rgba(0, 0, 0, 0.7);
		}
		
		.light-mode .close-modal {
			background: rgba(255, 255, 255, 0.3);
		}
		
		.close-modal:hover {
			background: rgba(255, 0, 0, 0.7);
			transform: scale(1.1);
		}
		
		.dark-mode .close-modal:hover {
			background: rgba(255, 0, 0, 0.7);
		}
		
		.light-mode .close-modal:hover {
			background: rgba(255, 0, 0, 0.7);
		}
		
		.image-nav-buttons {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 0 20px;
			box-sizing: border-box;
			pointer-events: none;
		}
		
		.image-nav-button {
			width: 50px;
			height: 50px;
			background: rgba(0, 0, 0, 0.5);
			border-radius: 50%;
			display: flex;
			justify-content: center;
			align-items: center;
			color: white;
			font-size: 20px;
			cursor: pointer;
			transition: background 0.3s ease, transform 0.3s ease;
			pointer-events: auto;
		}
		
		.dark-mode .image-nav-button {
			background: rgba(0, 0, 0, 0.7);
		}
		
		.light-mode .image-nav-button {
			background: rgba(255, 255, 255, 0.3);
		}
		
		.image-nav-button.prev {
			margin-right: auto;
			transform: translateX(-10px);
		}
		
		.image-nav-button.next {
			margin-left: auto;
			transform: translateX(10px);
		}
		
		.image-nav-button:hover {
			background: rgba(0, 0, 0, 0.7);
			transform: scale(1.1);
		}
		
		.dark-mode .image-nav-button:hover {
			background: rgba(0, 0, 0, 0.9);
		}
		
		.light-mode .image-nav-button:hover {
			background: rgba(0, 0, 0, 0.6);
		}
		
		.image-nav-button.prev:hover {
			transform: translateX(-10px) scale(1.1);
		}
		
		.image-nav-button.next:hover {
			transform: translateX(10px) scale(1.1);
		}
		
		.image-counter-indicator {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.5);
			color: white;
			padding: 8px 15px;
			border-radius: 30px;
			font-size: 14px;
			z-index: 1;
		}
		
		.dark-mode .image-counter-indicator {
			background: rgba(0, 0, 0, 0.7);
		}
		
		.light-mode .image-counter-indicator {
			background: rgba(0, 0, 0, 0.6);
		}
		
		@media (max-width: 768px) {
			.modal-content {
				flex-direction: column;
				height: auto;
				max-height: 90vh;
			}
			
			.modal-image-container {
				flex: 1;
				max-height: 70vh;
			}
			
			.dark-mode .modal-image-container {
				background: rgba(0, 0, 0, 0.8);
			}
			
			.light-mode .modal-image-container {
				background: rgba(255, 255, 255, 0.8);
			}
		}

		.image-modal .modal-content {
			position: relative;
			max-width: 90vw;
			max-height: 90vh;
			margin: 0 auto;
			text-align: center;
			margin-top: 5vh;
		}

		.image-modal .modal-image {
			max-width: 100%;
			max-height: 80vh;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
			transition: opacity 0.3s ease;
		}

		.image-modal .modal-video {
			max-width: 100%;
			max-height: 80vh;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
			transition: opacity 0.3s ease;
		}

		/* Стили для drag and drop изображений */
		.image-preview-item {
			position: relative;
			width: 80px;
			height: 80px;
			margin: 5px;
			border-radius: 8px;
			overflow: hidden;
			box-shadow: 0 2px 5px rgba(0,0,0,0.1);
			cursor: move;
			transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease;
		}

		.image-preview-item.dragging {
			z-index: 10;
			box-shadow: 0 5px 15px rgba(0,0,0,0.2);
		}

		.image-preview-item.drag-over {
			transform: scale(1.05);
			box-shadow: 0 8px 20px rgba(0,0,0,0.3);
			border: 2px dashed #4a89dc;
		}

		.image-gallery, .post-image-gallery {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-bottom: 10px;
		}

		/* Обновленные стили для контейнера превью изображений */
		.image-preview-container, .post-image-preview-container {
			margin-top: 10px;
			padding: 10px;
			border-radius: 8px;
			background-color: var(--bg-secondary);
			border: 1px solid var(--border-color);
		}

		.image-preview-container.active, .post-image-preview-container.active {
			display: block;
		}
	</style>

	<script>
		(function () {
			const savedTheme = localStorage.getItem('theme');
			const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

			// Обновляем логику установки темы
			if (savedTheme === 'system') {
				document.documentElement.style.visibility = 'hidden';
				document.documentElement.classList.add(prefersDark ? 'dark-mode' : 'light-mode');

				document.addEventListener('DOMContentLoaded', () => {
					document.body.classList.add(prefersDark ? 'dark-mode' : 'light-mode');
					document.documentElement.classList.remove(prefersDark ? 'dark-mode' : 'light-mode');
					document.documentElement.style.visibility = 'visible';
				});
			} else {
				const theme = savedTheme || (prefersDark ? 'dark-mode' : 'light-mode');
				document.documentElement.style.visibility = 'hidden';
				document.documentElement.classList.add(theme);

				document.addEventListener('DOMContentLoaded', () => {
					document.body.classList.add(theme);
					document.documentElement.classList.remove(theme);
					document.documentElement.style.visibility = 'visible';
				});
			}

			// Добавляем слушатель изменения системной темы
			if (savedTheme === 'system') {
				window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
					document.body.classList.remove('dark-mode', 'light-mode');
					document.body.classList.add(e.matches ? 'dark-mode' : 'light-mode');
				});
			}
		})();
	</script>

	<script type="module">
		import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js';
		import {
			getAuth,
			onAuthStateChanged
		} from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js';
		import { 
			getDatabase, 
			ref, 
			get, 
			set,
			push,
			query,
			orderByChild,
			equalTo,
			onValue,
			update,
			remove,
			serverTimestamp,
			child
		} from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js';
		import {
			getStorage,
			ref as storageRef,
			uploadBytes,
			uploadBytesResumable,
			getDownloadURL
		} from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-storage.js';
		import { initializeSidebar } from './sidebar_old.js'; // Добавляем импорт сайдбара

		// Инициализация Firebase
		const firebaseConfig = {
			apiKey: "AIzaSyCPQajYeeRG-GyQHhwlZ08nI5-BT36XpaU",
			authDomain: "ochat-9cfc9.firebaseapp.com",
			databaseURL: "https://ochat-9cfc9-default-rtdb.europe-west1.firebasedatabase.app",
			projectId: "ochat-9cfc9",
			storageBucket: "ochat-9cfc9.appspot.com",
			messagingSenderId: "190209379577",
			appId: "1:190209379577:web:a57171ab4b1f55a49f6628",
			measurementId: "G-KNRXS2ZKZ9"
		};

		const app = initializeApp(firebaseConfig);
		const auth = getAuth(app);
		const db = getDatabase(app);
		const storage = getStorage(app);

		// Вызов инициализации сайдбара после загрузки DOM
		document.addEventListener('DOMContentLoaded', () => {
		  initializeSidebar();
		  // Можно добавить другие инициализации сюда, если нужно
		});

		// Получение ID группы из URL
		const urlParams = new URLSearchParams(window.location.search);
		const groupId = urlParams.get('id');

		if (!groupId) {
			showError('ID группы не указан');
		} else {
			// Проверка авторизации
			onAuthStateChanged(auth, (user) => {
				if (user) {
					// Пользователь авторизован
					console.log('User is signed in:', user.uid);
					// Загружаем данные группы
					loadGroupData(groupId, user.uid);
				} else {
					// Пользователь не авторизован, перенаправляем на страницу входа
					console.log('User is not signed in');
					window.location.href = 'index.html';
				}
			});
		}

		// Функция для загрузки данных группы
		async function loadGroupData(groupId, userId) {
			try {
				// Получаем данные группы из Firebase
				const groupRef = ref(db, `groups/${groupId}`);
				const groupSnapshot = await get(groupRef);

				if (!groupSnapshot.exists()) {
					showError('Группа не найдена');
					return;
				}

				const groupData = groupSnapshot.val();
				groupData.id = groupId;

				// Обновляем заголовок страницы
				document.title = `${groupData.name} - Группа`;

				// Отображаем информацию о группе
				renderGroupInfo(groupData, userId);

				// Загружаем участников группы
				await loadGroupMembers(groupData);
                
                // Загружаем посты группы
                await loadGroupPosts(groupId, userId, groupData);

				// Сразу показываем контейнер с информацией о группе
				document.querySelector('.group-container').style.display = 'block';
				
				// Слушаем изменения в членах группы в реальном времени
				const groupMembersRef = ref(db, `groups/${groupId}/members`);
				onValue(groupMembersRef, (snapshot) => {
					if (snapshot.exists()) {
						const updatedMembers = snapshot.val();
						// Обновляем интерфейс при изменении состава участников
						loadGroupMembers({ ...groupData, members: updatedMembers });
						
						// Обновляем количество участников в шапке
						const memberCountEl = document.querySelector('.group-meta-item:first-child');
						const memberCount = Object.keys(updatedMembers).length;
						memberCountEl.innerHTML = `
							<i class="fas fa-users"></i> 
							${memberCount} 
							${getWordForm(memberCount, ['участник', 'участника', 'участников'])}
						`;
						
						// Обновляем кнопки действий
						updateActionButtons(updatedMembers, userId, groupId);
                        
                        // Обновляем секцию постов с учетом новой роли пользователя
                        // updatePostSection(updatedMembers[userId]?.role === 'admin', groupId); // Удаляем этот вызов
					}
				});
				
				// Слушаем изменения в информации о группе в реальном времени
				const groupInfoRef = ref(db, `groups/${groupId}`);
				onValue(groupInfoRef, (snapshot) => {
					if (snapshot.exists()) {
						const updatedGroupData = snapshot.val();
						updatedGroupData.id = groupId;
						
						// Обновляем заголовок страницы
						document.title = `${updatedGroupData.name} - Группа`;
						
						// Обновляем информацию о группе
						renderGroupInfo(updatedGroupData, userId);
					}
				});
				
			} catch (error) {
				console.error('Error loading group data:', error);
				showError('Ошибка при загрузке данных группы');
			}
		}
        
        // Функция для загрузки постов группы
        async function loadGroupPosts(groupId, userId, groupData) {
            try {
                const isAdmin = groupData.members && 
                            groupData.members[userId] && 
                            groupData.members[userId].role === 'admin';
                const isMember = groupData.members && userId in groupData.members;
                
                // Обновляем секцию постов
                updatePostSection(isAdmin, groupId, userId); // Передаем userId
                
                // Загружаем опубликованные посты
                const postsRef = ref(db, `groupPosts/${groupId}`);
                // Изменяем запрос для получения постов в порядке убывания по времени создания
                const postsQuery = query(postsRef, orderByChild('timestamp'));
                
                // Создаем Set для отслеживания уже отрендеренных постов
                let renderedPosts = new Set();
                
                // Слушаем изменения в постах в реальном времени
                onValue(postsQuery, async (snapshot) => {
                    const postsContainer = document.querySelector('.posts-list');
                    
                    if (!snapshot.exists()) {
                        postsContainer.innerHTML = `
                            <div class="empty-state">
                                <i class="fas fa-file-alt"></i>
                                <p>В этой группе пока нет постов</p>
                            </div>
                        `;
                        renderedPosts.clear(); // Очищаем список отрендеренных постов
                        return;
                    }
                    
                    // Удаляем сообщение о пустом списке, если оно есть
                    const emptyState = postsContainer.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.remove();
                    }
                    
                    // Собираем все посты и сортируем их по времени (сначала новые)
                    const posts = [];
                    snapshot.forEach((childSnapshot) => {
                        const post = childSnapshot.val();
                        post.id = childSnapshot.key;
                        posts.push(post);
                    });
                    
                    // Сортируем посты по убыванию времени (новые сверху)
                    posts.sort((a, b) => b.timestamp - a.timestamp);
                    
                    // Если это первая загрузка, отрисовываем все посты
                    if (renderedPosts.size === 0) {
                        // Очищаем контейнер перед первой загрузкой
                        postsContainer.innerHTML = '';
                        
                        // Добавляем все посты и отмечаем их как отрендеренные
                        for (const post of posts) {
                            const postElement = document.createElement('div');
                            await renderPost(post, postElement, false, userId, isAdmin, groupId);
                            if (postElement.firstChild) {
                                postsContainer.appendChild(postElement.firstChild);
                                renderedPosts.add(post.id);
                            }
                        }
                    } else {
                        // Находим новые посты, которых еще нет в контейнере
                        const newPosts = posts.filter(post => !renderedPosts.has(post.id));
                        
                        // Если есть новые посты, добавляем их в начало списка
                        if (newPosts.length > 0) {
                            for (const post of newPosts) {
                                const postElement = document.createElement('div');
                                await renderPost(post, postElement, false, userId, isAdmin, groupId);
                                if (postElement.firstChild) {
                                    // Вставляем новый пост в начало списка
                                    postsContainer.insertBefore(postElement.firstChild, postsContainer.firstChild);
                                    renderedPosts.add(post.id);
                                }
                            }
                        }
                        
                        // Проверяем, есть ли удаленные посты и удаляем их из DOM
                        const currentPostIds = new Set(posts.map(post => post.id));
                        for (const renderedId of renderedPosts) {
                            if (!currentPostIds.has(renderedId)) {
                                const postElement = document.getElementById(`post-${renderedId}`);
                                if (postElement) {
                                    postElement.remove();
                                }
                                renderedPosts.delete(renderedId);
                            }
                        }
                    }
                });
                
                // Если пользователь администратор, загружаем также предложенные посты
                if (isAdmin) {
                    const proposedPostsRef = ref(db, `proposedGroupPosts/${groupId}`);
                    const proposedPostsQuery = query(proposedPostsRef, orderByChild('timestamp'));
                    
                    // Слушаем изменения в предложенных постах
                    onValue(proposedPostsQuery, async (snapshot) => {
                        const pendingPostsContainer = document.getElementById('pending-posts-container');
                        
                        // Если нет контейнера предложенных постов, пропускаем
                        if (!pendingPostsContainer) return;
                        
                        if (!snapshot.exists()) {
                            pendingPostsContainer.innerHTML = `
                                <div class="empty-state">
                                    <i class="fas fa-inbox"></i>
                                    <p>Нет предложенных постов</p>
                                </div>
                            `;
                            
                            // Скрываем бейдж с количеством предложенных постов
                            const pendingTab = document.getElementById('pending-posts-tab');
                            if (pendingTab) {
                                const badge = pendingTab.querySelector('.pending-badge');
                                if (badge) badge.style.display = 'none';
                            }
                            
                            return;
                        }
                        
                        // Удаляем сообщение о пустом списке, если оно есть
                        const emptyState = pendingPostsContainer.querySelector('.empty-state');
                        if (emptyState) {
                            emptyState.remove();
                        }
                        
                        // Собираем все предложенные посты
                        const proposedPosts = [];
                        snapshot.forEach((childSnapshot) => {
                            const post = childSnapshot.val();
                            post.id = childSnapshot.key;
                            proposedPosts.push(post);
                        });
                        
                        // Обновляем бейдж с количеством предложенных постов
                        const pendingTab = document.getElementById('pending-posts-tab');
                        if (pendingTab) {
                            let badge = pendingTab.querySelector('.pending-badge');
                            if (!badge) {
                                badge = document.createElement('span');
                                badge.className = 'pending-badge';
                                pendingTab.appendChild(badge);
                            }
                            badge.textContent = proposedPosts.length;
                            badge.style.display = 'inline-block';
                        }
                        
                        // Сортируем посты по времени (сначала новые)
                        proposedPosts.sort((a, b) => b.timestamp - a.timestamp);
                        
                        // Очищаем контейнер перед добавлением отсортированных постов
                        pendingPostsContainer.innerHTML = '';
                        
                        // Добавляем предложенные посты в отсортированном порядке
                        for (const post of proposedPosts) {
                            const postElement = document.createElement('div');
                            await renderPost(post, postElement, true, userId, isAdmin, groupId);
                            if (postElement.firstChild) {
                                pendingPostsContainer.appendChild(postElement.firstChild);
                            }
                        }
                    });
                }
                
            } catch (error) {
                console.error('Error loading group posts:', error);
            }
        }
        
        // Функция для обновления секции постов
        async function updatePostSection(isAdmin, groupId, userId) { // Принимаем userId
            const groupMain = document.querySelector('.group-main');
            const postsSection = document.querySelector('.group-main .content-section');
            
            // Удаляем существующую секцию постов
            if (postsSection) {
                postsSection.remove();
            }
            
            // Создаем новую секцию постов
            const newPostsSection = document.createElement('div');
            newPostsSection.className = 'content-section';
            
            // --- НАЧАЛО: Получаем данные текущего пользователя для аватара ---
            let currentUserAvatarURL = '';
            try {
                const userRef = ref(db, `users/${userId}`);
                const userSnapshot = await get(userRef);
                if (userSnapshot.exists()) {
                    currentUserAvatarURL = userSnapshot.val().photoURL || '';
                }
            } catch (error) {
                console.error("Error fetching current user data for post input:", error);
            }
            // --- КОНЕЦ: Получаем данные текущего пользователя ---
            
            // --- НАЧАЛО: Новая форма для создания поста ---
            newPostsSection.innerHTML = `
                <div class="create-post-inline">
                    <div class="post-author-avatar">
                        ${currentUserAvatarURL ? `<img src="${currentUserAvatarURL}" alt="Ваш аватар">` : ''}
                    </div>
                    <div class="post-input-area">
                        <textarea id="inline-post-content" placeholder="Что у вас нового?"></textarea>
                        <div class="post-inline-actions" style="display: flex; justify-content: space-between; align-items: center;">
                            ${isAdmin ? `
                            <div style="display: flex; align-items: center;">
                                <div class="publish-as-group-option" style="display: flex; align-items: center; white-space: nowrap; margin-right: 15px;">
                                    <input type="checkbox" id="publish-as-group" style="margin-right: 5px;" checked>
                                    <label for="publish-as-group" style="font-size: 13px; color: #666; white-space: nowrap;">От имени группы</label>
                                </div>
                                <div class="show-author-option" style="display: flex; align-items: center; white-space: nowrap;">
                                    <input type="checkbox" id="show-author" style="margin-right: 5px;" checked>
                                    <label for="show-author" style="font-size: 13px; color: #666; white-space: nowrap;">Указать автора</label>
                                </div>
                            </div>
                            ` : `<div></div>`}
                            <div class="image-upload-container">
                                <button type="button" class="image-upload-button post-image-upload-button">
<i class="fas fa-image"></i> <span>Прикрепить медиа</span>
                                </button>
                                <input type="file" class="image-upload-input post-image-upload-input" accept="image/*,video/*" multiple>
                                <div class="image-counter post-image-counter" style="display: none;">0/10</div>
                                <button class="post-inline-send-btn" disabled>
                                    <i class="fas fa-paper-plane"></i> ${isAdmin ? 'Опубликовать' : 'Предложить'}
                                </button>
                            </div>
                        </div>
                        <!-- Контейнер для превью изображений -->
                        <div class="image-preview-container post-image-preview-container" style="display: none;">
                            <div class="image-gallery post-image-gallery"></div>
                            <button type="button" class="clear-all-images post-clear-all-images">
                                <i class="fas fa-trash"></i> Удалить все
                            </button>
                        </div>
                    </div>
                </div>
            `;
            // --- КОНЕЦ: Новая форма для создания поста ---
            
            if (isAdmin) {
                // Для администраторов показываем табы (Опубликованные, Предложенные)
                newPostsSection.innerHTML += `
                    <div class="post-tabs">
                        <button class="post-tab active" id="published-posts-tab" data-tab="published-posts">Опубликованные</button>
                        <button class="post-tab" id="pending-posts-tab" data-tab="pending-posts">Предложенные</button>
                    </div>
                    <div class="tab-content active" id="published-posts">
                        <div class="posts-list"></div>
                    </div>
                    <div class="tab-content" id="pending-posts">
                        <div class="posts-list" id="pending-posts-container"></div>
                    </div>
                `;
            } else {
                // Для обычных пользователей показываем табы (Опубликованные, Мои предложенные)
                newPostsSection.innerHTML += `
                    <div class="post-tabs">
                        <button class="post-tab active" id="published-posts-tab" data-tab="published-posts">Опубликованные</button>
                        <button class="post-tab" id="my-proposed-posts-tab" data-tab="my-proposed-posts">Мои предложенные</button>
                    </div>
                    <div class="tab-content active" id="published-posts">
                        <div class="posts-list"></div>
                    </div>
                    <div class="tab-content" id="my-proposed-posts">
                        <div class="posts-list" id="my-proposed-posts-container"></div>
                    </div>
                `;
            }
            
            // Добавляем секцию в главный контейнер
            groupMain.prepend(newPostsSection);
            
            // --- НАЧАЛО: Обработчики для нового поля ввода ---
            const postContentInput = document.getElementById('inline-post-content');
            const sendButton = document.querySelector('.post-inline-send-btn');
            const postForm = document.querySelector('.create-post-inline');
            const postImageUploadManager = new ImageUploadManager(postForm, 'post');
            
            // Получаем информацию о группе для аватарки
            let groupAvatarURL = '';
            if (isAdmin) {
                try {
                    const groupRef = ref(db, `groups/${groupId}`);
                    const groupSnapshot = await get(groupRef);
                    if (groupSnapshot.exists()) {
                        const groupData = groupSnapshot.val();
                        groupAvatarURL = groupData.photoURL || '';
                    }
                    
                    // Подписываемся на изменения данных группы
                    onValue(groupRef, (snapshot) => {
                        if (snapshot.exists()) {
                            const updatedGroupData = snapshot.val();
                            const newGroupAvatarURL = updatedGroupData.photoURL || '';
                            
                            // Обновляем локальную переменную
                            groupAvatarURL = newGroupAvatarURL;
                            
                            // Проверяем состояние чекбокса и обновляем аватарку, если он активирован
                            const publishAsGroupCheckbox = document.getElementById('publish-as-group');
                            const postAuthorAvatar = document.querySelector('.post-author-avatar');
                            
                            if (publishAsGroupCheckbox && publishAsGroupCheckbox.checked) {
                                postAuthorAvatar.innerHTML = `<img src="${newGroupAvatarURL}" alt="Аватар группы">`;
                            }
                        }
                    });
                } catch (error) {
                    console.error("Error fetching group avatar:", error);
                }
            }

            // Активация/деактивация кнопки отправки
            postContentInput.addEventListener('input', () => {
                sendButton.disabled = postContentInput.value.trim() === '' && !postImageUploadManager.hasImages();
            });

            // Обработчик чекбокса "От имени группы"
            if (isAdmin) {
                const publishAsGroupCheckbox = document.getElementById('publish-as-group');
                const postAuthorAvatar = document.querySelector('.post-author-avatar');
                
                // Сразу устанавливаем аватарку группы, так как чекбокс активен по умолчанию
                if (publishAsGroupCheckbox.checked && groupAvatarURL) {
                    postAuthorAvatar.innerHTML = `<img src="${groupAvatarURL}" alt="Аватар группы">`;
                }
                
                publishAsGroupCheckbox.addEventListener('change', async function() {
                    if (this.checked) {
                        // Получаем актуальную аватарку группы при каждой активации чекбокса
                        try {
                            const groupRef = ref(db, `groups/${groupId}`);
                            const groupSnapshot = await get(groupRef);
                            if (groupSnapshot.exists()) {
                                const groupData = groupSnapshot.val();
                                groupAvatarURL = groupData.photoURL || '';
                                // Меняем аватарку на аватарку группы
                                postAuthorAvatar.innerHTML = `<img src="${groupAvatarURL}" alt="Аватар группы">`;
                            }
                        } catch (error) {
                            console.error("Error fetching group avatar:", error);
                            // В случае ошибки оставляем текущую аватарку пользователя
                            postAuthorAvatar.innerHTML = `${currentUserAvatarURL ? `<img src="${currentUserAvatarURL}" alt="Ваш аватар">` : ''}`;
                        }
                    } else {
                        // Возвращаем аватарку пользователя
                        postAuthorAvatar.innerHTML = `${currentUserAvatarURL ? `<img src="${currentUserAvatarURL}" alt="Ваш аватар">` : ''}`;
                    }
                });
            }

            // Обработчик отправки поста
            sendButton.addEventListener('click', async () => {
                const content = postContentInput.value.trim();
                
                // Получаем загруженные изображения
                const uploadedImages = postImageUploadManager.getUploadedImagesUrls();
                
                // Проверяем, что есть текст или изображения
                if (!content && (!uploadedImages || uploadedImages.length === 0)) {
                    if (typeof window.showError === 'function') {
                        window.showError('Пост должен содержать текст или изображение');
                    } else {
                        alert('Пост должен содержать текст или изображение');
                    }
                    return;
                }
                
                // Показываем индикатор загрузки
                sendButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                sendButton.disabled = true;
                
                // Дополнительные параметры для администраторов
                let publishAsGroup = false;
                let showAuthor = false;
                
                if (isAdmin) {
                    // Для админов проверяем состояние чекбоксов
                    const publishAsGroupCheckbox = document.getElementById('publish-as-group');
                    const showAuthorCheckbox = document.getElementById('show-author');
                    
                    publishAsGroup = publishAsGroupCheckbox && publishAsGroupCheckbox.checked;
                    showAuthor = showAuthorCheckbox && showAuthorCheckbox.checked;
                }
                
                try {
                    // Создаем новый пост
                    await createGroupPost({
                        content: content,
                        authorId: auth.currentUser.uid,
                        groupId: groupId,
                        imageUrls: uploadedImages,
                        publishAsGroup: publishAsGroup,
                        showAuthor: showAuthor,
                        isPending: !isAdmin // Только админы могут публиковать напрямую
                    });
                    
                    // Очищаем поле ввода и сбрасываем изображения
                    postContentInput.value = '';
                    postImageUploadManager.clearImages();
                    
                    // Переключаемся на соответствующую вкладку
                    if (!isAdmin) {
                        // Для обычных пользователей переключаемся на "Мои предложенные"
                        const myProposedTab = document.getElementById('my-proposed-posts-tab');
                        if (myProposedTab) {
                            myProposedTab.click();
                        }
                    }
                    
                    // Уведомление об успешной отправке
                    const successMessage = isAdmin ? 'Пост успешно опубликован' : 'Пост успешно предложен и будет опубликован после проверки администратором';
                    if (typeof window.showSuccess === 'function') {
                        window.showSuccess(successMessage);
                    } else {
                        alert(successMessage);
                    }
                    
                } catch (error) {
                    console.error('Ошибка при создании поста:', error);
                    if (typeof window.showError === 'function') {
                        window.showError('Произошла ошибка при отправке поста. Пожалуйста, попробуйте еще раз.');
                    } else {
                        alert('Произошла ошибка при отправке поста. Пожалуйста, попробуйте еще раз.');
                    }
                } finally {
                    // Восстанавливаем кнопку
                    sendButton.innerHTML = `<i class="fas fa-paper-plane"></i> ${isAdmin ? 'Опубликовать' : 'Предложить'}`;
                    sendButton.disabled = true;
                }
            });
            // --- КОНЕЦ: Обработчики для нового поля ввода ---
            
            // Добавляем обработчики для табов
            const tabButtons = document.querySelectorAll('.post-tab');
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    button.classList.add('active');
                    const tabId = button.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Загружаем предложенные посты пользователя, если он не админ
            if (!isAdmin) {
                loadUserProposedPosts(groupId, userId);
            }
        }
        
        // Функция для отображения поста
        async function renderPost(post, container, isPending, currentUserId, isAdmin, groupId) {
            try {
                // Добавляем получение текущего пользователя из Firebase Auth
                const currentUser = auth.currentUser;
                
                // Проверяем, опубликован ли пост от имени группы
                let authorName, authorPhotoURL, publisherName;
                
                if (post.publishedAsGroup && !isPending) {
                    // Получаем информацию о группе
                    const groupRef = ref(db, `groups/${groupId}`);
                    const groupSnapshot = await get(groupRef);
                    
                    // Получаем информацию о реальном авторе поста
                    const authorRef = ref(db, `users/${post.authorId}`);
                    const authorSnapshot = await get(authorRef);
                    
                    if (groupSnapshot.exists()) {
                        const groupData = groupSnapshot.val();
                        authorName = groupData.name || 'Группа';
                        authorPhotoURL = groupData.photoURL || '';
                        
                        if (authorSnapshot.exists()) {
                            const authorData = authorSnapshot.val();
                            publisherName = authorData.name || authorData.displayName || authorData.email || 'Пользователь';
                        }
                    } else {
                        authorName = 'Группа';
                        authorPhotoURL = '';
                    }
                } else {
                    // Получаем информацию об авторе поста
                    const authorRef = ref(db, `users/${post.authorId}`);
                    const authorSnapshot = await get(authorRef);
                    
                    if (!authorSnapshot.exists()) {
                        console.error('Author data not found for post:', post.id);
                        return;
                    }
                    
                    const authorData = authorSnapshot.val();
                    authorName = authorData.name || authorData.displayName || authorData.email || 'Пользователь';
                    authorPhotoURL = authorData.photoURL || '';
                }
                
                // Создаем элемент поста
                const postEl = document.createElement('div');
                postEl.className = `post-item ${isPending ? 'pending-post-item' : ''}`;
                postEl.id = `post-${post.id}`;
                
                // Форматируем дату
                const postDate = new Date(post.timestamp);
                const formattedDate = postDate.toLocaleString('ru-RU', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // Заполняем содержимое поста
                postEl.innerHTML = `
                    <div class="post-header">
                        <div class="post-author-avatar">
                            ${authorPhotoURL ? `<img src="${authorPhotoURL}" alt="${authorName}">` : ''}
                        </div>
                        <div class="post-info">
                            <div class="post-author-name">
                                <span class="author-name-text">${authorName}</span> 
                                ${post.publishedAsGroup && publisherName && (post.showAuthor === true) ? 
                                    `<span class="author-link">(${publisherName})</span>` : ''}
                            </div>
                            <div class="post-date">${formattedDate}</div>
                        </div>
                    </div>
                    <div class="post-content">${post.content}</div>
                    ${post.imageURL ? `<img src="${post.imageURL}" alt="Изображение к посту" class="post-image">` : ''}
                    ${post.imageUrls && post.imageUrls.length > 0 ? `
                    <div class="post-images ${post.imageUrls.length > 1 ? 'post-images-gallery count-' + post.imageUrls.length : ''}">
                        ${post.imageUrls.map((url, index) => {
                            const isVideo = url.includes('.mp4') || url.includes('.webm') || url.includes('.ogg') || url.includes('.mov') || 
                                           url.includes('video') || url.includes('comment_videos');
                            return `
                                <div class="post-image-item" data-url="${url}" data-index="${index}">
                                    ${isVideo ? 
                                        `<div class="video-container">
                                            <video src="${url}" preload="metadata"></video>
                                            <div class="video-overlay"></div>
                                        </div>` : 
                                        `<img src="${url}" alt="Изображение ${index + 1}" class="post-image">`
                                    }
                                </div>
                            `;
                        }).join('')}
                    </div>` : ''}
                    ${!isPending ? `
                    <div class="post-actions">
                        <button class="post-action-btn post-like-btn" data-post-id="${post.id}" onclick="window.handlePostVote('${post.id}', 1)">
                            <i class="far fa-thumbs-up"></i> <span class="post-like-count">0</span>
                        </button>
                        <button class="post-action-btn post-dislike-btn" data-post-id="${post.id}" onclick="window.handlePostVote('${post.id}', -1)">
                            <i class="far fa-thumbs-down"></i> <span class="post-dislike-count">0</span>
                        </button>
                        <span class="post-author-like-container"></span>
                        ${post.authorId === currentUserId || isAdmin ? `
                        <button class="post-action-btn post-delete-btn" data-post-id="${post.id}">
                            <i class="far fa-trash-alt"></i> Удалить
                        </button>
                        ` : ''}
                    </div>
                    <div class="post-comments-section always-visible" data-post-id="${post.id}">
                        <div class="comments-list" data-post-id="${post.id}">
                            <!-- Комментарии будут добавлены через JavaScript -->
                        </div>
                        <form class="comment-form" data-post-id="${post.id}">
                            <img class="comment-form-avatar"
                                src="${currentUser ? (currentUser.photoURL || window.currentUserData?.photoURL || 'https://ui-avatars.com/api/?name=User&background=random') : 'https://ui-avatars.com/api/?name=User&background=random'}" alt="">
                            <div class="comment-form-content">
                                <textarea class="comment-input" placeholder="Написать комментарий..." maxlength="1000" rows="1"></textarea>
                                <div class="character-counter">0/1000</div>
                                <div class="image-upload-container">
                                    <button type="button" class="image-upload-button">
<i class="fas fa-image"></i> <span>Прикрепить медиа</span>
                                    </button>
                                    <input type="file" class="image-upload-input" accept="image/*,video/*" multiple>
                                    <div class="image-counter" style="display: none;">0/10</div>
                                </div>
                                <div class="image-preview-container">
                                    <div class="image-gallery"></div>
                                    <button type="button" class="clear-all-images">
                                        <i class="fas fa-trash"></i> Удалить все
                                    </button>
                                </div>
                                <div class="comment-form-buttons">
                                    <button type="button" class="secondary cancel-comment-button">
                                        <i class="fas fa-times"></i> Отмена
                                    </button>
                                    <button type="submit" class="primary">
                                        <i class="fas fa-paper-plane"></i> Отправить
                                    </button>
                                </div>
                            </div>
                        </form>
                    </div>
                    ` : `
                    <div class="pending-post-status">
                        <div class="pending-post-info">Ожидает одобрения администратора</div>
                        <div class="pending-post-actions">
                            <button class="approve-btn" data-post-id="${post.id}">Одобрить</button>
                            <button class="reject-btn" data-post-id="${post.id}">Отклонить</button>
                        </div>
                    </div>
                    `}
                `;
                
                // Добавляем обработчики для просмотра медиафайлов
                const mediaItems = postEl.querySelectorAll('.post-image-item');
                mediaItems.forEach((item, index) => {
                    item.addEventListener('click', (e) => {
                        // Если клик был по оверлею или изображению, но не по видео
                        if (e.target.closest('.video-overlay') || e.target.tagName === 'IMG') {
                            const url = item.dataset.url;
                            if (url) {
                                window.openImageModal(url, postEl, index);
                            }
                        }
                    });
                    
                    // Добавляем отдельный обработчик для видео-оверлея
                    const videoOverlay = item.querySelector('.video-overlay');
                    if (videoOverlay) {
                        videoOverlay.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            const url = item.dataset.url;
                            if (url) {
                                window.openImageModal(url, postEl, index);
                            }
                        });
                    }
                });
                
                // Добавляем обработчики для кнопок
                if (!isPending) {
                    // Обработчик для кнопки удаления
                    const deleteBtn = postEl.querySelector('.post-delete-btn');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', () => {
                            deletePost(groupId, post.id);
                        });
                    }
                    
                    // Настраиваем слушатель голосов для поста
                    setupPostVotesListener(groupId, post.id, postEl);
                } else if (isAdmin) {
                    // Обработчики для кнопок одобрения/отклонения предложенного поста
                    const approveBtn = postEl.querySelector('.approve-btn');
                    const rejectBtn = postEl.querySelector('.reject-btn');
                    
                    if (approveBtn) {
                        approveBtn.addEventListener('click', () => {
                            approvePost(groupId, post.id);
                        });
                    }
                    
                    if (rejectBtn) {
                        rejectBtn.addEventListener('click', () => {
                            rejectPost(groupId, post.id);
                        });
                    }
                }
                
                // Добавляем обработчики для аватара и имени автора поста
                if (post.publishedAsGroup) {
                    // Если пост опубликован от имени группы, добавляем обработчик для перехода на страницу группы
                    const authorAvatar = postEl.querySelector('.post-author-avatar');
                    const authorNameEl = postEl.querySelector('.author-name-text');
                    
                    // Функция перехода на страницу группы
                    const goToGroupPage = () => {
                        // Поскольку мы уже находимся на странице группы, можно просто прокрутить вверх
                        // или обновить страницу, если это нужно
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                    };
                    
                    // Добавляем обработчики кликов
                    authorAvatar.addEventListener('click', goToGroupPage);
                    authorNameEl.addEventListener('click', goToGroupPage);
                    
                    // Если пост показывает информацию об авторе, добавляем обработчик для имени автора в скобках
                    if (post.showAuthor && publisherName) {
                        const authorSpan = postEl.querySelector('.author-link');
                        if (authorSpan) {
                            // Получаем ссылку на базу данных для получения numericId пользователя-автора
                            const userRef = ref(db, `users/${post.authorId}`);
                            
                            // Получаем информацию о пользователе и устанавливаем обработчик
                            get(userRef).then((snapshot) => {
                                if (snapshot.exists()) {
                                    const userData = snapshot.val();
                                    // Используем numericId или обычный id, если numericId не найден
                                    const profileId = userData.numericId || post.authorId;
                                    
                                    // Добавляем отдельный обработчик только для имени автора в скобках
                                    authorSpan.addEventListener('click', (e) => {
                                        e.stopPropagation(); // Останавливаем всплытие события, чтобы не сработал клик по родителю
                                        window.location.href = `profile.html?id=${profileId}`;
                                    });
                                }
                            }).catch(error => {
                                console.error("Error getting user data for profile link:", error);
                            });
                        }
                    }
                } else {
                    // Если пост от обычного пользователя, переходим на его профиль
                    const authorAvatar = postEl.querySelector('.post-author-avatar');
                    const authorNameEl = postEl.querySelector('.post-author-name');
                    
                    // Получаем ссылку на базу данных для получения numericId пользователя
                    const userRef = ref(db, `users/${post.authorId}`);
                    
                    // Получаем информацию о пользователе и устанавливаем обработчики
                    get(userRef).then((snapshot) => {
                        if (snapshot.exists()) {
                            const userData = snapshot.val();
                            // Используем numericId или обычный id, если numericId не найден
                            const profileId = userData.numericId || post.authorId;
                            
                            // Функция перехода на страницу профиля автора
                            const goToAuthorProfile = () => {
                                window.location.href = `profile.html?id=${profileId}`;
                            };
                            
                            // Добавляем обработчики кликов
                            authorAvatar.addEventListener('click', goToAuthorProfile);
                            authorNameEl.addEventListener('click', goToAuthorProfile);
                        }
                    }).catch(error => {
                        console.error("Error getting user data for profile link:", error);
                    });
                }
                
                // Добавляем пост в контейнер
                container.appendChild(postEl);
                
                // Если пост не ожидает одобрения, загружаем комментарии
                if (!isPending) {
                    // Инициализируем форму комментария
                    initCommentForm(postEl, groupId, post.id);
                    
                    // Загружаем комментарии к посту
                    loadComments(groupId, post.id);
                }
                
            } catch (error) {
                console.error('Error rendering post:', error);
            }
        }
        
        // Функция для инициализации формы комментария
        function initCommentForm(postEl, groupId, postId) {
            const commentForm = postEl.querySelector(`.comment-form[data-post-id="${postId}"]`);
            if (!commentForm) return;
            
            // Инициализируем загрузку изображений для комментариев
            const imageUploadManager = new ImageUploadManager(commentForm, 'comment');
            
            // Инициализируем обработчик для формы комментария
            commentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const submitButton = commentForm.querySelector('button[type="submit"]');
                if (submitButton.disabled) return; // Предотвращаем повторную отправку
                
                submitButton.disabled = true; // Блокируем кнопку
                
                const textarea = commentForm.querySelector('.comment-input');
                const text = textarea.value.trim();
                
                // Получаем загруженные изображения
                const uploadedImages = imageUploadManager.getUploadedImagesUrls();
                
                // Проверяем, что есть текст или изображения
                if (!text && (!uploadedImages || uploadedImages.length === 0)) {
                    if (typeof window.showError === 'function') {
                        window.showError('Пост должен содержать текст или изображение');
                    } else {
                        alert('Пост должен содержать текст или изображение');
                    }
                    submitButton.disabled = false; // Разблокируем кнопку
                    return;
                }
                
                try {
                    await addComment(groupId, postId, text, null, null, null, uploadedImages);
                    textarea.value = '';
                    
                    // Сбрасываем счетчик символов
                    const counter = commentForm.querySelector('.character-counter');
                    if (counter) {
                        counter.textContent = '0/1000';
                    }
                    
                    // Очищаем загруженные изображения
                    imageUploadManager.clearImages();
                    
                    // Скрываем кнопки
                    const buttonsContainer = commentForm.querySelector('.comment-form-buttons');
                    if (buttonsContainer) {
                        buttonsContainer.style.display = 'none';
                    }
                    
                    // Прокручиваем список комментариев к концу для пользователя, который добавил комментарий
                    const commentsList = postEl.querySelector('.comments-list');
                    if (commentsList) {
                        setTimeout(() => {
                            commentsList.scrollTop = commentsList.scrollHeight;
                        }, 500); // Небольшая задержка, чтобы комментарий успел загрузиться
                    }
                } catch (error) {
                    console.error('Ошибка при добавлении комментария:', error);
                    alert('Не удалось добавить комментарий');
                } finally {
                    // Разблокируем кнопку в любом случае
                    submitButton.disabled = false;
                }
            });
            
            // Инициализируем обработчик для текстового поля
            const textarea = commentForm.querySelector('.comment-input');
            const counter = commentForm.querySelector('.character-counter');
            const buttonsContainer = commentForm.querySelector('.comment-form-buttons');
            
            if (textarea && counter && buttonsContainer) {
                // Обновляем счетчик символов при вводе
                textarea.addEventListener('input', () => {
                    const length = textarea.value.length;
                    counter.textContent = `${length}/1000`;
                    
                    // Показываем кнопки, если есть текст
                    if (length > 0 || imageUploadManager.hasImages()) {
                        buttonsContainer.style.display = 'flex';
                    } else {
                        buttonsContainer.style.display = 'none';
                    }
                    
                    // Авторасширение текстового поля
                    textarea.style.height = 'auto';
                    textarea.style.height = `${textarea.scrollHeight}px`;
                });
                
                // Инициализируем кнопку отмены
                const cancelButton = commentForm.querySelector('.cancel-comment-button');
                if (cancelButton) {
                    cancelButton.addEventListener('click', () => {
                        textarea.value = '';
                        counter.textContent = '0/1000';
                        buttonsContainer.style.display = 'none';
                        textarea.style.height = 'auto';
                        
                        // Очищаем загруженные изображения
                        imageUploadManager.clearImages();
                    });
                }
            }
        }

        // Инициализируем обработчик для кнопок отмены в ответах на комментарии
        document.addEventListener('click', (e) => {
            const cancelButton = e.target.closest('.cancel-reply-button');
            if (cancelButton) {
                const commentId = cancelButton.dataset.commentId;
                const replyForm = document.querySelector(`.reply-form[data-parent-id="${commentId}"]`);
                if (replyForm) {
                    const textarea = replyForm.querySelector('.reply-input');
                    if (textarea) {
                        textarea.value = '';
                    }
                    replyForm.classList.remove('active');
                }
            }
        });

        // Инициализируем обработчик для отслеживания ввода в ответах на комментарии
        document.addEventListener('input', (e) => {
            if (e.target.classList.contains('reply-input')) {
                const replyForm = e.target.closest('.reply-form');
                if (replyForm) {
                    const commentId = replyForm.dataset.parentId;
                    const counter = replyForm.querySelector(`.reply-character-counter[data-comment-id="${commentId}"]`);
                    if (counter) {
                        const length = e.target.value.length;
                        counter.textContent = `${length}/1000`;
                    }
                    
                    // Авторасширение текстового поля
                    e.target.style.height = 'auto';
                    e.target.style.height = `${e.target.scrollHeight}px`;
                }
            } else if (e.target.classList.contains('comment-input')) {
                // Авторасширение текстового поля для основных комментариев
                e.target.style.height = 'auto';
                e.target.style.height = `${e.target.scrollHeight}px`;
            }
        });

        // Добавляем CSS стили для комментариев
        document.addEventListener('DOMContentLoaded', () => {
            const styleSheet = document.createElement('style');
            styleSheet.textContent = `
                .post-comments-section {
                    margin-top: 10px;
                    border-top: 1px solid #eee;
                    padding-top: 10px;
                }
                
                .dark-mode .post-comments-section {
                    border-top-color: #444;
                }
                
                .post-comments-section.always-visible {
                    display: block;
                }
                
                .comments-list {
                    display: flex;
										max-height: 500px;
										overflow-y: auto;
                    flex-direction: column;
                    gap: 15px;
                    margin-bottom: 15px;
                }
                
                .comment {
                    display: flex;
                    gap: 10px;
                    padding: 5px;
                    border-radius: 10px;
                    transition: background-color 0.3s;
                }
                
                .comment-avatar-link {
                    text-decoration: none;
                    flex-shrink: 0;
                }
                
                .comment-avatar {
                    width: 36px;
                    height: 36px;
                    border-radius: 50%;
                    object-fit: cover;
                }
                
                .comment-main {
                    flex-grow: 1;
                }
                
                .comment-header {
                    display: flex;
                    align-items: center;
                    margin-bottom: 5px;
                }
                
                .comment-author {
                    font-weight: 500;
                    color: #333;
                    margin-right: 10px;
                    text-decoration: none;
                }
                
                .dark-mode .comment-author {
                    color: #f5f5f5;
                }
                
                .comment-date {
                    font-size: 12px;
                    color: #888;
                }
                
                .dark-mode .comment-date {
                    color: #999;
                }
                
                .reply-info {
                    font-size: 12px;
                    color: #888;
                    margin-bottom: 5px;
                    padding: 2px 5px;
                    background-color: rgba(0, 0, 0, 0.03);
                    border-radius: 4px;
                    display: inline-block;
                    cursor: pointer;
                }
                
                .dark-mode .reply-info {
                    color: #aaa;
                    background-color: rgba(255, 255, 255, 0.05);
                }
                
                .reply-author {
                    color: #4a76a8;
                    font-weight: 500;
                }
                
                .dark-mode .reply-author {
                    color: #5a86b8;
                }
                
                .reply-info-divider {
                    margin: 0 5px;
                    color: #ccc;
                }
                
                .dark-mode .reply-info-divider {
                    color: #666;
                }
                
                .comment-content {
                    margin-bottom: 8px;
                    white-space: pre-wrap;
                    word-break: break-word;
                }
                
                .comment-images {
                    display: grid;
                    gap: 5px;
                    margin-bottom: 8px;
                    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                }
                
                .comment-images.count-1 {
                    grid-template-columns: minmax(0, 300px);
                }
                
                .comment-image-item {
                    cursor: pointer;
                    border-radius: 8px;
                    overflow: hidden;
                    aspect-ratio: 1;
                }
                
                .comment-image-item img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }
                
                .comment-image-item .video-container {
                    position: relative;
                    width: 100%;
                    height: 100%;
                    overflow: hidden;
                }
                
                .comment-image-item .video-container video {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }
                
                .comment-image-item .video-overlay {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.2);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    cursor: pointer;
                }
                
                .comment-image-item .video-overlay::before {
                    content: '\f144';
                    font-family: 'Font Awesome 5 Free';
                    font-size: 24px;
                    color: #fff;
                    opacity: 0.8;
                }
                
                .comment-votes {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    margin-bottom: 5px;
                }
                
                .reply-btn {
                    background: none;
                    border: none;
                    color: #4a76a8;
                    font-size: 12px;
                    cursor: pointer;
                    padding: 0;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                }
                
                .dark-mode .reply-btn {
                    color: #5a86b8;
                }
                
                .reply-btn.delete {
                    color: #e53935;
                }
                
                .dark-mode .reply-btn.delete {
                    color: #f44336;
                }
                
                .reply-btn i {
                    font-size: 12px;
                }
                
                .reply-form {
                    display: none;
                    gap: 10px;
                    margin-top: 10px;
                    margin-bottom: 5px;
                }
                
                .reply-form.active {
                    display: flex;
                }
                
                .comment-replies {
                    margin-left: 10px;
                    margin-top: 10px;
                    border-left: none;
                    padding-left: 15px;
                    display: flex;
                    flex-direction: column;
                    gap: 15px;
                }
                
                .dark-mode .comment-replies {
                    border-left-color: #444;
                }
                
                .no-comments {
                    color: #888;
                    text-align: center;
                    padding: 20px 0;
                    font-style: italic;
                }
                
                .dark-mode .no-comments {
                    color: #aaa;
                }
            `;
            
            document.head.appendChild(styleSheet);
        });
        
        // Функция для открытия модального окна создания/предложения поста
        function openCreatePostModal(groupId, isAdmin) {
            // Создаем модальное окно, если его нет
            if (!document.getElementById('create-post-modal-overlay')) {
                const modalHTML = `
                    <div id="create-post-modal-overlay" class="modal-overlay">
                        <div class="modal-container">
                            <div class="modal-header">
                                <h3 class="modal-title" id="create-post-modal-title">Создание поста</h3>
                                <button class="modal-close" id="create-post-modal-close">&times;</button>
                            </div>
                            <div class="modal-body">
                                <form id="create-post-form">
                                    <div class="form-group">
                                        <label for="post-content" class="form-label">Содержание поста</label>
                                        <textarea id="post-content" class="form-input form-textarea" placeholder="Напишите что-нибудь..." required></textarea>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Изображение (необязательно)</label>
                                        <div class="image-upload">
                                            <div class="post-image-preview" id="post-image-preview">
                                                <i class="fas fa-image"></i>
                                            </div>
                                            <input type="file" id="post-image-input" accept="image/*,video/*" style="display: none;">
                                            <div class="upload-hint">Нажмите на изображение, чтобы выбрать файл</div>
                                        </div>
                                    </div>
                                </form>
                            </div>
                            <div class="modal-footer">
                                <button class="modal-btn secondary" id="cancel-post">Отмена</button>
                                <button class="modal-btn primary" id="submit-post">Опубликовать</button>
                            </div>
                        </div>
                    </div>
                `;
                
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
                // Добавляем обработчики для модального окна
                setupCreatePostModalHandlers();
            }
            
            // Обновляем заголовок модального окна в зависимости от роли пользователя
            const modalTitle = document.getElementById('create-post-modal-title');
            const submitBtn = document.getElementById('submit-post');
            
            if (isAdmin) {
                modalTitle.textContent = 'Создание поста';
                submitBtn.textContent = 'Опубликовать';
            } else {
                modalTitle.textContent = 'Предложить пост';
                submitBtn.textContent = 'Предложить';
            }
            
            // Сохраняем данные о группе и роли пользователя
            window.currentPostGroupId = groupId;
            window.isCurrentUserAdmin = isAdmin;
            
            // Сбрасываем форму
            document.getElementById('create-post-form').reset();
            document.getElementById('post-image-preview').innerHTML = '<i class="fas fa-image"></i>';
            window.postImageBlob = null;
            
            // Показываем модальное окно
            document.getElementById('create-post-modal-overlay').classList.add('active');
        }
        
        // Настройка обработчиков для модального окна создания поста
        function setupCreatePostModalHandlers() {
            const modalOverlay = document.getElementById('create-post-modal-overlay');
            const modalClose = document.getElementById('create-post-modal-close');
            const cancelBtn = document.getElementById('cancel-post');
            const submitBtn = document.getElementById('submit-post');
            const imageInput = document.getElementById('post-image-input');
            const imagePreview = document.getElementById('post-image-preview');
            
            // Закрытие модального окна
            modalClose.addEventListener('click', () => {
                modalOverlay.classList.remove('active');
            });
            
            cancelBtn.addEventListener('click', () => {
                modalOverlay.classList.remove('active');
            });
            
            // Клик вне модального окна закрывает его
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    modalOverlay.classList.remove('active');
                }
            });
            
            // Обработка клика на превью изображения
            imagePreview.addEventListener('click', () => {
                imageInput.click();
            });
            
            // Обработка выбора изображения
            imageInput.addEventListener('change', function() {
                if (this.files && this.files[0]) {
                    const file = this.files[0];
                    // Проверка типа файла
                    if (!file.type.match('image.*') && !file.type.match('video.*')) {
                        alert('Пожалуйста, выберите изображение или видео');
                        return;
                    }
                    
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        // Отображаем превью выбранного изображения или видео
                        if (file.type.match('image.*')) {
                            imagePreview.innerHTML = `<img src="${e.target.result}" alt="Превью">`;
                        } else if (file.type.match('video.*')) {
                            imagePreview.innerHTML = `<video src="${e.target.result}" controls></video>`;
                        }
                        
                        // Сохраняем blob для загрузки
                        const byteString = atob(e.target.result.split(',')[1]);
                        const mimeString = e.target.result.split(',')[0].split(':')[1].split(';')[0];
                        const ab = new ArrayBuffer(byteString.length);
                        const ia = new Uint8Array(ab);
                        
                        for (let i = 0; i < byteString.length; i++) {
                            ia[i] = byteString.charCodeAt(i);
                        }
                        
                        window.postImageBlob = new Blob([ab], { type: mimeString });
                    };
                    
                    reader.readAsDataURL(file);
                }
            });
            
            // Обработка отправки формы
            submitBtn.addEventListener('click', async () => {
                const content = document.getElementById('post-content').value.trim();
                
                if (!content) {
                    alert('Пожалуйста, введите содержание поста');
                    return;
                }
                
                // Блокируем кнопку отправки
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Отправка...';
                
                try {
                    await submitPost(content, window.currentPostGroupId, window.isCurrentUserAdmin, window.postImageBlob);
                    
                    // Закрываем модальное окно после успешной отправки
                    modalOverlay.classList.remove('active');
                } catch (error) {
                    console.error('Error submitting post:', error);
                    alert('Ошибка при отправке поста');
                } finally {
                    // Разблокируем кнопку отправки
                    submitBtn.disabled = false;
                    submitBtn.textContent = window.isCurrentUserAdmin ? 'Опубликовать' : 'Предложить';
                }
            });
        }
        
        // Функция для отправки поста
        async function submitPost(content, groupId, isAdmin, imageBlob = null, publishAsGroup = false, showAuthor = true) { // Добавляем параметры
            const auth = getAuth();
            const user = auth.currentUser;
            
            if (!user) {
                throw new Error('User not authenticated');
            }
            
            try {
                // Создаем объект с данными поста
                const postData = {
                    content,
                    authorId: user.uid,
                    timestamp: Date.now(),
                    createdAt: serverTimestamp()
                };
                
                // Если пост публикуется от имени группы, добавляем соответствующий флаг
                if (publishAsGroup && isAdmin) {
                    postData.publishedAsGroup = true;
                }
                
                // Добавляем флаг отображения автора
                postData.showAuthor = showAuthor;
                
                // Определяем, куда будет сохранен пост (опубликованные или предложенные)
                const postsRef = isAdmin 
                    ? ref(db, `groupPosts/${groupId}`) 
                    : ref(db, `proposedGroupPosts/${groupId}`);
                
                const newPostRef = push(postsRef);
                
                // Если есть изображение, загружаем его
                if (imageBlob) { // Используем переданный imageBlob
                    const imagePath = `groupPosts/${groupId}/${newPostRef.key}`;
                    const imageStorageRef = storageRef(storage, imagePath);
                    
                    const uploadTask = await uploadBytes(imageStorageRef, imageBlob); // Загружаем blob
                    const imageURL = await getDownloadURL(uploadTask.ref);
                    
                    // Добавляем URL изображения к данным поста
                    postData.imageURL = imageURL;
                }
                
                // Сохраняем пост в базе данных
                await set(newPostRef, postData);
                
                console.log(`Post ${isAdmin ? 'published' : 'proposed'} successfully`);
                
            } catch (error) {
                console.error('Error submitting post:', error);
                throw error;
            }
        }
        
        // Функция для переключения состояния лайка
        async function toggleLike(groupId, postId, userId) {
            try {
                const likeRef = ref(db, `groupPosts/${groupId}/${postId}/likes/${userId}`);
                const likeSnapshot = await get(likeRef);
                
                if (likeSnapshot.exists()) {
                    // Удаляем лайк, если он уже есть
                    await set(likeRef, null);
                } else {
                    // Добавляем лайк, если его нет
                    await set(likeRef, true);
                }
                
                // Обновление UI происходит автоматически через onValue
                
            } catch (error) {
                console.error('Error toggling like:', error);
            }
        }
        
        // Функция для удаления поста
        async function deletePost(groupId, postId) {
            if (!confirm('Вы уверены, что хотите удалить этот пост?')) {
                return;
            }
            
            try {
                // Удаляем пост из базы данных
                await set(ref(db, `groupPosts/${groupId}/${postId}`), null);
                
                console.log('Post deleted successfully');
                
            } catch (error) {
                console.error('Error deleting post:', error);
                alert('Ошибка при удалении поста');
            }
        }
        
        // Функция для одобрения предложенного поста
        async function approvePost(groupId, postId) {
            try {
                // Получаем данные предложенного поста
                const proposedPostRef = ref(db, `proposedGroupPosts/${groupId}/${postId}`);
                const proposedPostSnapshot = await get(proposedPostRef);
                
                if (!proposedPostSnapshot.exists()) {
                    console.error('Proposed post not found');
                    return;
                }
                
                const postData = proposedPostSnapshot.val();
                
                // Добавляем пост в опубликованные
                const publishedPostsRef = ref(db, `groupPosts/${groupId}`);
                const newPostRef = push(publishedPostsRef);
                
                // Спрашиваем, нужно ли опубликовать пост от имени группы
                if (confirm('Опубликовать этот пост от имени группы?')) {
                    postData.publishedAsGroup = true;
                    
                    // Спрашиваем, нужно ли указывать автора поста
                    postData.showAuthor = confirm('Указать автора поста?');
                }
                
                await set(newPostRef, postData);
                
                // Удаляем пост из предложенных
                await set(proposedPostRef, null);
                
                console.log('Post approved and published successfully');
                
            } catch (error) {
                console.error('Error approving post:', error);
                alert('Ошибка при одобрении поста');
            }
        }
        
        // Функция для отклонения предложенного поста
        async function rejectPost(groupId, postId) {
            if (!confirm('Вы уверены, что хотите отклонить этот пост?')) {
                return;
            }
            
            try {
                // Удаляем предложенный пост из базы данных
                await set(ref(db, `proposedGroupPosts/${groupId}/${postId}`), null);
                
                console.log('Post rejected successfully');
                
            } catch (error) {
                console.error('Error rejecting post:', error);
                alert('Ошибка при отклонении поста');
            }
        }

		// Функция для обновления кнопок действий
		function updateActionButtons(members, userId, groupId) {
			const actionsContainer = document.querySelector('.group-actions');
			const isAdmin = members && members[userId] && members[userId].role === 'admin';
			const isMember = members && userId in members;
			
			actionsContainer.innerHTML = '';
			
			if (isAdmin) {
				const editButton = document.createElement('button');
				editButton.className = 'group-btn secondary';
				editButton.id = 'edit-group-btn';
				editButton.innerHTML = '<i class="fas fa-edit"></i> Редактировать';
				editButton.addEventListener('click', () => {
					// Получаем актуальные данные группы перед редактированием
					const groupRef = ref(db, `groups/${groupId}`);
					get(groupRef).then((snapshot) => {
						if (snapshot.exists()) {
							const groupData = snapshot.val();
							groupData.id = groupId;
							openEditModal(groupData);
						}
					});
				});
				actionsContainer.appendChild(editButton);
			} else if (isMember) {
				const leaveButton = document.createElement('button');
				leaveButton.className = 'group-btn secondary';
				leaveButton.id = 'leave-group-btn';
				leaveButton.innerHTML = '<i class="fas fa-sign-out-alt"></i> Выйти';
				leaveButton.addEventListener('click', () => {
					leaveGroup(groupId, userId);
				});
				actionsContainer.appendChild(leaveButton);
			} else {
				const joinButton = document.createElement('button');
				joinButton.className = 'group-btn';
				joinButton.id = 'join-group-btn';
				joinButton.innerHTML = '<i class="fas fa-plus"></i> Вступить';
				joinButton.addEventListener('click', () => {
					joinGroup(groupId, userId);
				});
				actionsContainer.appendChild(joinButton);
			}
		}
		
		// Функция вступления в группу
		async function joinGroup(groupId, userId) {
			try {
				// Получаем информацию о пользователе
				const userRef = ref(db, `users/${userId}`);
				const userSnapshot = await get(userRef);
				
				if (!userSnapshot.exists()) {
					console.error('User data not found');
					return;
				}
				
				// Добавляем пользователя в члены группы с ролью участника
				const memberData = {
					role: 'member',
					joinedAt: Date.now()
				};
				
				// Обновляем данные в базе данных
				await set(ref(db, `groups/${groupId}/members/${userId}`), memberData);
				
				// Добавляем группу в список групп пользователя
				await set(ref(db, `users/${userId}/joinedGroups/${groupId}`), true);
				
				console.log('Successfully joined the group');
			} catch (error) {
				console.error('Error joining group:', error);
				alert('Ошибка при вступлении в группу');
			}
		}
		
		// Функция выхода из группы
		async function leaveGroup(groupId, userId) {
			try {
				// Убеждаемся, что пользователь не является единственным администратором
				const groupRef = ref(db, `groups/${groupId}`);
				const groupSnapshot = await get(groupRef);
				
				if (!groupSnapshot.exists()) {
					console.error('Group not found');
					return;
				}
				
				const groupData = groupSnapshot.val();
				
				// Проверяем, является ли пользователь администратором
				const isAdmin = groupData.members && 
								groupData.members[userId] && 
								groupData.members[userId].role === 'admin';
				
				// Если пользователь админ, проверяем, есть ли другие админы
				if (isAdmin) {
					const adminCount = Object.entries(groupData.members || {})
						.filter(([uid, data]) => data.role === 'admin' && uid !== userId)
						.length;
					
					if (adminCount === 0) {
						alert('Вы не можете покинуть группу, так как вы единственный администратор. Назначьте другого администратора перед выходом.');
						return;
					}
				}
				
				// Удаляем пользователя из группы
				await set(ref(db, `groups/${groupId}/members/${userId}`), null);
				
				// Удаляем группу из списка групп пользователя
				await set(ref(db, `users/${userId}/joinedGroups/${groupId}`), null);
				
				console.log('Successfully left the group');
			} catch (error) {
				console.error('Error leaving group:', error);
				alert('Ошибка при выходе из группы');
			}
		}

		// Функция для отображения информации о группе
		function renderGroupInfo(groupData, userId) {
			const groupHeaderEl = document.querySelector('.group-header');
			const isAdmin = groupData.members && 
							groupData.members[userId] && 
							groupData.members[userId].role === 'admin';
			const isMember = groupData.members && userId in groupData.members;

			// Заполняем шапку группы
			groupHeaderEl.innerHTML = `
				<div class="group-cover">
					${groupData.coverImage ? `<img src="${groupData.coverImage}" alt="${groupData.name}">` : ''}
				</div>
				<div class="group-info">
					<div class="group-avatar">
						${groupData.photoURL ? `<img src="${groupData.photoURL}" alt="${groupData.name}">` : ''}
					</div>
					<div class="group-details">
						<h1 class="group-name">${groupData.name}</h1>
						<p class="group-description">${groupData.description || 'Нет описания'}</p>
						<div class="group-meta">
							<div class="group-meta-item">
								<i class="fas fa-users"></i> 
								${groupData.members ? Object.keys(groupData.members).length : 0} 
								${getWordForm(groupData.members ? Object.keys(groupData.members).length : 0, ['участник', 'участника', 'участников'])}
							</div>
							<div class="group-meta-item">
								<i class="fas fa-id-card"></i> 
								ID: ${groupData.id}
							</div>
						</div>
					</div>
					<div class="group-actions">
						${isAdmin ? `
							<button class="group-btn secondary" id="edit-group-btn">
								<i class="fas fa-edit"></i> Редактировать
							</button>
						` : isMember ? `
							<button class="group-btn secondary" id="leave-group-btn">
								<i class="fas fa-sign-out-alt"></i> Выйти
							</button>
						` : `
							<button class="group-btn" id="join-group-btn">
								<i class="fas fa-plus"></i> Вступить
							</button>
						`}
					</div>
				</div>
			`;

			// Добавляем обработчики для кнопок
			if (isAdmin) {
				document.getElementById('edit-group-btn').addEventListener('click', () => {
					openEditModal(groupData);
				});
			} else if (isMember) {
				document.getElementById('leave-group-btn').addEventListener('click', () => {
					leaveGroup(groupData.id, userId);
				});
			} else {
				document.getElementById('join-group-btn').addEventListener('click', () => {
					joinGroup(groupData.id, userId);
				});
			}

			// Добавляем возможность клика на количество участников
			document.querySelector('.group-meta-item:first-child').style.cursor = 'pointer';
			document.querySelector('.group-meta-item:first-child').addEventListener('click', () => {
				openMembersModal(groupData, userId);
			});
		}

		// Функция для загрузки участников группы
		async function loadGroupMembers(groupData) {
			if (!groupData.members) return;

			const membersListEl = document.querySelector('.members-list');
			const membersCount = Object.keys(groupData.members).length;
			
			// Обновляем заголовок с количеством участников
			const sectionTitle = document.querySelector('.group-sidebar .section-title');
			if (sectionTitle) {
				sectionTitle.innerHTML = `Подписчики<span class="members-count">${membersCount}</span>`;
				sectionTitle.style.cursor = 'pointer';
				sectionTitle.addEventListener('click', () => {
						openMembersModal(groupData, auth.currentUser.uid);
					});
			}
			
			// Очищаем список участников перед добавлением новых
			membersListEl.innerHTML = '';
			
			const memberPromises = Object.entries(groupData.members).map(async ([userId, memberData]) => {
				try {
					// Получаем информацию о пользователе
					const userRef = ref(db, `users/${userId}`);
					const userSnapshot = await get(userRef);

					if (!userSnapshot.exists()) {
						return null;
					}

					const userData = userSnapshot.val();
					
					// Проверяем, есть ли numericId, иначе используем Firebase UID как запасной вариант
					const profileId = userData.numericId || userId; 
					
					// Создаем элемент участника с правильным отображением имени
					const memberEl = document.createElement('div');
					memberEl.className = 'member-item';
					memberEl.innerHTML = `
						<div class="member-avatar">
							${userData.photoURL ? `<img src="${userData.photoURL}" alt="${userData.name || userData.displayName || 'Пользователь'}">` : ''}
						</div>
						<div class="member-name">${userData.name || userData.displayName || userData.email || 'Пользователь'}</div>
						<div class="member-role">${memberData.role === 'admin' ? 'Администратор' : 'Участник'}</div>
					`;
					
					// Добавляем обработчик для перехода на страницу пользователя с использованием profileId
					memberEl.addEventListener('click', () => {
						window.location.href = `profile.html?id=${profileId}`; 
					});

					return memberEl;
				} catch (error) {
					console.error('Error loading member data:', error);
					return null;
				}
			});

			const memberElements = await Promise.all(memberPromises);
			const validMembers = memberElements.filter(el => el !== null);

			if (validMembers.length > 0) {
				validMembers.forEach(el => membersListEl.appendChild(el));
			} else {
				membersListEl.innerHTML = '<div class="empty-state">Нет участников</div>';
			}
		}

		// Вспомогательные функции
		function showLoading(isLoading) {
			const loadingEl = document.querySelector('.loading-indicator');
			if (isLoading) {
				loadingEl.style.display = 'block';
				document.querySelector('.group-container').style.display = 'none';
			} else {
				loadingEl.style.display = 'none';
				document.querySelector('.group-container').style.display = 'block';
			}
		}

		function showError(message) {
			const errorEl = document.querySelector('.error-message');
			errorEl.innerHTML = `<i class="fas fa-exclamation-circle"></i> ${message}`;
			errorEl.style.display = 'block';
			document.querySelector('.loading-indicator').style.display = 'none';
			document.querySelector('.group-container').style.display = 'none';
		}

		function getWordForm(number, words) {
			const cases = [2, 0, 1, 1, 1, 2];
			return words[(number % 100 > 4 && number % 100 < 20) ? 2 : cases[Math.min(number % 10, 5)]];
		}

		// Инициализация сайдбара при загрузке страницы
		window.addEventListener('load', () => {
			
			// Добавляем модальное окно для участников группы, если его еще нет
			if (!document.getElementById('members-modal-overlay')) {
				const membersModalHTML = `
					<div id="members-modal-overlay" class="modal-overlay">
						<div class="modal-container">
							<div class="modal-header">
								<h3 class="modal-title">Подписчики группы</h3>
								<button class="modal-close" id="members-modal-close">&times;</button>
							</div>
							<div class="modal-body">
								<div class="members-modal-tabs">
									<button class="tab-button active" data-tab="all-members">Подписчики</button>
									<button class="tab-button" data-tab="admins">Администраторы</button>
									<button class="tab-button" data-tab="friends">Друзья</button>
								</div>
								<div class="tab-content active" id="all-members">
									<div class="members-modal-list" id="all-members-list"></div>
								</div>
								<div class="tab-content" id="admins">
									<div class="members-modal-list" id="admins-list"></div>
								</div>
								<div class="tab-content" id="friends">
									<div class="members-modal-list" id="friends-list"></div>
								</div>
							</div>
						</div>
					</div>
				`;
				document.body.insertAdjacentHTML('beforeend', membersModalHTML);
				
				// Настраиваем обработчики для модального окна участников
				setupMembersModalHandlers();
			}
		});

		// Функция для открытия модального окна редактирования группы
		function openEditModal(groupData) {
			// Создаем модальное окно, если его нет
			if (!document.getElementById('edit-group-modal-overlay')) {
				const modalHTML = `
					<div id="edit-group-modal-overlay" class="modal-overlay">
						<div class="modal-container">
							<div class="modal-header">
								<h3 class="modal-title">Редактирование группы</h3>
								<button class="modal-close" id="edit-modal-close">&times;</button>
							</div>
							<div class="modal-body">
								<form id="edit-group-form">
									<div class="form-group">
										<label for="edit-group-name" class="form-label">Название группы</label>
										<input type="text" id="edit-group-name" class="form-input" placeholder="Введите название группы" required>
									</div>
									<div class="form-group">
										<label for="edit-group-description" class="form-label">Описание группы</label>
										<textarea id="edit-group-description" class="form-input form-textarea" placeholder="Расскажите о группе"></textarea>
									</div>
									<div class="form-group">
										<label for="edit-group-id" class="form-label">Уникальный ID группы</label>
										<input type="text" id="edit-group-id" class="form-input" placeholder="Например: groupCursor1">
										<div class="upload-hint">Если изменить ID, все ссылки на старый ID перестанут работать</div>
									</div>
									<div class="form-group">
										<label for="edit-group-category" class="form-label">Категория группы</label>
										<select id="edit-group-category" class="form-input">
											<option value="" disabled>Выберите категорию</option>
											<option value="technology">Технологии</option>
											<option value="programming">Программирование</option>
											<option value="design">Дизайн</option>
											<option value="education">Образование</option>
											<option value="business">Бизнес</option>
											<option value="entertainment">Развлечения</option>
											<option value="health">Здоровье и спорт</option>
											<option value="cooking">Кулинария и рецепты</option>
											<option value="art">Искусство</option>
											<option value="music">Музыка</option>
											<option value="literature">Литература</option>
											<option value="travel">Путешествия</option>
											<option value="photography">Фотография</option>
											<option value="gaming">Игры</option>
											<option value="science">Наука</option>
											<option value="hobbies">Хобби и творчество</option>
											<option value="nature">Природа и животные</option>
											<option value="languages">Языки</option>
											<option value="fashion">Мода и стиль</option>
											<option value="psychology">Психология</option>
										</select>
									</div>
									<div class="form-group">
										<label class="form-label">Аватар группы</label>
										<div class="image-upload">
											<div class="image-preview avatar-preview" id="edit-group-avatar-preview">
												<i class="fas fa-camera"></i>
											</div>
											<input type="file" id="edit-group-avatar-input" accept="image/*" style="display: none;">
											<div class="upload-hint">Нажмите на изображение, чтобы выбрать файл</div>
										</div>
									</div>
									<div class="form-group">
										<label class="form-label">Обложка группы</label>
										<div class="image-upload">
											<div class="image-preview" id="edit-group-cover-preview">
												<i class="fas fa-image"></i>
											</div>
											<input type="file" id="edit-group-cover-input" accept="image/*" style="display: none;">
											<div class="upload-hint">Нажмите на изображение, чтобы выбрать файл</div>
										</div>
									</div>
									
									<!-- Блок удаления группы -->
									<div class="delete-group-section">
										<h3 class="delete-group-title">Удаление группы</h3>
										<p class="delete-group-instructions">
											Внимание! Это действие нельзя отменить. Все данные группы будут безвозвратно удалены.
											Для подтверждения введите "Удалить <span id="delete-group-id-text"></span>".
										</p>
										<div class="delete-group-confirmation">
											<input type="text" id="delete-group-confirmation-input" class="form-input" placeholder="Введите фразу для подтверждения">
										</div>
										<button type="button" id="delete-group-btn" class="delete-btn" disabled>Удалить группу</button>
									</div>
								</form>
							</div>
							<div class="modal-footer">
								<button class="modal-btn secondary" id="cancel-edit-group">Отмена</button>
								<button class="modal-btn primary" id="save-edit-group">Сохранить</button>
							</div>
						</div>
					</div>

					<div id="edit-avatar-crop-modal" class="modal-overlay">
						<div class="modal-container">
							<div class="modal-header">
								<h3 class="modal-title">Обрезка аватара</h3>
								<button class="modal-close" id="edit-avatar-crop-close">&times;</button>
							</div>
							<div class="modal-body">
								<div id="edit-avatar-crop-container"></div>
								<div class="crop-controls">
									<button class="crop-btn cancel" id="edit-avatar-crop-cancel">Отмена</button>
									<button class="crop-btn save" id="edit-avatar-crop-save">Сохранить</button>
								</div>
							</div>
						</div>
					</div>

					<div id="edit-cover-crop-modal" class="modal-overlay">
						<div class="modal-container">
							<div class="modal-header">
								<h3 class="modal-title">Обрезка обложки</h3>
								<button class="modal-close" id="edit-cover-crop-close">&times;</button>
							</div>
							<div class="modal-body">
								<div id="edit-cover-crop-container"></div>
								<div class="crop-controls">
									<button class="crop-btn cancel" id="edit-cover-crop-cancel">Отмена</button>
									<button class="crop-btn save" id="edit-cover-crop-save">Сохранить</button>
								</div>
							</div>
						</div>
					</div>
				`;

				document.body.insertAdjacentHTML('beforeend', modalHTML);

				// Добавляем обработчики
				setupEditModalHandlers();
			}

			// Заполняем поля данными группы
			document.getElementById('edit-group-name').value = groupData.name || '';
			document.getElementById('edit-group-description').value = groupData.description || '';
			document.getElementById('edit-group-id').value = groupData.id || '';
			document.getElementById('edit-group-category').value = groupData.category || '';

			// Обновляем превью изображений если они есть
			const avatarPreview = document.getElementById('edit-group-avatar-preview');
			const coverPreview = document.getElementById('edit-group-cover-preview');

			// Очищаем предыдущие изображения
			avatarPreview.innerHTML = '';
			coverPreview.innerHTML = '';

			if (groupData.photoURL) {
				const img = document.createElement('img');
				img.src = groupData.photoURL;
				avatarPreview.appendChild(img);
			} else {
				avatarPreview.innerHTML = '<i class="fas fa-camera"></i>';
			}

			if (groupData.coverImage) {
				const img = document.createElement('img');
				img.src = groupData.coverImage;
				coverPreview.appendChild(img);
			} else {
				coverPreview.innerHTML = '<i class="fas fa-image"></i>';
			}

			// Переменные для хранения обрезанных изображений
			window.editCroppedAvatarBlob = null;
			window.editCroppedCoverBlob = null;
			
			// Переменные для хранения экземпляров Cropper
			window.editAvatarCropper = null;
			window.editCoverCropper = null;

			// Сохраняем original ID для сравнения позже
			window.originalGroupId = groupData.id || '';
			
			// Обновляем текст для подтверждения удаления группы
			if (window.updateDeleteConfirmationText) {
				window.updateDeleteConfirmationText();
			}

			// Показываем модальное окно
			document.getElementById('edit-group-modal-overlay').classList.add('active');
		}

		// Настройка обработчиков для модального окна редактирования
		function setupEditModalHandlers() {
			const modalOverlay = document.getElementById('edit-group-modal-overlay');
			const modalClose = document.getElementById('edit-modal-close');
			const cancelBtn = document.getElementById('cancel-edit-group');
			const saveBtn = document.getElementById('save-edit-group');
			const avatarInput = document.getElementById('edit-group-avatar-input');
			const coverInput = document.getElementById('edit-group-cover-input');
			const avatarPreview = document.getElementById('edit-group-avatar-preview');
			const coverPreview = document.getElementById('edit-group-cover-preview');
			const groupIdInput = document.getElementById('edit-group-id');
			
			// Обработчики для удаления группы
			const deleteBtn = document.getElementById('delete-group-btn');
			const deleteGroupIdText = document.getElementById('delete-group-id-text');
			const deleteConfirmationInput = document.getElementById('delete-group-confirmation-input');
			
			// Обновляем текст для подтверждения удаления при открытии модального окна
			window.updateDeleteConfirmationText = function() {
				const groupId = document.getElementById('edit-group-id').value || '';
				deleteGroupIdText.textContent = groupId;
				deleteConfirmationInput.placeholder = `Введите "Удалить ${groupId}"`;
				
				// Сбрасываем поле ввода и кнопку
				deleteConfirmationInput.value = '';
				deleteBtn.disabled = true;
			};
			
			// Обработчик изменения ID группы
			groupIdInput.addEventListener('input', function() {
				window.updateDeleteConfirmationText();
			});
			
			// Валидация поля подтверждения удаления
			deleteConfirmationInput.addEventListener('input', function() {
				const groupId = document.getElementById('edit-group-id').value || '';
				const confirmationText = `Удалить ${groupId}`;
				
				// Проверяем совпадает ли введенный текст с требуемым
				if (this.value === confirmationText) {
					deleteBtn.disabled = false;
				} else {
					deleteBtn.disabled = true;
				}
			});
			
			// Обработчик кнопки удаления
			deleteBtn.addEventListener('click', async function() {
				const groupId = document.getElementById('edit-group-id').value || '';
				
				if (!groupId) {
					alert('ID группы не указан');
					return;
				}
				
				// Запрашиваем подтверждение
				if (!confirm('Вы действительно хотите удалить группу? Это действие нельзя отменить.')) {
					return;
				}
				
				// Блокируем кнопку и меняем текст
				this.disabled = true;
				this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Удаление...';
				
				try {
					// Получаем текущие данные группы
					const groupRef = ref(db, `groups/${groupId}`);
					const groupSnapshot = await get(groupRef);
					
					if (!groupSnapshot.exists()) {
						alert('Группа не найдена');
						return;
					}
					
					const groupData = groupSnapshot.val();
					
					// Удаляем группу из списков всех пользователей, которые в ней состоят
					if (groupData.members) {
						const memberPromises = Object.keys(groupData.members).map(async (userId) => {
							// Удаляем группу из joinedGroups пользователя
							await set(ref(db, `users/${userId}/joinedGroups/${groupId}`), null);
						});
						
						await Promise.all(memberPromises);
					}
					
					// Удаляем группу из базы данных
					await set(ref(db, `groups/${groupId}`), null);
					
					// Удаляем ID группы из реестра
					await set(ref(db, `groupIds/${groupId}`), null);
					
					// Закрываем модальное окно
					modalOverlay.classList.remove('active');
					
					// Перенаправляем на главную страницу
					window.location.href = 'groups.html';
					
				} catch (error) {
					console.error('Error deleting group:', error);
					alert('Ошибка при удалении группы: ' + error.message);
					
					// Разблокируем кнопку
					this.disabled = false;
					this.textContent = 'Удалить группу';
				}
			});

			// Закрытие модального окна
			modalClose.addEventListener('click', () => {
				modalOverlay.classList.remove('active');
			});

			cancelBtn.addEventListener('click', () => {
				modalOverlay.classList.remove('active');
			});

			// Клик вне модального окна закрывает его
			modalOverlay.addEventListener('click', (e) => {
				if (e.target === modalOverlay) {
					modalOverlay.classList.remove('active');
				}
			});

			// Обработка клика на аватар
			avatarPreview.addEventListener('click', () => {
				avatarInput.click();
			});

			// Обработка выбора аватара
			avatarInput.addEventListener('change', function() {
				if (this.files && this.files[0]) {
					const file = this.files[0];
					// Проверка типа файла
					if (!file.type.match('image.*') && !file.type.match('video.*')) {
						alert('Пожалуйста, выберите изображение или видео');
						return;
					}

					const reader = new FileReader();
					
					reader.onload = function(e) {
						// Проверяем, является ли файл GIF
						if (file.type === 'image/gif') {
							// Для GIF не используем кадрирование
							handleGifUpload(e.target.result, 'avatar');
						} else {
							// Открываем модальное окно обрезки аватарки
							openEditAvatarCropModal(e.target.result);
						}
					};
					
					reader.readAsDataURL(file);
				}
			});

			// Обработка клика на обложку
			coverPreview.addEventListener('click', () => {
				coverInput.click();
			});

			// Обработка выбора обложки
			coverInput.addEventListener('change', function() {
				if (this.files && this.files[0]) {
					const file = this.files[0];
					// Проверка типа файла
					if (!file.type.match('image.*') && !file.type.match('video.*')) {
						alert('Пожалуйста, выберите изображение или видео');
						return;
					}

					const reader = new FileReader();
					
					reader.onload = function(e) {
						// Проверяем, является ли файл GIF
						if (file.type === 'image/gif') {
							// Для GIF не используем кадрирование
							handleGifUpload(e.target.result, 'cover');
						} else {
							// Открываем модальное окно обрезки обложки
							openEditCoverCropModal(e.target.result);
						}
					};
					
					reader.readAsDataURL(file);
				}
			});

			// Обработка сохранения изменений
			saveBtn.addEventListener('click', async () => {
				const groupId = document.getElementById('edit-group-id').value;
				const name = document.getElementById('edit-group-name').value;
				const description = document.getElementById('edit-group-description').value;
				const category = document.getElementById('edit-group-category').value;
				const originalGroupId = window.originalGroupId;

				if (!name) {
					alert('Введите название группы');
					return;
				}
				
				if (!groupId) {
					alert('ID группы не может быть пустым');
					return;
				}

				// Блокируем кнопку сохранения
				saveBtn.disabled = true;
				saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Сохранение...';

				try {
					// Проверяем, изменился ли ID группы
					if (groupId !== originalGroupId) {
						// Проверяем уникальность нового ID
						const customIdRef = ref(db, `groupIds/${groupId}`);
						const customIdSnapshot = await get(customIdRef);
						
						if (customIdSnapshot.exists()) {
							alert('Этот ID группы уже занят. Пожалуйста, выберите другой.');
							saveBtn.disabled = false;
							saveBtn.innerHTML = 'Сохранить';
							return;
						}
					}
					
					// Обновляем данные группы
					const updatedData = {
						name,
						description,
						category
					};

					// Загрузка аватарки в Storage (если есть)
					if (window.editCroppedAvatarBlob) {
						const avatarRef = storageRef(storage, `groups/${originalGroupId}/avatar.jpg`);
						const avatarSnapshot = await uploadBytes(avatarRef, window.editCroppedAvatarBlob);
						const avatarURL = await getDownloadURL(avatarSnapshot.ref);
						updatedData.photoURL = avatarURL;
					}

					// Загрузка обложки в Storage (если есть)
					if (window.editCroppedCoverBlob) {
						const coverRef = storageRef(storage, `groups/${originalGroupId}/cover.jpg`);
						const coverSnapshot = await uploadBytes(coverRef, window.editCroppedCoverBlob);
						const coverURL = await getDownloadURL(coverSnapshot.ref);
						updatedData.coverImage = coverURL;
					}

					// Если ID изменился, нужно создать новую группу и удалить старую
					if (groupId !== originalGroupId) {
						// Получаем текущие данные группы
						const groupRef = ref(db, `groups/${originalGroupId}`);
						const groupSnapshot = await get(groupRef);
						
						if (groupSnapshot.exists()) {
							const groupData = groupSnapshot.val();
							
							// Создаем новую группу с новым ID
							await set(ref(db, `groups/${groupId}`), {
								...groupData,
								...updatedData
							});
							
							// Регистрируем новый ID
							await set(ref(db, `groupIds/${groupId}`), true);
							
							// Удаляем старый ID из реестра
							await set(ref(db, `groupIds/${originalGroupId}`), null);
							
							// Удаляем старую группу
							await set(ref(db, `groups/${originalGroupId}`), null);
							
							// Обновляем ссылки в данных пользователей
							// 1. Обновляем ссылки в createdGroups
							const usersSnapshot = await get(ref(db, `users`));
							if (usersSnapshot.exists()) {
								const users = usersSnapshot.val();
								for (const userId in users) {
									if (users[userId].createdGroups && users[userId].createdGroups[originalGroupId]) {
										// Удаляем старую ссылку
										await set(ref(db, `users/${userId}/createdGroups/${originalGroupId}`), null);
										// Добавляем новую ссылку
										await set(ref(db, `users/${userId}/createdGroups/${groupId}`), true);
									}
									
									if (users[userId].joinedGroups && users[userId].joinedGroups[originalGroupId]) {
										// Удаляем старую ссылку
										await set(ref(db, `users/${userId}/joinedGroups/${originalGroupId}`), null);
										// Добавляем новую ссылку
										await set(ref(db, `users/${userId}/joinedGroups/${groupId}`), true);
									}
								}
							}
							
							// Перенаправляем на новую страницу группы
							window.location.href = `group.html?id=${groupId}`;
						}
					} else {
						// Используем выделенную функцию для обновления данных группы
						await updateGroupData(groupId, updatedData);
					}

				} catch (error) {
					console.error('Error updating group:', error);
					alert('Ошибка при обновлении группы');
				} finally {
					// Разблокируем кнопку сохранения
					saveBtn.disabled = false;
					saveBtn.innerHTML = 'Сохранить';
				}
			});

			// Настройка модального окна обрезки аватара
			setupEditAvatarCropModalHandlers();

			// Настройка модального окна обрезки обложки
			setupEditCoverCropModalHandlers();
		}

		// Функция открытия модального окна обрезки аватара
		function openEditAvatarCropModal(imageData) {
			const modal = document.getElementById('edit-avatar-crop-modal');
			const container = document.getElementById('edit-avatar-crop-container');
			
			// Очищаем контейнер и уничтожаем старый экземпляр Cropper
			if (window.editAvatarCropper) {
				try {
					window.editAvatarCropper.destroy();
				} catch (error) {
					console.warn('Error destroying previous cropper instance:', error);
				}
				window.editAvatarCropper = null;
			}
			
			container.innerHTML = '';
			
			// Создаем изображение
			const image = document.createElement('img');
			image.src = imageData;
			container.appendChild(image);
			
			// Показываем модальное окно
			modal.classList.add('active');
			
			// Сбрасываем значение input, чтобы можно было выбрать то же самое изображение
			document.getElementById('edit-group-avatar-input').value = '';
			
			// Инициализируем Cropper только после загрузки изображения
			image.onload = function() {
				try {
					window.editAvatarCropper = new Cropper(image, {
						aspectRatio: 1, // квадратное соотношение сторон для аватара
						viewMode: 1,
						zoomable: true,
						cropBoxResizable: true,
						minContainerWidth: 300,
						minContainerHeight: 300
					});
				} catch (error) {
					console.error('Error initializing avatar cropper:', error);
				}
			};
		}

		// Функция открытия модального окна обрезки обложки
		function openEditCoverCropModal(imageData) {
			const modal = document.getElementById('edit-cover-crop-modal');
			const container = document.getElementById('edit-cover-crop-container');
			
			// Очищаем контейнер и уничтожаем старый экземпляр Cropper
			if (window.editCoverCropper) {
				try {
					window.editCoverCropper.destroy();
				} catch (error) {
					console.warn('Error destroying previous cropper instance:', error);
				}
				window.editCoverCropper = null;
			}
			
			container.innerHTML = '';
			
			// Создаем изображение
			const image = document.createElement('img');
			image.src = imageData;
			container.appendChild(image);
			
			// Показываем модальное окно
			modal.classList.add('active');
			
			// Сбрасываем значение input, чтобы можно было выбрать то же самое изображение
			document.getElementById('edit-group-cover-input').value = '';
			
			// Инициализируем Cropper только после загрузки изображения
			image.onload = function() {
				try {
					window.editCoverCropper = new Cropper(image, {
						aspectRatio: 16 / 9, // широкоэкранное соотношение для обложки
						viewMode: 1,
						zoomable: true,
						cropBoxResizable: true,
						minContainerWidth: 300,
						minContainerHeight: 150
					});
				} catch (error) {
					console.error('Error initializing cover cropper:', error);
				}
			};
		}

		// Настройка обработчиков для модального окна обрезки аватара
		function setupEditAvatarCropModalHandlers() {
			const modal = document.getElementById('edit-avatar-crop-modal');
			const closeBtn = document.getElementById('edit-avatar-crop-close');
			const cancelBtn = document.getElementById('edit-avatar-crop-cancel');
			const saveBtn = document.getElementById('edit-avatar-crop-save');
			
			// Закрытие модального окна
			closeBtn.addEventListener('click', () => {
				modal.classList.remove('active');
			});
			
			cancelBtn.addEventListener('click', () => {
				modal.classList.remove('active');
			});
			
			// Клик вне модального окна закрывает его
			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					modal.classList.remove('active');
				}
			});
			
			// Сохранение обрезанного изображения
			saveBtn.addEventListener('click', () => {
				if (window.editAvatarCropper) {
					// Получаем обрезанное изображение
					window.editAvatarCropper.getCroppedCanvas({
						width: 300,
						height: 300
					}).toBlob((blob) => {
						// Сохраняем blob в переменную
						window.editCroppedAvatarBlob = blob;
						
						// Обновляем превью
						const avatarPreview = document.getElementById('edit-group-avatar-preview');
						avatarPreview.innerHTML = '';
						
						const img = document.createElement('img');
						img.src = URL.createObjectURL(blob);
						avatarPreview.appendChild(img);
						
						// Закрываем модальное окно
						modal.classList.remove('active');
					}, 'image/jpeg');
				}
			});
		}

		// Настройка обработчиков для модального окна обрезки обложки
		function setupEditCoverCropModalHandlers() {
			const modal = document.getElementById('edit-cover-crop-modal');
			const closeBtn = document.getElementById('edit-cover-crop-close');
			const cancelBtn = document.getElementById('edit-cover-crop-cancel');
			const saveBtn = document.getElementById('edit-cover-crop-save');
			
			// Закрытие модального окна
			closeBtn.addEventListener('click', () => {
				modal.classList.remove('active');
			});
			
			cancelBtn.addEventListener('click', () => {
				modal.classList.remove('active');
			});
			
			// Клик вне модального окна закрывает его
			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					modal.classList.remove('active');
				}
			});
			
			// Сохранение обрезанного изображения
			saveBtn.addEventListener('click', () => {
				if (window.editCoverCropper) {
					// Получаем обрезанное изображение
					window.editCoverCropper.getCroppedCanvas({
						width: 1200,
						height: 675
					}).toBlob((blob) => {
						// Сохраняем blob в переменную
						window.editCroppedCoverBlob = blob;
						
						// Обновляем превью
						const coverPreview = document.getElementById('edit-group-cover-preview');
						coverPreview.innerHTML = '';
						
						const img = document.createElement('img');
						img.src = URL.createObjectURL(blob);
						coverPreview.appendChild(img);
						
						// Закрываем модальное окно
						modal.classList.remove('active');
					}, 'image/jpeg');
				}
			});
		}

		// Функция для обработки загрузки GIF изображений
		function handleGifUpload(dataUrl, type) {
			// Преобразуем Data URL в Blob
			const byteString = atob(dataUrl.split(',')[1]);
			const mimeString = dataUrl.split(',')[0].split(':')[1].split(';')[0];
			const ab = new ArrayBuffer(byteString.length);
			const ia = new Uint8Array(ab);
			
			for (let i = 0; i < byteString.length; i++) {
				ia[i] = byteString.charCodeAt(i);
			}
			
			const blob = new Blob([ab], { type: mimeString });
			
			// Обновляем превью и сохраняем blob
			if (type === 'avatar') {
				// Обновляем превью аватарки
				const avatarPreview = document.getElementById('edit-group-avatar-preview');
				avatarPreview.innerHTML = '';
				
				const img = document.createElement('img');
				img.src = dataUrl;
				avatarPreview.appendChild(img);
				
				// Сохраняем blob для последующей загрузки
				window.editCroppedAvatarBlob = blob;
			} else if (type === 'cover') {
				// Обновляем превью обложки
				const coverPreview = document.getElementById('edit-group-cover-preview');
				coverPreview.innerHTML = '';
				
				const img = document.createElement('img');
				img.src = dataUrl;
				coverPreview.appendChild(img);
				
				// Сохраняем blob для последующей загрузки
				window.editCroppedCoverBlob = blob;
			}
		}

		// Добавляем функцию обновления группы в базе данных с расширенным функционалом для отображения в реальном времени
		async function updateGroupData(groupId, updatedData) {
			try {
				// Сохраняем обновленные данные в базе данных
				await update(ref(db, `groups/${groupId}`), updatedData);
				
				// Закрываем модальное окно
				document.getElementById('edit-group-modal-overlay').classList.remove('active');
				
				// Информация о группе теперь обновляется автоматически через слушатель onValue
				
			} catch (error) {
				console.error('Error updating group:', error);
				alert('Ошибка при обновлении группы');
			}
		}

		// Функция настройки обработчиков для модального окна участников
		function setupMembersModalHandlers() {
			const modal = document.getElementById('members-modal-overlay');
			const closeBtn = document.getElementById('members-modal-close');
			
			// Закрытие модального окна
			closeBtn.addEventListener('click', () => {
				modal.classList.remove('active');
			});
			
			// Клик вне модального окна закрывает его
			modal.addEventListener('click', (e) => {
				if (e.target === modal) {
					modal.classList.remove('active');
				}
			});
			
			// Обработчики для табов
			const tabButtons = modal.querySelectorAll('.tab-button');
			tabButtons.forEach(button => {
				button.addEventListener('click', () => {
					// Убираем активный класс у всех кнопок и контента
					tabButtons.forEach(btn => btn.classList.remove('active'));
					modal.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
					
					// Добавляем активный класс нажатой кнопке и соответствующему контенту
					button.classList.add('active');
					const tabId = button.getAttribute('data-tab');
					document.getElementById(tabId).classList.add('active');
				});
			});
		}

		// Функция открытия модального окна участников
		async function openMembersModal(groupData, currentUserId) {
			const modal = document.getElementById('members-modal-overlay');
			
			// Очищаем списки перед заполнением
			document.getElementById('all-members-list').innerHTML = '';
			document.getElementById('admins-list').innerHTML = '';
			document.getElementById('friends-list').innerHTML = '';
			
			// Отображаем модальное окно
			modal.classList.add('active');
			
			// --- НАЧАЛО ИЗМЕНЕНИЯ: Получение numericId текущего пользователя ---
			let currentUserNumericId = null;
			try {
				const currentUserRef = ref(db, `users/${currentUserId}`);
				const currentUserSnapshot = await get(currentUserRef);
				if (currentUserSnapshot.exists()) {
					currentUserNumericId = currentUserSnapshot.val().numericId;
				}
			} catch (error) {
				console.error("Не удалось получить numericId текущего пользователя:", error);
				// Обработка ошибки, если не удалось получить numericId
				// Можно показать сообщение или просто не загружать друзей
				document.getElementById('friends-list').innerHTML = '<div class="error-message">Ошибка загрузки данных пользователя</div>';
				return; // Прерываем выполнение, если не можем получить ID
			}
			
			if (!currentUserNumericId) {
				console.error("numericId текущего пользователя не найден.");
				document.getElementById('friends-list').innerHTML = '<div class="error-message">ID пользователя не найден</div>';
				return; // Прерываем выполнение
			}
			console.log(`[openMembersModal] Current user numericId: ${currentUserNumericId}`);
			// --- КОНЕЦ ИЗМЕНЕНИЯ ---
			
			// --- НАЧАЛО ИЗМЕНЕНИЯ: Получение друзей из таблицы friendships ---
			// Используем currentUserNumericId для запроса friendships
			const friendshipsRef = ref(db, `friendships/${currentUserNumericId}`); 
			const friendshipsSnapshot = await get(friendshipsRef);
			let friendIds = []; // Для Firebase UID друзей

			if (friendshipsSnapshot.exists()) {
				const friendships = friendshipsSnapshot.val();
				// Фильтруем друзей и получаем их numericId
				const friendNumericIds = Object.entries(friendships)
					.filter(([_, data]) => data && data.status === 'friends')
					.map(([friendNumericId, _]) => friendNumericId);
				
				// Получаем Firebase UID друзей по их numericId
				if (friendNumericIds.length > 0) {
					const usersRef = ref(db, 'users');
					const usersSnapshot = await get(usersRef);
					if (usersSnapshot.exists()) {
						const usersData = usersSnapshot.val();
						friendIds = Object.entries(usersData)
							.filter(([firebaseUid, userData]) => userData && friendNumericIds.includes(String(userData.numericId)))
							.map(([firebaseUid, _]) => firebaseUid);
					}
				}
			}
			console.log('[openMembersModal] Friend Firebase UIDs from friendships:', friendIds);
			// --- КОНЕЦ ИЗМЕНЕНИЯ ---
			
			// Массивы для хранения данных участников
			const allMembers = [];
			const admins = [];
			const friends = [];
			
			// Загружаем информацию о каждом участнике
			const memberPromises = Object.entries(groupData.members).map(async ([userId, memberData]) => {
				try {
					// Получаем данные пользователя-участника
					const memberUserRef = ref(db, `users/${userId}`); // userId здесь - это Firebase UID участника
					const memberUserSnapshot = await get(memberUserRef);
					if (!memberUserSnapshot.exists()) {
						console.warn(`[openMembersModal] Member user data not found for userId: ${userId}`);
						return null; 
					}
					const memberUserData = memberUserSnapshot.val();

					// Создаем объект с данными участника
					const memberItem = {
						firebaseId: userId,
						id: memberUserData.numericId || userId, // Используем numericId, если есть
						name: memberUserData.name || memberUserData.displayName || memberUserData.email || 'Пользователь',
						photoURL: memberUserData.photoURL || '',
						role: memberData.role
					};
					
					// Добавляем в соответствующие массивы
					allMembers.push(memberItem);
					
					if (memberData.role === 'admin') {
						admins.push(memberItem);
					}
					
					// Сравниваем Firebase UID участника с Firebase UID друзей
					const isFriend = friendIds.includes(userId); 
					// console.log(`[openMembersModal] Comparing member ${userId} with friends [${friendIds.join(', ')}]? ${isFriend}`); // Оставим один лог для проверки (закомментирован пока)
					
					if (isFriend) {
						friends.push(memberItem);
					}
					
					return memberItem;
				} catch (error) {
					console.error(`[openMembersModal] Error loading member data for ${userId}:`, error);
					return null;
				}
			});
			
			// Ждем завершения всех запросов
			await Promise.all(memberPromises);
			
			// Отображаем списки участников
			renderMembersList(allMembers, 'all-members-list', 'В группе нет участников');
			renderMembersList(admins, 'admins-list', 'В группе нет администраторов');
			renderMembersList(friends, 'friends-list', 'В этой группе нет ваших друзей');
		}

		// Функция отображения списка участников
		function renderMembersList(members, containerId, emptyMessage) {
			const container = document.getElementById(containerId);
			
			// Очищаем контейнер
			container.innerHTML = '';
			
			// Проверяем наличие участников
			if (members.length === 0) {
				container.innerHTML = `<div class="empty-tab-message">${emptyMessage}</div>`;
				return;
			}
			
			// Добавляем каждого участника в список
			members.forEach(member => {
				const memberEl = document.createElement('div');
				memberEl.className = 'members-modal-item';
				memberEl.innerHTML = `
					<div class="members-modal-avatar">
						${member.photoURL ? `<img src="${member.photoURL}" alt="${member.name}">` : ''}
					</div>
					<div class="members-modal-name">${member.name}</div>
					<div class="members-modal-role">${member.role === 'admin' ? 'Администратор' : 'Участник'}</div>
				`;
				
				// Добавляем обработчик для перехода на страницу пользователя, используя member.id (который теперь numericId)
				memberEl.addEventListener('click', () => {
					window.location.href = `profile.html?id=${member.id}`; 
				});
				
				container.appendChild(memberEl);
			});
		}

		// Функция для загрузки предложенных постов пользователя
        async function loadUserProposedPosts(groupId, userId) {
            try {
                const proposedPostsRef = ref(db, `proposedGroupPosts/${groupId}`);
                
                // Создаем запрос для получения предложенных постов
                onValue(proposedPostsRef, async (snapshot) => {
                    const myProposedPostsContainer = document.getElementById('my-proposed-posts-container');
                    
                    if (!myProposedPostsContainer) return;
                    
                    if (!snapshot.exists()) {
                        myProposedPostsContainer.innerHTML = `
                            <div class="empty-state">
                                <i class="fas fa-inbox"></i>
                                <p>У вас нет предложенных постов</p>
                            </div>
                        `;
                        
                        // Скрываем индикатор, если нет предложенных постов
                        const proposedTab = document.getElementById('my-proposed-posts-tab');
                        if (proposedTab) {
                            const badge = proposedTab.querySelector('.pending-badge');
                            if (badge) badge.style.display = 'none';
                        }
                        
                        return;
                    }
                    
                    // Фильтруем посты, оставляя только посты текущего пользователя
                    const myProposedPosts = [];
                    snapshot.forEach((childSnapshot) => {
                        const post = childSnapshot.val();
                        if (post.authorId === userId) {  // Только посты текущего пользователя
                            post.id = childSnapshot.key;
                            myProposedPosts.push(post);
                        }
                    });
                    
                    if (myProposedPosts.length === 0) {
                        myProposedPostsContainer.innerHTML = `
                            <div class="empty-state">
                                <i class="fas fa-inbox"></i>
                                <p>У вас нет предложенных постов</p>
                            </div>
                        `;
                        
                        // Скрываем индикатор, если нет предложенных постов
                        const proposedTab = document.getElementById('my-proposed-posts-tab');
                        if (proposedTab) {
                            const badge = proposedTab.querySelector('.pending-badge');
                            if (badge) badge.style.display = 'none';
                        }
                        
                        return;
                    }
                    
                    // Обновляем индикатор с количеством предложенных постов
                    const proposedTab = document.getElementById('my-proposed-posts-tab');
                    if (proposedTab) {
                        let badge = proposedTab.querySelector('.pending-badge');
                        if (!badge) {
                            badge = document.createElement('span');
                            badge.className = 'pending-badge';
                            proposedTab.appendChild(badge);
                        }
                        badge.textContent = myProposedPosts.length;
                        badge.style.display = 'inline-block';
                    }
                    
                    // Удаляем сообщение о пустом списке, если оно есть
                    const emptyState = myProposedPostsContainer.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.remove();
                    }
                    
                    // Сортируем посты по времени (сначала новые)
                    myProposedPosts.sort((a, b) => b.timestamp - a.timestamp);
                    
                    // Получаем список ID постов, которые уже отображаются
                    const existingPostIds = Array.from(
                        myProposedPostsContainer.querySelectorAll('.post-item')
                    ).map(element => element.id.replace('post-', ''));
                    
                    // Найдем ID постов, которые отображаются, но отсутствуют в отфильтрованных данных
                    const postIdsToRemove = existingPostIds.filter(
                        id => !myProposedPosts.some(post => post.id === id)
                    );
                    
                    // Удаляем посты, которых больше нет в данных
                    for (const idToRemove of postIdsToRemove) {
                        const postToRemove = document.getElementById(`post-${idToRemove}`);
                        if (postToRemove) {
                            // Добавляем анимацию исчезновения перед удалением
                            postToRemove.style.transition = 'opacity 0.3s, transform 0.3s';
                            postToRemove.style.opacity = '0';
                            postToRemove.style.transform = 'translateY(-10px)';
                            
                            // Удаляем элемент после завершения анимации
                            setTimeout(() => {
                                if (postToRemove.parentNode) {
                                    postToRemove.parentNode.removeChild(postToRemove);
                                }
                                
                                // Если все посты удалены, показываем сообщение о пустом списке
                                if (!myProposedPostsContainer.querySelector('.post-item')) {
                                    myProposedPostsContainer.innerHTML = `
                                        <div class="empty-state">
                                            <i class="fas fa-inbox"></i>
                                            <p>У вас нет предложенных постов</p>
                                        </div>
                                    `;
                                    
                                    // Скрываем индикатор, если больше нет предложенных постов
                                    const proposedTab = document.getElementById('my-proposed-posts-tab');
                                    if (proposedTab) {
                                        const badge = proposedTab.querySelector('.pending-badge');
                                        if (badge) badge.style.display = 'none';
                                    }
                                }
                            }, 300);
                        }
                    }
                    
                    // Фильтруем только новые посты
                    const newPosts = myProposedPosts.filter(post => !existingPostIds.includes(post.id));
                    
                    // Добавляем новые посты в начало контейнера
                    for (const post of newPosts) {
                        const tempContainer = document.createElement('div');
                        await renderProposedPost(post, tempContainer, userId, groupId);
                        
                        if (tempContainer.firstChild) {
                            const newPostEl = tempContainer.firstChild;
                            
                            // Устанавливаем начальные стили для анимации
                            newPostEl.style.opacity = '0';
                            newPostEl.style.transform = 'translateY(-20px)';
                            newPostEl.style.transition = 'opacity 0.5s, transform 0.5s';
                            
                            // Вставляем пост в начало списка
                            if (myProposedPostsContainer.firstChild) {
                                myProposedPostsContainer.insertBefore(newPostEl, myProposedPostsContainer.firstChild);
                            } else {
                                myProposedPostsContainer.appendChild(newPostEl);
                            }
                            
                            // Запускаем анимацию появления (timeout нужен для работы анимации)
                            setTimeout(() => {
                                newPostEl.style.opacity = '1';
                                newPostEl.style.transform = 'translateY(0)';
                            }, 10);
                        }
                    }
                    
                    // Обновляем существующие посты, если они изменились
                    for (const post of myProposedPosts) {
                        if (existingPostIds.includes(post.id)) {
                            const existingPost = document.getElementById(`post-${post.id}`);
                            // Обновляем только важную информацию, если она изменилась
                            // Например, содержание поста
                            const contentEl = existingPost.querySelector('.post-content');
                            if (contentEl && contentEl.textContent !== post.content) {
                                contentEl.textContent = post.content;
                            }
                            
                            // Обновляем изображение, если оно изменилось
                            const imageEl = existingPost.querySelector('.post-image');
                            if (post.imageURL) {
                                if (!imageEl) {
                                    // Если изображения не было, но теперь оно есть
                                    const newImage = document.createElement('img');
                                    newImage.src = post.imageURL;
                                    newImage.alt = 'Изображение к посту';
                                    newImage.className = 'post-image';
                                    existingPost.querySelector('.post-content').after(newImage);
                                } else if (imageEl.src !== post.imageURL) {
                                    // Если изображение изменилось
                                    imageEl.src = post.imageURL;
                                }
                            } else if (imageEl) {
                                // Если изображение было, но теперь его нет
                                imageEl.remove();
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error loading user proposed posts:', error);
            }
        }
        
        // Функция для отображения предложенного поста пользователя
        async function renderProposedPost(post, container, userId, groupId) {
            try {
                // Получаем информацию об авторе поста (это сам пользователь)
                const authorRef = ref(db, `users/${userId}`);
                const authorSnapshot = await get(authorRef);
                
                if (!authorSnapshot.exists()) {
                    console.error('Author data not found for post:', post.id);
                    return;
                }
                
                const authorData = authorSnapshot.val();
                
                // Создаем элемент поста
                const postEl = document.createElement('div');
                postEl.className = 'post-item pending-post-item';
                postEl.id = `post-${post.id}`;
                
                // Форматируем дату
                const postDate = new Date(post.timestamp);
                const formattedDate = postDate.toLocaleString('ru-RU', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                // Заполняем содержимое поста
                postEl.innerHTML = `
                    <div class="post-header">
                        <div class="post-author-avatar">
                            ${authorData.photoURL ? `<img src="${authorData.photoURL}" alt="${authorData.name || authorData.displayName || 'Пользователь'}">` : ''}
                        </div>
                        <div class="post-info">
                            <div class="post-author-name">${authorData.name || authorData.displayName || authorData.email || 'Пользователь'}</div>
                            <div class="post-date">${formattedDate}</div>
                        </div>
                    </div>
                    <div class="post-content">${post.content}</div>
                    ${post.imageURL ? `<img src="${post.imageURL}" alt="Изображение к посту" class="post-image">` : ''}
                    <div class="pending-post-status">
                        <div class="pending-post-info">Ожидает одобрения администратора</div>
                        <div class="pending-post-actions">
                            <button class="reject-btn" data-post-id="${post.id}">Удалить</button>
                        </div>
                    </div>
                `;
                
                // Добавляем обработчик для кнопки удаления
                const deleteBtn = postEl.querySelector('.reject-btn');
                deleteBtn.addEventListener('click', () => {
                    deleteProposedPost(groupId, post.id);
                });
                
                // Добавляем пост в контейнер
                container.appendChild(postEl);
                
            } catch (error) {
                console.error('Error rendering proposed post:', error);
            }
        }
        
        // Функция для удаления предложенного поста пользователем
        async function deleteProposedPost(groupId, postId) {
            if (!confirm('Вы уверены, что хотите удалить этот предложенный пост?')) {
                return;
            }
            
            try {
                // Удаляем предложенный пост из базы данных
                await set(ref(db, `proposedGroupPosts/${groupId}/${postId}`), null);
                
                console.log('Proposed post deleted successfully');
                
            } catch (error) {
                console.error('Error deleting proposed post:', error);
                alert('Ошибка при удалении предложенного поста');
            }
        }

		// Функции для работы с комментариями к постам
		function createCommentElement(comment, authorData, currentUser, level = 0) {
			const commentElement = document.createElement('div');
			commentElement.className = 'comment';
			commentElement.dataset.commentId = comment.id;
			commentElement.dataset.level = level;

			const defaultAuthorData = {
				name: 'Удаленный пользователь',
				photoURL: 'https://ui-avatars.com/api/?name=User&background=random',
				email: '',
				numericId: null
			};

			const author = authorData || defaultAuthorData;

			if (comment.authorPhotoURL) {
				author.photoURL = comment.authorPhotoURL;
			}

			let deleteButtonHtml = '';
			if (currentUser) {
				const canDelete = currentUser.uid === comment.authorId;
				if (canDelete) {
					deleteButtonHtml = `
						<button class="reply-btn delete" onclick="window.deleteComment('${comment.id}')">
							<i class="fas fa-trash"></i>
						</button>
					`;
				}
			}

			let votesHtml = '';
			if (currentUser) {
				votesHtml = `
					<button class="vote-btn like" onclick="window.handleVote('${comment.id}', 1)">
						<i class="fas fa-thumbs-up"></i>
						<span class="vote-count like-count">0</span>
					</button>
					<button class="vote-btn dislike" onclick="window.handleVote('${comment.id}', -1)">
						<i class="fas fa-thumbs-down"></i>
						<span class="vote-count dislike-count">0</span>
					</button>
					<span class="author-like-container"></span>
				`;
			}

			let replyInfoHtml = '';
			if (comment.replyToAuthor && comment.parentId) {
				let replyToText = '';
				if (comment.replyToText) {
					replyToText = comment.replyToText;
				}

				const maxLength = 30;
				if (replyToText.length > maxLength) {
					replyToText = replyToText.substring(0, maxLength) + '..';
				}

				replyInfoHtml = `
					<div class="reply-info" data-reply-to-id="${comment.actualReplyToId || comment.parentId}" onclick="window.scrollToOriginalComment('${comment.actualReplyToId || comment.parentId}')">
						в ответ <span class="reply-author">@${comment.replyToAuthor}</span> ${replyToText ? `<span class="reply-info-divider">|</span> ${replyToText}` : ''}
					</div>
				`;
			}
			
			// Функция для проверки, является ли URL видео
			function isVideoUrl(url) {
				return url.includes('.mp4') || url.includes('.webm') || url.includes('.ogg') || url.includes('.mov') || 
				       url.includes('video') || url.includes('comment_videos');
			}
			
			// Генерируем HTML для медиафайлов (изображения и видео)
			let imagesHtml = '';
			if (comment.imageUrls && comment.imageUrls.length > 0) {
				imagesHtml = `
					<div class="comment-images count-${comment.imageUrls.length}">
						${comment.imageUrls.map((url, index) => {
							const isVideo = isVideoUrl(url);
							return `
								<div class="comment-image-item" data-url="${url}" data-index="${index}">
									${isVideo ? 
										`<div class="video-container">
											<video src="${url}" preload="metadata"></video>
											<div class="video-overlay"></div>
										</div>` : 
										`<img src="${url}" alt="Изображение ${index + 1} в комментарии">`
									}
								</div>
							`;
						}).join('')}
					</div>
				`;
			}

			const profileLink = author.numericId ? `profile.html?id=${author.numericId}` : '#';
			const avatarLinkClass = author.numericId ? 'comment-avatar-link' : 'comment-avatar-link disabled';

			commentElement.innerHTML = `
				<a href="${profileLink}" class="${avatarLinkClass}">
					<img src="${author.photoURL || 'https://ui-avatars.com/api/?name=User&background=random'}" alt="" class="comment-avatar">
				</a>
				<div class="comment-main">
					<div class="comment-header">
						<a href="${profileLink}" class="comment-author">${author.name || 'Удаленный пользователь'}</a>
						<span class="comment-date">${formatDate(comment.timestamp)}</span>
					</div>
					${replyInfoHtml}
					<div class="comment-content">${comment.text}</div>
					${imagesHtml}
					<div class="comment-votes">
						${votesHtml}
						<button class="reply-btn" onclick="window.toggleReplyForm('${comment.id}')">
							<i class="fas fa-reply"></i> Ответить
						</button>
						${deleteButtonHtml}
					</div>
					<form class="reply-form" data-parent-id="${comment.id}">
						<img src="${currentUser ? (window.currentUserData?.photoURL || currentUser.photoURL || 'https://ui-avatars.com/api/?name=User&background=random') : 'https://ui-avatars.com/api/?name=User&background=random'}" alt="" class="comment-form-avatar">
						<div class="comment-form-content">
							<textarea class="reply-input" placeholder="Написать ответ..." maxlength="1000" rows="1"></textarea>
							<div class="reply-character-counter" data-comment-id="${comment.id}">0/1000</div>
							<div class="image-upload-container">
								<button type="button" class="image-upload-button reply-image-upload-button" data-comment-id="${comment.id}">
									<i class="fas fa-image"></i> <span>Прикрепить медиа</span>
								</button>
								<input type="file" class="image-upload-input reply-image-upload-input" data-comment-id="${comment.id}" accept="image/*,video/*" multiple>
								<div class="image-counter reply-image-counter" data-comment-id="${comment.id}" style="display: none;">0/10</div>
							</div>
							<div class="image-preview-container reply-image-preview-container" data-comment-id="${comment.id}">
								<div class="image-gallery reply-image-gallery" data-comment-id="${comment.id}"></div>
								<button type="button" class="clear-all-images reply-clear-all-images" data-comment-id="${comment.id}">
									<i class="fas fa-trash"></i> Удалить все
								</button>
							</div>
							<div class="comment-form-buttons">
								<button type="button" class="secondary cancel-reply-button" data-comment-id="${comment.id}">
									<i class="fas fa-times"></i> Отмена
								</button>
								<button type="submit" class="primary">
									<i class="fas fa-paper-plane"></i> Ответить
								</button>
							</div>
						</div>
					</form>
					<div class="comment-replies" data-parent-id="${comment.id}"></div>
				</div>
			`;

			// Добавляем обработчики для просмотра медиафайлов в комментарии
			const mediaItems = commentElement.querySelectorAll('.comment-image-item');
			mediaItems.forEach((item, index) => {
				item.addEventListener('click', (e) => {
					// Если клик был по оверлею или изображению, но не по видео
					if (e.target.closest('.video-overlay') || e.target.tagName === 'IMG') {
						const url = item.dataset.url;
						if (url) {
							window.openImageModal(url, commentElement, index);
						}
					}
				});
				
				// Добавляем отдельный обработчик для видео-оверлея
				const videoOverlay = item.querySelector('.video-overlay');
				if (videoOverlay) {
					videoOverlay.addEventListener('click', (e) => {
						e.preventDefault();
						e.stopPropagation();
						const url = item.dataset.url;
						if (url) {
							window.openImageModal(url, commentElement, index);
						}
					});
				}
			});
			
			// Добавляем обработчик формы ответа
			const replyForm = commentElement.querySelector('.reply-form');
			if (replyForm) {
				// Инициализируем загрузку изображений для ответа
				const replyImageUploadManager = new ImageUploadManager(replyForm, 'reply', comment.id);
				
			replyForm.addEventListener('submit', async (e) => {
				e.preventDefault();
				const text = e.target.querySelector('.reply-input').value.trim();
				const commentId = replyForm.dataset.parentId;
				const postId = commentElement.closest('.post-comments-section').dataset.postId;
				const groupId = getGroupIdFromUrl();
				
					// Получаем загруженные изображения
					const uploadedImages = replyImageUploadManager.getUploadedImagesUrls();
					
					// Проверяем, что есть текст или изображения
					if (!text && (!uploadedImages || uploadedImages.length === 0)) {
						if (typeof window.showError === 'function') {
							window.showError('Комментарий должен содержать текст или изображение');
						} else {
							alert('Комментарий должен содержать текст или изображение');
						}
					return;
				}

				try {
					const replyToAuthor = author.name || 'Удаленный пользователь';
						await addComment(groupId, postId, text, commentId, replyToAuthor, comment.text, uploadedImages);
					e.target.querySelector('.reply-input').value = '';
					replyForm.classList.remove('active');
						
						// Очищаем загруженные изображения
						replyImageUploadManager.clearImages();
				} catch (error) {
					console.error('Ошибка при добавлении ответа:', error);
				}
			});
				
				// Инициализируем обработчик отмены
				const cancelButton = replyForm.querySelector('.cancel-reply-button');
				if (cancelButton) {
					cancelButton.addEventListener('click', () => {
						const textarea = replyForm.querySelector('.reply-input');
						if (textarea) {
							textarea.value = '';
						}
						
						// Очищаем загруженные изображения
						if (replyImageUploadManager) {
							replyImageUploadManager.clearImages();
						}
						
						replyForm.classList.remove('active');
					});
				}
			}

			return commentElement;
		}

		// Форматирование даты комментария
		function formatDate(timestamp) {
			if (!timestamp) return 'только что';
			
			const date = new Date(timestamp);
			const now = new Date();
			const diffMs = now - date;
			const diffSec = Math.floor(diffMs / 1000);
			const diffMin = Math.floor(diffSec / 60);
			const diffHour = Math.floor(diffMin / 60);
			const diffDay = Math.floor(diffHour / 24);

			if (diffSec < 60) {
				return 'только что';
			} else if (diffMin < 60) {
				return `${diffMin} ${declension(diffMin, ['минуту', 'минуты', 'минут'])} назад`;
			} else if (diffHour < 24) {
				return `${diffHour} ${declension(diffHour, ['час', 'часа', 'часов'])} назад`;
			} else if (diffDay < 7) {
				return `${diffDay} ${declension(diffDay, ['день', 'дня', 'дней'])} назад`;
			} else {
				return date.toLocaleString('ru-RU', {
					day: '2-digit',
					month: '2-digit',
					year: 'numeric',
					hour: '2-digit',
					minute: '2-digit'
				});
			}
		}

		// Функция для склонения слов
		function declension(number, words) {
			const cases = [2, 0, 1, 1, 1, 2];
			return words[(number % 100 > 4 && number % 100 < 20) ? 2 : cases[(number % 10 < 5) ? number % 10 : 5]];
		}

		// Получение ID группы из URL
		function getGroupIdFromUrl() {
			const urlParams = new URLSearchParams(window.location.search);
			return urlParams.get('id');
		}

		// Функция для отображения комментария
		async function renderComment(groupId, postId, comment, container, level = 0) {
			try {
				// Получаем текущего пользователя
				const currentUser = auth.currentUser;
				
				// Получаем информацию об авторе комментария
				let authorData = null;
				
				if (comment.authorId) {
					const authorRef = ref(db, `users/${comment.authorId}`);
					const authorSnapshot = await get(authorRef);
					
					if (authorSnapshot.exists()) {
						const data = authorSnapshot.val();
						authorData = {
							name: data.name || data.displayName || data.email || 'Пользователь',
							photoURL: data.photoURL || comment.authorPhotoURL || null,
							email: data.email || null,
							numericId: data.numericId || null
						};
					}
				}
				
				// Создаем элемент комментария
				const commentElement = createCommentElement(comment, authorData, currentUser, level);
				
				// Настраиваем слушатель голосов для комментария
				setupVotesListener(comment.id, commentElement);
				
				// Добавляем комментарий в контейнер
				container.appendChild(commentElement);
			} catch (error) {
				console.error('Ошибка при отображении комментария:', error);
			}
		}

		// Функция для загрузки комментариев к посту
		async function loadComments(groupId, postId) {
			try {
				const commentsRef = ref(db, `groupComments/${groupId}/${postId}`);
				
				// Подписываемся на изменения комментариев в реальном времени
				onValue(commentsRef, async (snapshot) => {
					const commentsContainer = document.querySelector(`.comments-list[data-post-id="${postId}"]`);
					if (!commentsContainer) return;
					
					if (!snapshot.exists()) {
						commentsContainer.innerHTML = '<div class="no-comments">Нет комментариев</div>';
						return;
					}
					
					// Получаем все комментарии из базы данных
					const comments = [];
					snapshot.forEach(childSnapshot => {
						const comment = childSnapshot.val();
						comment.id = childSnapshot.key;
						comments.push(comment);
					});
					
					// Сортировка по возрастанию clientTimestamp (от старых к новым)
					comments.sort((a, b) => {
						const timeA = a.clientTimestamp || 0;
						const timeB = b.clientTimestamp || 0;
						return timeA - timeB;
					});
					
					// Собираем ID всех комментариев из базы данных
					const dbCommentIds = new Set(comments.map(comment => comment.id));
					
					// Проверяем существующие комментарии в DOM и удаляем те, которых нет в базе данных
					const existingCommentIds = new Set();
					commentsContainer.querySelectorAll('.comment').forEach(el => {
						const commentId = el.dataset.commentId;
						existingCommentIds.add(commentId);
						
						// Если комментария нет в базе данных, удаляем его из DOM
						if (!dbCommentIds.has(commentId)) {
							// Если это корневой комментарий, удаляем также контейнер с ответами
							if (!el.closest('.comment-replies')) {
								const repliesContainer = document.querySelector(`.comment-replies[data-parent-id="${commentId}"]`);
								if (repliesContainer) {
									repliesContainer.remove();
								}
							}
							el.remove();
						}
					});
					
					// Отдельно храним корневые комментарии и ответы
					const rootComments = [];
					const replies = {};
					
					comments.forEach(comment => {
						if (!comment.parentId) {
							rootComments.push(comment);
						} else {
							if (!replies[comment.parentId]) {
								replies[comment.parentId] = [];
							}
							replies[comment.parentId].push(comment);
						}
					});
					
					// Удаляем сообщение "Нет комментариев", если оно есть и теперь есть комментарии
					const noCommentsEl = commentsContainer.querySelector('.no-comments');
					if (noCommentsEl && rootComments.length > 0) {
						noCommentsEl.remove();
					}
					
					// Отображаем только новые корневые комментарии
					for (const comment of rootComments) {
						// Проверяем, существует ли уже этот комментарий в DOM
						if (!existingCommentIds.has(comment.id)) {
							await renderComment(groupId, postId, comment, commentsContainer);
						}
					}
					
					// Получаем список отображенных контейнеров для ответов
					const repliesContainers = {};
					commentsContainer.querySelectorAll('.comment-replies').forEach(el => {
						repliesContainers[el.dataset.parentId] = el;
					});
					
					// Отображаем новые ответы на комментарии
					for (const parentId in replies) {
						// Проверяем, есть ли контейнер для ответов
						let parentRepliesContainer = repliesContainers[parentId];
						
						if (!parentRepliesContainer) {
							// Если контейнера нет, пропускаем
							continue;
						}
						
						// Получаем текущие ответы в DOM для этого родительского комментария
						const existingRepliesIds = new Set();
						parentRepliesContainer.querySelectorAll('.comment').forEach(el => {
							existingRepliesIds.add(el.dataset.commentId);
						});
						
						// Проверяем количество новых ответов
						const newReplies = replies[parentId].filter(reply => !existingRepliesIds.has(reply.id));
						const repliesCount = replies[parentId].length;
						
						// Если есть новые ответы и уже есть контейнер с ответами
						if (newReplies.length > 0) {
							// Ищем существующий контейнер для скрытых ответов
							let hiddenRepliesContainer = parentRepliesContainer.querySelector('.hidden-replies');
							let showRepliesButton = parentRepliesContainer.querySelector('.show-more-replies');
							
							// Если контейнера нет, но есть ответы - создаем его
							if (!hiddenRepliesContainer && repliesCount > 0) {
								hiddenRepliesContainer = document.createElement('div');
								hiddenRepliesContainer.className = 'hidden-replies';
								parentRepliesContainer.appendChild(hiddenRepliesContainer);
								
								// Создаем кнопку "Показать ответы"
								showRepliesButton = document.createElement('button');
								showRepliesButton.className = 'show-more-replies';
								showRepliesButton.innerHTML = `<i class="fas fa-chevron-down"></i> Показать ответы (${repliesCount})`;
								showRepliesButton.onclick = function() {
									hiddenRepliesContainer.classList.toggle('expanded');
									this.innerHTML = hiddenRepliesContainer.classList.contains('expanded') 
										? `<i class="fas fa-chevron-up"></i> Скрыть ответы` 
										: `<i class="fas fa-chevron-down"></i> Показать ответы (${repliesCount})`;
								};
								
								// Вставляем кнопку перед контейнером скрытых ответов
								parentRepliesContainer.insertBefore(showRepliesButton, hiddenRepliesContainer);
								
								// Помечаем контейнер как имеющий ответы
								parentRepliesContainer.classList.add('has-replies');
							}
							
							// Обновляем текст кнопки с новым количеством ответов
							if (showRepliesButton) {
								if (!hiddenRepliesContainer.classList.contains('expanded')) {
									showRepliesButton.innerHTML = `<i class="fas fa-chevron-down"></i> Показать ответы (${repliesCount})`;
								}
							}
							
							// Отображаем только новые ответы
							for (const reply of newReplies) {
								await renderComment(groupId, postId, reply, hiddenRepliesContainer, 1);
							}
						}
					}
					
					// Проверяем все контейнеры с ответами на странице
					commentsContainer.querySelectorAll('.comment-replies').forEach(repliesContainer => {
						const parentId = repliesContainer.dataset.parentId;
						const hiddenRepliesContainer = repliesContainer.querySelector('.hidden-replies');
						const showRepliesButton = repliesContainer.querySelector('.show-more-replies');
						
						// Получаем актуальное количество ответов из данных базы данных
						const actualReplies = replies[parentId] || [];
						const repliesCount = actualReplies.length;
						
						// Если ответов не осталось, но кнопка и контейнер есть - удаляем их
						if (repliesCount === 0) {
							if (showRepliesButton) showRepliesButton.remove();
							if (hiddenRepliesContainer) hiddenRepliesContainer.remove();
							// Удаляем класс has-replies у контейнера с ответами
							repliesContainer.classList.remove('has-replies');
						} else if (repliesCount > 0 && showRepliesButton) {
							// Обновляем текст кнопки с актуальным количеством ответов
							if (!hiddenRepliesContainer.classList.contains('expanded')) {
								// Явно устанавливаем актуальное количество ответов
								showRepliesButton.innerHTML = `<i class="fas fa-chevron-down"></i> Показать ответы (${repliesCount})`;
							}
							
							// Обновляем кнопку также в обработчике клика
							showRepliesButton.onclick = function() {
								hiddenRepliesContainer.classList.toggle('expanded');
								const isExpanded = hiddenRepliesContainer.classList.contains('expanded');
								this.innerHTML = isExpanded 
									? `<i class="fas fa-chevron-up"></i> Скрыть ответы` 
									: `<i class="fas fa-chevron-down"></i> Показать ответы (${repliesCount})`;
							};
						}
					});
				});
			} catch (error) {
				console.error('Ошибка при загрузке комментариев:', error);
			}
		}

		// Функция для добавления комментария
		async function addComment(groupId, postId, text, parentId = null, replyToAuthor = null, replyToText = null, imageUrls = []) {
			const currentUser = auth.currentUser;
			if (!currentUser) {
				if (typeof window.showError === 'function') {
					window.showError('Необходимо войти в систему для комментирования');
				} else {
					alert('Необходимо войти в систему для комментирования');
				}
				return;
			}

			// Проверяем, есть ли текст или изображения
			if (!text && (!imageUrls || imageUrls.length === 0)) {
				if (typeof window.showError === 'function') {
					window.showError('Комментарий должен содержать текст или изображение');
				} else {
					alert('Комментарий должен содержать текст или изображение');
				}
				return;
			}

			try {
				const commentsRef = ref(db, `groupComments/${groupId}/${postId}`);
				const newCommentRef = push(commentsRef);
				const newCommentId = newCommentRef.key;

				// Определяем уровень родительского комментария
				let parentLevel = 0;
				let effectiveParentId = parentId;

				if (parentId) {
					const parentElement = document.querySelector(`[data-comment-id="${parentId}"]`);
					if (parentElement) {
						parentLevel = parseInt(parentElement.dataset.level);

						if (parentLevel >= 1) {
							const parentComment = await get(ref(db, `groupComments/${groupId}/${postId}/${parentId}`));
							if (parentComment.exists()) {
								effectiveParentId = parentComment.val().parentId || parentId;
							}
						}
					}
				}

				// Используем клиентскую временную метку для немедленного отображения и определения новых комментариев
				const clientTimestamp = Date.now();

				// Получаем URL аватара пользователя
				let authorPhotoURL = currentUser.photoURL;

				try {
					const userRef = ref(db, `users/${currentUser.uid}`);
					const userSnapshot = await get(userRef);
					if (userSnapshot.exists()) {
						const userData = userSnapshot.val();
						if (userData.photoURL) {
							authorPhotoURL = userData.photoURL;
						}
					}
				} catch (error) {
					console.error("Ошибка при получении данных пользователя:", error);
				}

				const newComment = {
					authorId: currentUser.uid,
					authorPhotoURL: authorPhotoURL,
					text: text,
					parentId: effectiveParentId,
					replyToAuthor: replyToAuthor,
					replyToText: replyToText,
					timestamp: serverTimestamp(),
					clientTimestamp: clientTimestamp,
					actualReplyToId: parentId
				};

				// Добавляем URL изображения, если оно есть
				if (imageUrls.length > 0) {
					newComment.imageUrls = imageUrls;
				}

				// Сохраняем комментарий в базу данных
				await set(newCommentRef, newComment);
				
				// Если это ответ на комментарий, прокручиваем к нему после добавления
				if (parentId) {
					setTimeout(() => {
						const replyContainer = document.querySelector(`.comment-replies[data-parent-id="${effectiveParentId}"] .hidden-replies`);
						if (replyContainer) {
							// Раскрываем ответы, если они скрыты
							if (!replyContainer.classList.contains('expanded')) {
								const showRepliesButton = replyContainer.parentElement.querySelector('.show-more-replies');
								if (showRepliesButton) {
									showRepliesButton.click();
								}
							}
							
							// Прокручиваем к ответам
							replyContainer.scrollTop = replyContainer.scrollHeight;
						}
					}, 1000); // Даём время на обновление DOM
				}

				console.log("Комментарий успешно добавлен:", newCommentId);
			} catch (error) {
				console.error("Ошибка при добавлении комментария:", error);
				if (typeof window.showError === 'function') {
					window.showError("Не удалось добавить комментарий. Пожалуйста, попробуйте еще раз.");
				} else {
					alert("Не удалось добавить комментарий. Пожалуйста, попробуйте еще раз.");
				}
			}
		}

		// Функция для удаления комментария
		window.deleteComment = async function(commentId, isRoot = true) {
			try {
				if (!confirm('Вы уверены, что хотите удалить этот комментарий?')) {
					return;
				}
				
				const groupId = getGroupIdFromUrl();
				const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
				if (!commentElement) return;
				
				const postId = commentElement.closest('.post-comments-section').dataset.postId;
				
				// Удаляем комментарий из базы данных
				const commentRef = ref(db, `groupComments/${groupId}/${postId}/${commentId}`);
				await remove(commentRef);
				
				// Если это корневой комментарий, удаляем также все ответы на него
				if (isRoot) {
					const commentsRef = ref(db, `groupComments/${groupId}/${postId}`);
					const commentsSnapshot = await get(commentsRef);
					
					if (commentsSnapshot.exists()) {
						commentsSnapshot.forEach(childSnapshot => {
							const childComment = childSnapshot.val();
							if (childComment.parentId === commentId) {
								const childCommentRef = ref(db, `groupComments/${groupId}/${postId}/${childSnapshot.key}`);
								remove(childCommentRef);
							}
						});
					}
				}
				
				console.log('Комментарий успешно удален');
			} catch (error) {
				console.error('Ошибка при удалении комментария:', error);
				if (typeof window.showError === 'function') {
					window.showError('Не удалось удалить комментарий');
				} else {
					alert('Не удалось удалить комментарий');
				}
			}
		};

		// Глобальная функция для прокрутки к оригинальному комментарию
		window.scrollToOriginalComment = function(commentId) {
			const originalComment = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
			if (originalComment) {
				// Прокручиваем к комментарию
				originalComment.scrollIntoView({ behavior: 'smooth', block: 'center' });
				
				// Добавляем класс для подсветки комментария
				originalComment.classList.add('highlighted');
				
				// Удаляем класс подсветки через 2 секунды
				setTimeout(() => {
					originalComment.classList.remove('highlighted');
				}, 2000);
			}
		};

		// Функция для переключения формы ответа
		window.toggleReplyForm = function(commentId) {
			// Закрываем все другие формы ответов
			const allForms = document.querySelectorAll('.reply-form');
			allForms.forEach(form => {
				if (form.dataset.parentId !== commentId) {
					form.classList.remove('active');
				}
			});
			
			const replyForm = document.querySelector(`.reply-form[data-parent-id="${commentId}"]`);
			if (replyForm) {
				replyForm.classList.toggle('active');
				
				if (replyForm.classList.contains('active')) {
					// Обновляем аватар пользователя в форме ответа
					const currentUser = auth.currentUser;
					if (currentUser) {
						const avatarImg = replyForm.querySelector('.comment-form-avatar');
						if (avatarImg) {
							avatarImg.src = window.currentUserData?.photoURL || currentUser.photoURL || 'https://ui-avatars.com/api/?name=User&background=random';
						}
					}
					
					// Устанавливаем фокус на поле ввода ответа
					const replyInput = replyForm.querySelector('.reply-input');
					if (replyInput) {
						setTimeout(() => {
							replyInput.focus();
						}, 10);
					}
					
					// Инициализируем загрузку изображений для ответа, если ещё не сделано
					const commentElement = document.querySelector(`[data-comment-id="${commentId}"]`);
					if (commentElement && !commentElement.replyUploadInitialized) {
						const replyImageUploadManager = new ImageUploadManager(replyForm, 'reply', commentId);
						commentElement.replyUploadInitialized = true;
					}
				}
			}
		};

		// Функция для обработки голосования за комментарии
		window.handleVote = async function (commentId, value) {
			const currentUser = auth.currentUser;
			if (!currentUser) {
				if (typeof window.showError === 'function') {
					window.showError('Необходимо войти в систему для голосования');
				} else {
					alert('Необходимо войти в систему для голосования');
				}
				return;
			}

			try {
				const votesRef = ref(db, `groupCommentVotes/${commentId}`);

				// Получаем текущие голоса
				const votesSnapshot = await get(votesRef);
				const votes = votesSnapshot.val() || {};
				const userVote = votes[currentUser.uid] || 0;

				// Если пользователь нажимает на ту же кнопку - отменяем голос
				if (userVote === value) {
					delete votes[currentUser.uid];
				} else {
					// Иначе устанавливаем новый голос
					votes[currentUser.uid] = value;
				}

				// Обновляем голоса в базе данных
				await set(votesRef, votes);

				// Обновляем UI через слушатель onValue
			} catch (error) {
				console.error('Ошибка при голосовании:', error);
				if (typeof window.showError === 'function') {
					window.showError('Ошибка при голосовании');
				} else {
					alert('Ошибка при голосовании');
				}
			}
		};

		// Функция для настройки слушателя голосов для комментария
		function setupVotesListener(commentId, commentElement) {
			const votesRef = ref(db, `groupCommentVotes/${commentId}`);

			// Используем onValue для получения обновлений в реальном времени
			onValue(votesRef, async (votesSnapshot) => {
				const votes = votesSnapshot.val() || {};
				const likes = Object.values(votes).filter(v => v === 1).length;
				const dislikes = Object.values(votes).filter(v => v === -1).length;
				const userVote = auth.currentUser ? votes[auth.currentUser.uid] || 0 : 0;

				// Обновляем UI голосов
				const likeBtn = commentElement.querySelector('.vote-btn.like');
				const dislikeBtn = commentElement.querySelector('.vote-btn.dislike');
				const likeCount = likeBtn?.querySelector('.like-count');
				const dislikeCount = dislikeBtn?.querySelector('.dislike-count');
				const authorLikeContainer = commentElement.querySelector('.author-like-container');

				if (likeBtn && dislikeBtn && likeCount && dislikeCount) {
					likeBtn.classList.toggle('active', userVote === 1);
					dislikeBtn.classList.toggle('active', userVote === -1);
					likeCount.textContent = likes;
					dislikeCount.textContent = dislikes;

					try {
						// Получаем ID группы
						const groupId = getGroupIdFromUrl();
						
						// Получаем информацию о группе
						const groupRef = ref(db, `groups/${groupId}`);
						const groupSnapshot = await get(groupRef);
						
						if (groupSnapshot.exists()) {
							const groupData = groupSnapshot.val();
							const groupCreatorId = groupData.creatorId;
							
							if (groupCreatorId && votes[groupCreatorId] === 1) {
								// Проверяем, существует ли уже индикатор лайка создателя группы
								const existingAuthorLike = authorLikeContainer.querySelector('.author-like');
								if (!existingAuthorLike) {
									// Получаем данные создателя группы
									const creatorRef = ref(db, `users/${groupCreatorId}`);
									const creatorSnapshot = await get(creatorRef);
									const creatorData = creatorSnapshot.val();

									if (creatorData && authorLikeContainer) {
										authorLikeContainer.innerHTML = `
											<span class="author-like">
												<i class="fas fa-heart"></i>
												<img src="${creatorData.photoURL || 'https://ui-avatars.com/api/?name=User&background=random'}" 
													 alt="Создатель группы" 
													 class="author-like-avatar"
													 title="Понравилось создателю группы">
											</span>
										`;
									}
								}
							} else if (authorLikeContainer) {
								// Удаляем индикатор, только если он существует
								const existingAuthorLike = authorLikeContainer.querySelector('.author-like');
								if (existingAuthorLike) {
									authorLikeContainer.innerHTML = '';
								}
							}
						}
					} catch (error) {
						console.error('Ошибка при проверке лайка создателя:', error);
					}
				}
			});
		}

		// Функция для обработки голосования за посты
		window.handlePostVote = async function (postId, value) {
			const currentUser = auth.currentUser;
			if (!currentUser) {
				if (typeof window.showError === 'function') {
					window.showError('Необходимо войти в систему для голосования');
				} else {
					alert('Необходимо войти в систему для голосования');
				}
				return;
			}

			try {
				const votesRef = ref(db, `groupPostVotes/${postId}`);

				// Получаем текущие голоса
				const votesSnapshot = await get(votesRef);
				const votes = votesSnapshot.val() || {};
				const userVote = votes[currentUser.uid] || 0;

				// Если пользователь нажимает на ту же кнопку - отменяем голос
				if (userVote === value) {
					delete votes[currentUser.uid];
				} else {
					// Иначе устанавливаем новый голос
					votes[currentUser.uid] = value;
				}

				// Обновляем голоса в базе данных
				await set(votesRef, votes);

				// Обновляем UI через слушатель onValue
			} catch (error) {
				console.error('Ошибка при голосовании за пост:', error);
				if (typeof window.showError === 'function') {
					window.showError('Ошибка при голосовании');
				} else {
					alert('Ошибка при голосовании');
				}
			}
		};

		// Функция для настройки слушателя голосов для поста
		function setupPostVotesListener(groupId, postId, postElement) {
			const votesRef = ref(db, `groupPostVotes/${postId}`);

			// Используем onValue для получения обновлений в реальном времени
			onValue(votesRef, async (votesSnapshot) => {
				const votes = votesSnapshot.val() || {};
				const likes = Object.values(votes).filter(v => v === 1).length;
				const dislikes = Object.values(votes).filter(v => v === -1).length;
				const userVote = auth.currentUser ? votes[auth.currentUser.uid] || 0 : 0;

				// Обновляем UI голосов
				const likeBtn = postElement.querySelector('.post-like-btn');
				const dislikeBtn = postElement.querySelector('.post-dislike-btn');
				const likeCount = likeBtn?.querySelector('.post-like-count');
				const dislikeCount = dislikeBtn?.querySelector('.post-dislike-count');
				const authorLikeContainer = postElement.querySelector('.post-author-like-container');

				if (likeBtn && dislikeBtn && likeCount && dislikeCount) {
					// Обновляем классы активности кнопок
					if (userVote === 1) {
						likeBtn.classList.add('active');
						likeBtn.querySelector('i').classList.remove('far');
						likeBtn.querySelector('i').classList.add('fas');
					} else {
						likeBtn.classList.remove('active');
						likeBtn.querySelector('i').classList.remove('fas');
						likeBtn.querySelector('i').classList.add('far');
					}
					
					if (userVote === -1) {
						dislikeBtn.classList.add('active');
						dislikeBtn.querySelector('i').classList.remove('far');
						dislikeBtn.querySelector('i').classList.add('fas');
					} else {
						dislikeBtn.classList.remove('active');
						dislikeBtn.querySelector('i').classList.remove('fas');
						dislikeBtn.querySelector('i').classList.add('far');
					}
					
					// Обновляем счетчики
					likeCount.textContent = likes;
					dislikeCount.textContent = dislikes;

					try {
						// Получаем информацию о группе
						const groupRef = ref(db, `groups/${groupId}`);
						const groupSnapshot = await get(groupRef);
						
						if (groupSnapshot.exists()) {
							const groupData = groupSnapshot.val();
							const groupCreatorId = groupData.creatorId;
							
							if (groupCreatorId && votes[groupCreatorId] === 1) {
								// Проверяем, существует ли уже индикатор лайка создателя группы
								const existingAuthorLike = authorLikeContainer.querySelector('.author-like');
								if (!existingAuthorLike) {
									// Получаем данные создателя группы
									const creatorRef = ref(db, `users/${groupCreatorId}`);
									const creatorSnapshot = await get(creatorRef);
									const creatorData = creatorSnapshot.val();

									if (creatorData && authorLikeContainer) {
										authorLikeContainer.innerHTML = `
											<span class="author-like">
												<i class="fas fa-heart"></i>
												<img src="${creatorData.photoURL || 'https://ui-avatars.com/api/?name=User&background=random'}" 
													 alt="Создатель группы" 
													 class="author-like-avatar"
													 title="Понравилось создателю группы">
											</span>
										`;
									}
								}
							} else if (authorLikeContainer) {
								// Удаляем индикатор, только если он существует
								const existingAuthorLike = authorLikeContainer.querySelector('.author-like');
								if (existingAuthorLike) {
									authorLikeContainer.innerHTML = '';
								}
							}
						}
					} catch (error) {
						console.error('Ошибка при проверке лайка создателя:', error);
					}
				}
			});
		}

		// Класс для управления загрузкой изображений
		class ImageUploadManager {
			constructor(formElement, formType, commentId = null) {
				this.formElement = formElement;
				this.formType = formType; // 'comment' или 'reply'
				this.commentId = commentId;
				this.uploadedImages = [];
				this.maxImages = 10;
				
				// Находим элементы формы
				this.imageUploadButton = this.formElement.querySelector(formType === 'reply' ? `.reply-image-upload-button[data-comment-id="${commentId}"]` : '.image-upload-button');
				this.imageUploadInput = this.formElement.querySelector(formType === 'reply' ? `.reply-image-upload-input[data-comment-id="${commentId}"]` : '.image-upload-input');
				this.imageGallery = this.formElement.querySelector(formType === 'reply' ? `.reply-image-gallery[data-comment-id="${commentId}"]` : '.image-gallery');
				this.imagePreviewContainer = this.formElement.querySelector(formType === 'reply' ? `.reply-image-preview-container[data-comment-id="${commentId}"]` : '.image-preview-container');
				this.imageCounter = this.formElement.querySelector(formType === 'reply' ? `.reply-image-counter[data-comment-id="${commentId}"]` : '.image-counter');
				this.clearAllImagesButton = this.formElement.querySelector(formType === 'reply' ? `.reply-clear-all-images[data-comment-id="${commentId}"]` : '.clear-all-images');
				this.buttonsContainer = this.formElement.querySelector('.comment-form-buttons');
				
				// Инициализируем обработчики
				this.init();
			}
			
			init() {
				// Если не удалось найти элементы формы, выходим
				if (!this.imageUploadButton || !this.imageUploadInput || !this.imageGallery || !this.imagePreviewContainer) {
					console.warn('Не удалось найти элементы формы для загрузки изображений');
					return;
				}
				
				// Обработчик нажатия на кнопку загрузки изображений
				this.imageUploadButton.addEventListener('click', () => {
					this.imageUploadInput.click();
				});
				
				// Обработчик выбора файлов
				this.imageUploadInput.addEventListener('change', (e) => {
					const files = e.target.files;
					if (!files || files.length === 0) return;
					
					// Проверяем количество уже загруженных изображений
					if (this.uploadedImages.length + files.length > this.maxImages) {
						if (typeof window.showError === 'function') {
							window.showError(`Вы можете загрузить максимум ${this.maxImages} изображений`);
						} else {
							alert(`Вы можете загрузить максимум ${this.maxImages} изображений`);
						}
						return;
					}
					
					// Обрабатываем каждый выбранный файл
					Array.from(files).forEach(file => {
						// Проверяем тип файла
						if (!file.type.match('image.*') && !file.type.match('video.*')) {
							if (typeof window.showError === 'function') {
								window.showError('Пожалуйста, выберите только изображения или видео');
							} else {
								alert('Пожалуйста, выберите только изображения или видео');
							}
							return;
						}
						
						// Определяем, является ли файл видео
						const isVideo = file.type.match('video.*');
						
						// Создаем уникальный ID для этого изображения
						const imageId = 'img_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
						
						// Создаем URL для предпросмотра
						const localUrl = URL.createObjectURL(file);
						
						// Добавляем файл в массив с флагом загрузки
						this.uploadedImages.push({
							id: imageId,
							file: file,
							localUrl: localUrl,
							isUploading: true,
							uploadError: false,
							isVideo: isVideo
						});
						
						// Обновляем галерею
						this.updateImageGallery();
						
						// Загружаем изображение в Firebase
						this.uploadImageToFirebase(file, imageId);
					});
					
					// Сбрасываем input, чтобы можно было выбрать те же файлы снова
					e.target.value = '';
					
					// Показываем кнопки, если есть изображения
					if (this.buttonsContainer && this.uploadedImages.length > 0) {
						this.buttonsContainer.style.display = 'flex';
					}
				});
				
				// Обработчик нажатия на кнопку очистки всех изображений
				if (this.clearAllImagesButton) {
					this.clearAllImagesButton.addEventListener('click', () => {
						this.clearImages();
					});
				}
			}
			
			// Обновление галереи изображений
			updateImageGallery() {
				if (!this.imageGallery || !this.imagePreviewContainer || !this.imageCounter) return;
				
				// Очищаем галерею
				this.imageGallery.innerHTML = '';
				
				// Обновляем счетчик изображений
				this.imageCounter.textContent = `${this.uploadedImages.length}/${this.maxImages}`;
				this.imageCounter.style.display = this.uploadedImages.length > 0 ? 'block' : 'none';
				
				// Если есть изображения, показываем контейнер предпросмотра
				if (this.uploadedImages.length > 0) {
					this.imagePreviewContainer.style.display = 'block';
					this.imagePreviewContainer.classList.add('active');
				} else {
					this.imagePreviewContainer.style.display = 'none';
					this.imagePreviewContainer.classList.remove('active');
				}
				
				// Добавляем изображения в галерею
				this.uploadedImages.forEach((image, index) => {
					const imageElement = document.createElement('div');
					imageElement.className = 'image-preview-item';
					imageElement.dataset.index = index;
					imageElement.dataset.id = image.id;
					imageElement.draggable = true; // Делаем элемент перетаскиваемым
					
					// Добавляем класс загрузки или ошибки, если нужно
					if (image.isUploading) {
						imageElement.classList.add('uploading');
					}
					if (image.uploadError) {
						imageElement.classList.add('error');
					}
					
					// Добавляем HTML для предпросмотра
					imageElement.innerHTML = `
						${image.isVideo ? 
							`<div class="video-container">
								<video src="${image.localUrl}" preload="metadata"></video>
								<div class="video-overlay"></div>
							</div>` : 
							`<img src="${image.localUrl}" alt="Предпросмотр изображения">`
						}
						<button type="button" class="remove-image-btn" data-id="${image.id}">
							<i class="fas fa-times"></i>
						</button>
						${image.isUploading ? `<div class="upload-spinner"><i class="fas fa-spinner fa-spin"></i></div>` : ''}
						${image.uploadError ? `<div class="upload-error"><i class="fas fa-exclamation-circle"></i></div>` : ''}
					`;
					
					// Добавляем обработчик нажатия на кнопку удаления
					const removeButton = imageElement.querySelector('.remove-image-btn');
					if (removeButton) {
						removeButton.addEventListener('click', (e) => {
							e.stopPropagation();
							this.removeImage(image.id);
						});
					}
					
					// Добавляем обработчики drag and drop
					this.addDragHandlers(imageElement);
					
					// Добавляем обработчик для просмотра изображения/видео при клике
					imageElement.addEventListener('click', (e) => {
						// Не обрабатываем клик по кнопке удаления
						if (e.target.closest('.remove-image-btn')) return;
						
						// Открываем медиафайл в модальном окне
						if (image.url || image.firebaseUrl || image.localUrl) {
							window.openImageModal(image.url || image.firebaseUrl || image.localUrl, null);
						}
					});
					
					// Добавляем изображение в галерею
					this.imageGallery.appendChild(imageElement);
				});
			}
			
			// Добавление обработчиков drag and drop для элемента изображения
			addDragHandlers(imageElement) {
				// Обработчик начала перетаскивания
				imageElement.addEventListener('dragstart', (e) => {
					e.dataTransfer.setData('text/plain', imageElement.dataset.index);
					imageElement.classList.add('dragging');
					// Установка таймаута для визуального эффекта
					setTimeout(() => {
						imageElement.style.opacity = '0.5';
					}, 0);
				});
				
				// Обработчик окончания перетаскивания
				imageElement.addEventListener('dragend', () => {
					imageElement.classList.remove('dragging');
					imageElement.style.opacity = '1';
					// Убираем класс у всех элементов
					this.imageGallery.querySelectorAll('.image-preview-item').forEach(item => {
						item.classList.remove('drag-over');
					});
				});
				
				// Обработчик входа в зону перетаскивания
				imageElement.addEventListener('dragenter', (e) => {
					e.preventDefault();
					const draggingElement = this.imageGallery.querySelector('.dragging');
					if (imageElement !== draggingElement) {
						imageElement.classList.add('drag-over');
					}
				});
				
				// Обработчик нахождения над элементом
				imageElement.addEventListener('dragover', (e) => {
					e.preventDefault(); // Необходимо для разрешения drop
				});
				
				// Обработчик выхода из зоны перетаскивания
				imageElement.addEventListener('dragleave', () => {
					imageElement.classList.remove('drag-over');
				});
				
				// Обработчик сброса перетаскиваемого элемента
				imageElement.addEventListener('drop', (e) => {
					e.preventDefault();
					imageElement.classList.remove('drag-over');
					
					const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
					const toIndex = parseInt(imageElement.dataset.index);
					
					if (fromIndex !== toIndex) {
						// Перемещаем элемент в массиве
						const movedImage = this.uploadedImages.splice(fromIndex, 1)[0];
						this.uploadedImages.splice(toIndex, 0, movedImage);
						
						// Обновляем галерею
						this.updateImageGallery();
					}
				});
			}
			
			// Загрузка изображения в Firebase
			uploadImageToFirebase(file, imageId) {
				const currentUser = auth.currentUser;
				if (!currentUser) {
					console.error('Пользователь не авторизован');
					return;
				}
				
				// Создаем ссылку на файл в Firebase Storage
				const storage = getStorage();
				// Определяем папку в зависимости от типа файла
				const folder = file.type.startsWith('video/') ? 'comment_videos' : 'comment_images';
				const mediaStorageRef = storageRef(storage, `${folder}/${currentUser.uid}/${Date.now()}_${file.name}`);
				
				// Загружаем файл
				const uploadTask = uploadBytesResumable(mediaStorageRef, file);
				
				// Слушаем события загрузки
				uploadTask.on('state_changed',
					(snapshot) => {
						// Прогресс загрузки
						const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
						console.log('Upload is ' + progress + '% done');
					},
					(error) => {
						// Ошибка загрузки
						console.error('Error uploading image to Firebase:', error);
						
						// Помечаем изображение как неудачно загруженное
						const imgIndex = this.uploadedImages.findIndex(img => img.id === imageId);
						if (imgIndex !== -1) {
							this.uploadedImages[imgIndex].isUploading = false;
							this.uploadedImages[imgIndex].uploadError = true;
							this.updateImageGallery();
						}
					},
					() => {
						// Загрузка успешно завершена
						getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {
							console.log('File available at', downloadURL);
							
							// Обновляем данные изображения
							const imgIndex = this.uploadedImages.findIndex(img => img.id === imageId);
							if (imgIndex !== -1) {
								this.uploadedImages[imgIndex].isUploading = false;
								this.uploadedImages[imgIndex].firebaseUrl = downloadURL;
								this.uploadedImages[imgIndex].url = downloadURL;
								this.updateImageGallery();
							}
						});
					}
				);
			}
			
			// Удаление изображения
			removeImage(imageId) {
				// Находим индекс изображения в массиве
				const imgIndex = this.uploadedImages.findIndex(img => img.id === imageId);
				if (imgIndex !== -1) {
					// Удаляем URL объекта
					URL.revokeObjectURL(this.uploadedImages[imgIndex].localUrl);
					
					// Удаляем изображение из массива
					this.uploadedImages.splice(imgIndex, 1);
					
					// Обновляем галерею
					this.updateImageGallery();
					
					// Скрываем кнопки, если нет ни текста, ни изображений
					if (this.buttonsContainer && this.uploadedImages.length === 0) {
						const textarea = this.formElement.querySelector(this.formType === 'reply' ? '.reply-input' : '.comment-input');
						if (textarea && !textarea.value.trim()) {
							this.buttonsContainer.style.display = 'none';
						}
					}
				}
			}
			
			// Очистка всех изображений
			clearImages() {
				// Удаляем URL объектов
				this.uploadedImages.forEach(img => {
					URL.revokeObjectURL(img.localUrl);
				});
				
				// Очищаем массив
				this.uploadedImages = [];
				
				// Обновляем галерею
				this.updateImageGallery();
				
				// Скрываем кнопки, если нет ни текста, ни изображений
				if (this.buttonsContainer) {
					const textarea = this.formElement.querySelector(this.formType === 'reply' ? '.reply-input' : '.comment-input');
					if (textarea && !textarea.value.trim()) {
						this.buttonsContainer.style.display = 'none';
					}
				}
			}
			
			// Получение URL загруженных изображений
			getUploadedImagesUrls() {
				// Возвращаем массив URL успешно загруженных изображений
				return this.uploadedImages
					.filter(img => !img.isUploading && !img.uploadError && img.firebaseUrl)
					.map(img => img.firebaseUrl);
			}
			
			// Проверка наличия загруженных изображений
			hasImages() {
				return this.uploadedImages.length > 0;
			}
		}

		// Функция для создания поста с поддержкой множественных изображений
		async function createGroupPost(postOptions) {
			const { content, authorId, groupId, imageUrls = [], publishAsGroup = false, showAuthor = true, isPending = false } = postOptions;
			const auth = getAuth();
			const user = auth.currentUser;
			
			if (!user) {
				throw new Error('Пользователь не авторизован');
			}
			
			try {
				// Создаем объект с данными поста
				const postData = {
					content,
					authorId,
					timestamp: Date.now(),
					createdAt: serverTimestamp()
				};
				
				// Если пост публикуется от имени группы, добавляем соответствующий флаг
				if (publishAsGroup) {
					postData.publishedAsGroup = true;
				}
				
				// Добавляем флаг отображения автора
				postData.showAuthor = showAuthor;
				
				// Если есть изображения, добавляем их URLs в объект поста
				if (imageUrls && imageUrls.length > 0) {
					postData.imageUrls = imageUrls;
				}
				
				// Определяем, куда будет сохранен пост (опубликованные или предложенные)
				const postsRef = !isPending 
					? ref(db, `groupPosts/${groupId}`) 
					: ref(db, `proposedGroupPosts/${groupId}`);
				
				// Создаем новый пост
				const newPostRef = push(postsRef);
				await set(newPostRef, postData);
				
				console.log(`Пост ${isPending ? 'предложен' : 'опубликован'} успешно`);
				return newPostRef.key;
				
			} catch (error) {
				console.error('Ошибка при создании поста:', error);
				throw error;
			}
		}
	</script>

	<script>
		// Импортируем функции показа сообщений, если они еще не определены
		if (typeof window.showSuccess !== 'function' || 
			typeof window.showError !== 'function' || 
			typeof window.showMessage !== 'function') {
			
			// Функции для показа всплывающих сообщений
			const showMessage = (type, message, duration = 5000) => {
				document.querySelectorAll('.error-message, .success-message').forEach(el => el.remove());
				const messageBox = document.createElement('div');
				messageBox.className = `${type}-message`;
				messageBox.innerHTML = `
				<svg viewBox="0 0 24 24" style="height:20px;margin-right:8px;">
					${type === 'error'
						? `<path fill="white"
							d="M11 15h2v2h-2zm0-8h2v6h-2zm1-5C6.47
							2 2 6.5 2 12a10 10 0 0 0 10
							10a10 10 0 0 0 10-10A10 10
							0 0 0 12 2m0 18a8 8 0 0
							1-8-8a8 8 0 0 1 8-8a8 8
							0 0 1 8 8a8 8 0 0 1-8 8"/>`
						: `<path fill="white"
							d="M12 2C6.5 2 2 6.5 2 12s4.5
							10 10 10 10-4.5 10-10S17.5
							2 12 2m-2 15l-5-5 1.41-1.41L10
							14.17l7.59-7.59L19 8l-9 9z"/>`
					}
				</svg>
				${message}
				`;
				document.body.appendChild(messageBox);

				setTimeout(() => {
					messageBox.classList.add('message-exit');
					messageBox.addEventListener('animationend', () => messageBox.remove());
				}, duration);
			};

			const showError = (msg, dur) => showMessage('error', msg, dur);
			const showSuccess = (msg, dur) => showMessage('success', msg, dur);

			// Делаем функции доступными глобально
			window.showMessage = showMessage;
			window.showError = showError;
			window.showSuccess = showSuccess;
		}
	</script>
	
	<style>
		/* Стили для видео в группах, взятые из profile.html */
		/* Стили для видео в комментариях */
		.comment-video {
			cursor: pointer;
			position: relative;
			display: inline-block;
			margin: 5px 0;
			border-radius: 8px;
			overflow: hidden;
			max-width: 100%;
			width: 100%;
			max-width: 250px;
		}

		.comment-video video {
			max-width: 100%;
			max-height: 300px;
			border-radius: 8px;
			display: block;
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		/* Обновленные стили для видео-контейнеров */
		.comment-image-item .video-container,
		.post-image-item .video-container {
			position: static;
			display: inline-block;
			width: 100%;
			height: 0;
			padding-bottom: 56.25%; /* Соотношение сторон 16:9 */
			overflow: hidden;
		}
		
		.comment-image-item .video-container video,
		.post-image-item .video-container video {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			object-fit: cover;
			z-index: 1;
		}
		
		.comment-image-item .video-overlay,
		.post-image-item .video-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: transparent;
			z-index: 10;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
		}
		
		.comment-image-item .video-overlay::before,
		.post-image-item .video-overlay::before {
			content: '';
			background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg>');
			background-repeat: no-repeat;
			background-position: center;
			background-size: 50px;
			width: 60px;
			height: 60px;
			opacity: 0.7;
			transition: opacity 0.3s;
			pointer-events: none;
		}
		
		.comment-image-item .video-overlay:hover::before,
		.post-image-item .video-overlay:hover::before {
			opacity: 1;
		}
		
		.comment-image-item .video-overlay:hover,
		.post-image-item .video-overlay:hover {
			background-color: rgba(0, 0, 0, 0.1); /* Легкое затемнение при наведении */
		}
		
		/* Скрываем элементы управления видео в галерее */
		.comment-image-item video::-webkit-media-controls,
		.comment-image-item video::-moz-media-controls,
		.comment-image-item video::-ms-media-controls,
		.post-image-item video::-webkit-media-controls,
		.post-image-item video::-moz-media-controls,
		.post-image-item video::-ms-media-controls,
		.comment-video video::-webkit-media-controls,
		.comment-video video::-moz-media-controls,
		.comment-video video::-ms-media-controls {
			display: none !important;
			opacity: 0;
			visibility: hidden;
		}
		
		/* Явно отключаем возможность управления видео через атрибут controlsList */
		.comment-image-item video,
		.post-image-item video,
		.comment-video video {
			pointer-events: none;
		}
		
		/* Для модального окна оставляем элементы управления видимыми */
		.modal-video::-webkit-media-controls {
			z-index: 20;
			position: relative;
		}
		
		/* Стили для модального видео */
		.image-modal .modal-video {
			max-width: 100%;
			max-height: 80vh;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
			background-color: #000;
		}
	</style>
</head>

<body>
	<div class="error-message" style="display: none;"></div>
	
	<div class="group-container">
		<div class="group-header">
			<!-- Здесь будет информация о группе -->
		</div>
		
		<div class="group-content">
			<div class="group-main">
				<!-- Секция постов теперь создается динамически в updatePostSection -->
				<!-- Удаляем статический контент секции постов -->
				<!--
				<div class="content-section">
					<div class="create-post-container">
						// Здесь будет кнопка создания/предложения поста в зависимости от роли пользователя //
					</div>
					
					// Для админов будут табы "Опубликованные" и "Предложенные" //
					<div class="post-tabs" style="display: none;">
						<button class="post-tab active" id="published-posts-tab" data-tab="published-posts">Опубликованные</button>
						<button class="post-tab" id="pending-posts-tab" data-tab="pending-posts">Предложенные</button>
					</div>
					
					<h2 class="section-title">Посты</h2>
					
					<div class="tab-content active" id="published-posts">
						<div class="posts-list">
							<div class="empty-state">
								<i class="fas fa-file-alt"></i>
								<p>В этой группе пока нет постов</p>
							</div>
						</div>
					</div>
					
					<div class="tab-content" id="pending-posts" style="display: none;">
						<div class="posts-list" id="pending-posts-container">
							// Здесь будут предложенные посты //
						</div>
					</div>
				</div>
				-->
			</div>
			
			<div class="group-sidebar">
				<div class="content-section">
					<h2 class="section-title">Подписчики<span class="members-count">0</span></h2>
					<div class="members-list">
						<!-- Здесь будут отображаться участники группы -->
					</div>
				</div>
			</div>
		</div>
	</div>
</body>

<!-- Модальное окно для просмотра изображений -->
<div class="image-modal" id="image-modal">
	<div class="modal-content">
		<div class="modal-image-container">
			<img src="" alt="Полный размер" class="modal-image" id="modal-image">
			<div class="image-nav-buttons">
				<button class="image-nav-button prev" id="prev-image-button" style="display: none;">
					<i class="fas fa-chevron-left"></i>
				</button>
				<button class="image-nav-button next" id="next-image-button" style="display: none;">
					<i class="fas fa-chevron-right"></i>
				</button>
			</div>
			<div class="image-counter-indicator" id="image-counter-indicator" style="display: none;">
				1 / 1
			</div>
		</div>
	</div>
	<div class="close-modal" id="close-modal">&times;</div>
</div>

<script>
	// Инициализируем переменные для управления видео
	if (!window.videoVolumes) {
		window.videoVolumes = {};
	}
	if (!window.videoPositions) {
		window.videoPositions = {};
	}

	// Загружаем сохраненные настройки громкости из localStorage
	try {
		const savedVolumes = localStorage.getItem('videoVolumes');
		if (savedVolumes) {
			window.videoVolumes = JSON.parse(savedVolumes);
		}
	} catch (e) {
		console.error('Ошибка загрузки настроек громкости:', e);
	}

	// Добавляем обработчики для модального окна изображений и видео
	document.addEventListener('DOMContentLoaded', function() {
		// Функция для проверки является ли URL видео
		function isVideoUrl(url) {
			return url.includes('.mp4') || url.includes('.webm') || url.includes('.ogg') || url.includes('.mov') || 
				   url.includes('video') || url.includes('comment_videos');
		}

		// Функция для открытия модального окна с медиафайлом
		window.openImageModal = function(mediaUrl, parentElement, imageIndex = 0) {
			const modal = document.getElementById('image-modal');
			const modalImage = document.getElementById('modal-image');
			const modalContent = document.querySelector('.modal-image-container');
			const prevButton = document.getElementById('prev-image-button');
			const nextButton = document.getElementById('next-image-button');
			const counterIndicator = document.getElementById('image-counter-indicator');
			
			// Очищаем предыдущее содержимое
			const existingVideo = modalContent.querySelector('video');
			if (existingVideo) {
				existingVideo.pause();
				existingVideo.remove();
			}
			
			// Показываем по умолчанию изображение
			modalImage.style.display = 'block';
			
			// Скрываем навигационные кнопки и индикатор по умолчанию
			prevButton.style.display = 'none';
			nextButton.style.display = 'none';
			counterIndicator.style.display = 'none';
			
			// Получаем все медиафайлы (изображения и видео) из родительского элемента
			let mediaUrls = [];
			let mediaTypes = []; // Массив типов медиа (изображение или видео)
			let currentIndex = 0;
			
			// Находим все медиафайлы в родительском контейнере
			function collectImages() {
				// Проверяем, есть ли родительский элемент
				if (!parentElement || typeof parentElement !== 'object' || !(parentElement instanceof Element)) {
					// Если parentElement не DOM-элемент, а строка (ID комментария или поста), 
					// попробуем найти этот элемент
					if (typeof parentElement === 'string') {
						// Сначала ищем как элемент комментария
						const commentElement = document.querySelector(`.comment[data-comment-id="${parentElement}"], .comment-item[data-comment-id="${parentElement}"]`);
						if (commentElement) {
							// Нашли комментарий, собираем из него изображения и видео
							const imgElements = commentElement.querySelectorAll('.comment-image-item img, .comment-image');
							const videoElements = commentElement.querySelectorAll('.comment-image-item video, .comment-video video');
							
							// Добавляем изображения
							Array.from(imgElements).forEach(img => {
								mediaUrls.push(img.src);
								mediaTypes.push('image');
							});
							
							// Добавляем видео
							Array.from(videoElements).forEach(video => {
								mediaUrls.push(video.src);
								mediaTypes.push('video');
							});
							
							// Если нашли медиафайлы, выходим
							if (mediaUrls.length > 0) {
								currentIndex = Math.min(imageIndex, mediaUrls.length - 1);
								return;
							}
						}
						
						// Затем ищем как элемент поста
						const postElement = document.querySelector(`.post-item[data-post-id="${parentElement}"]`);
						if (postElement) {
							// Нашли пост, собираем из него изображения и видео
							const imgElements = postElement.querySelectorAll('.post-image-item img, .post-image');
							const videoElements = postElement.querySelectorAll('.post-image-item video, .post-video video');
							
							// Добавляем изображения
							Array.from(imgElements).forEach(img => {
								mediaUrls.push(img.src);
								mediaTypes.push('image');
							});
							
							// Добавляем видео
							Array.from(videoElements).forEach(video => {
								mediaUrls.push(video.src);
								mediaTypes.push('video');
							});
							
							// Если нашли медиафайлы, выходим
							if (mediaUrls.length > 0) {
								currentIndex = Math.min(imageIndex, mediaUrls.length - 1);
								return;
							}
						}
					}
					
					// Если не смогли найти элемент или медиафайлы, используем только переданный URL
					mediaUrls = [mediaUrl];
					mediaTypes = [isVideoUrl(mediaUrl) ? 'video' : 'image'];
					return;
				}
				
				// Определяем, является ли родитель комментарием или постом
				const isComment = parentElement.closest('.comment-item, .comment');
				const isPost = parentElement.closest('.post-item');
				
				if (isComment) {
					// Для комментария ищем все изображения и видео
					const commentElement = isComment;
					const imgElements = commentElement.querySelectorAll('.comment-image-item img, .comment-image');
					const videoElements = commentElement.querySelectorAll('.comment-image-item video, .comment-video video');
					
					// Добавляем изображения
					Array.from(imgElements).forEach(img => {
						mediaUrls.push(img.src);
						mediaTypes.push('image');
					});
					
					// Добавляем видео
					Array.from(videoElements).forEach(video => {
						mediaUrls.push(video.src);
						mediaTypes.push('video');
					});
				} else if (isPost) {
					// Для поста ищем все изображения и видео
					const postElement = isPost;
					const imgElements = postElement.querySelectorAll('.post-image-item img, .post-image');
					const videoElements = postElement.querySelectorAll('.post-image-item video, .post-video video');
					
					// Добавляем изображения
					Array.from(imgElements).forEach(img => {
						mediaUrls.push(img.src);
						mediaTypes.push('image');
					});
					
					// Добавляем видео
					Array.from(videoElements).forEach(video => {
						mediaUrls.push(video.src);
						mediaTypes.push('video');
					});
				} else {
					// Если родительский элемент не определен, используем переданный URL
					mediaUrls = [mediaUrl];
					mediaTypes = [isVideoUrl(mediaUrl) ? 'video' : 'image'];
				}
				
				// Если нет медиафайлов, используем переданный URL
				if (mediaUrls.length === 0) {
					mediaUrls = [mediaUrl];
					mediaTypes = [isVideoUrl(mediaUrl) ? 'video' : 'image'];
				}
				
				// Устанавливаем индекс текущего медиафайла
				currentIndex = Math.min(imageIndex, mediaUrls.length - 1);
			}
			
			// Собираем изображения
			collectImages();
			
			// Функция для обновления отображения медиафайла и навигационных элементов
			function updateImageDisplay() {
				if (mediaUrls.length === 0) return;
				
				const currentUrl = mediaUrls[currentIndex];
				const isVideo = mediaTypes[currentIndex] === 'video' || isVideoUrl(currentUrl);
				
				// Очищаем предыдущее содержимое
				const existingVideo = modalContent.querySelector('video');
				if (existingVideo) {
					existingVideo.pause();
					existingVideo.remove();
				}
				
				if (isVideo) {
					// Если это видео, создаем видеоэлемент
					modalImage.style.display = 'none';
					
					const videoElement = document.createElement('video');
					videoElement.src = currentUrl;
					videoElement.controls = true;
					videoElement.autoplay = true;
					videoElement.className = 'modal-video';
					
					// Устанавливаем громкость: 50% по умолчанию или сохраненное значение
					if (window.videoVolumes[currentUrl] !== undefined) {
						videoElement.volume = window.videoVolumes[currentUrl];
					} else {
						videoElement.volume = 0.5; // 50% по умолчанию для нового видео
					}
					
					// Проверяем, есть ли сохраненная позиция для этого видео
					if (window.videoPositions[currentUrl]) {
						videoElement.currentTime = window.videoPositions[currentUrl];
					}
					
					// Сохраняем изменения громкости
					videoElement.addEventListener('volumechange', function() {
						window.videoVolumes[currentUrl] = videoElement.volume;
						
						// Сохраняем в localStorage для использования между сессиями
						try {
							localStorage.setItem('videoVolumes', JSON.stringify(window.videoVolumes));
						} catch (e) {
							console.error('Ошибка сохранения настроек громкости:', e);
						}
					});
					
					// Добавляем видео в контейнер
					modalContent.insertBefore(videoElement, modalImage);
					
					// Сохраняем позицию видео при закрытии
					const handleVideoClose = () => {
						window.videoPositions[currentUrl] = videoElement.currentTime;
						videoElement.pause();
					};
					
					// Добавляем обработчик закрытия для видео
					const closeBtn = document.getElementById('close-modal');
					if (closeBtn) {
						closeBtn.addEventListener('click', handleVideoClose, { once: true });
					}
					
					// Добавляем обработчик клавиши Escape
					const handleEscKey = (e) => {
						if (e.key === 'Escape') {
							handleVideoClose();
							document.removeEventListener('keydown', handleEscKey);
						}
					};
					document.addEventListener('keydown', handleEscKey);
				} else {
					// Для изображения используем стандартный процесс
					modalImage.style.display = 'block';
					modalImage.style.opacity = '0.3';
					
					// Предзагружаем изображение
					const newImg = new Image();
					newImg.onload = function() {
						// Обновляем изображение после загрузки
						modalImage.src = currentUrl;
						modalImage.style.opacity = '1';
					};
					newImg.onerror = function() {
						// В случае ошибки загрузки также обновляем, но показываем что-то для индикации ошибки
						modalImage.src = currentUrl;
						modalImage.style.opacity = '1';
					};
					newImg.src = currentUrl;
					
					// Если изображение уже в кэше и загружено мгновенно, применяем изменения сразу
					if (newImg.complete) {
						modalImage.src = currentUrl;
						modalImage.style.opacity = '1';
					}
				}
				
				// Обновляем навигационные кнопки в зависимости от индекса
				if (mediaUrls.length > 1) {
					// Показываем/скрываем кнопки в зависимости от индекса
					prevButton.style.display = currentIndex > 0 ? 'flex' : 'none';
					nextButton.style.display = currentIndex < mediaUrls.length - 1 ? 'flex' : 'none';
					
					// Обновляем индикатор
					counterIndicator.textContent = `${currentIndex + 1} / ${mediaUrls.length}`;
					counterIndicator.style.display = 'block';
				} else {
					// Если только один медиафайл - скрываем все кнопки и индикатор
					prevButton.style.display = 'none';
					nextButton.style.display = 'none';
					counterIndicator.style.display = 'none';
				}
			}
			
			// Обработчики для кнопок навигации - добавляем блокировку кнопок на время загрузки
			prevButton.onclick = function() {
				if (currentIndex > 0) {
					// Временно блокируем кнопки, чтобы предотвратить многократные быстрые нажатия
					prevButton.disabled = true;
					nextButton.disabled = true;
					
					// Если текущий элемент - видео, сохраняем его позицию
					const currentUrl = mediaUrls[currentIndex];
					if (mediaTypes[currentIndex] === 'video' || isVideoUrl(currentUrl)) {
						const videoElement = modalContent.querySelector('video');
						if (videoElement) {
							window.videoPositions[currentUrl] = videoElement.currentTime;
							videoElement.pause();
						}
					}
					
					currentIndex--;
					updateImageDisplay();
					
					// Разблокируем кнопки после короткой задержки
					setTimeout(() => {
						prevButton.disabled = false;
						nextButton.disabled = false;
					}, 300);
				}
			};
			
			nextButton.onclick = function() {
				if (currentIndex < mediaUrls.length - 1) {
					// Временно блокируем кнопки, чтобы предотвратить многократные быстрые нажатия
					prevButton.disabled = true;
					nextButton.disabled = true;
					
					// Если текущий элемент - видео, сохраняем его позицию
					const currentUrl = mediaUrls[currentIndex];
					if (mediaTypes[currentIndex] === 'video' || isVideoUrl(currentUrl)) {
						const videoElement = modalContent.querySelector('video');
						if (videoElement) {
							window.videoPositions[currentUrl] = videoElement.currentTime;
							videoElement.pause();
						}
					}
					
					currentIndex++;
					updateImageDisplay();
					
					// Разблокируем кнопки после короткой задержки
					setTimeout(() => {
						prevButton.disabled = false;
						nextButton.disabled = false;
					}, 300);
				}
			};
			
			// Предзагрузка изображения для плавного отображения
			modal.classList.add('active');
			
			// Блокируем прокрутку страницы
			document.body.style.overflow = 'hidden';
			
			// Применяем эффект загрузки
			modalImage.style.opacity = '0.3';
			
			// Обновляем навигационные элементы сразу
			updateImageDisplay();
			
			// Предзагружаем начальное изображение
			const img = new Image();
			img.onload = function() {
				// Показываем изображение плавно после загрузки
				modalImage.style.opacity = '1';
			};
			img.src = mediaUrls[currentIndex];
		};
		
		// Функция для закрытия модального окна
		window.closeImageModal = function() {
			const modal = document.getElementById('image-modal');
			modal.classList.remove('active');
			
			// Разблокируем прокрутку страницы
			document.body.style.overflow = '';
		};
		
		// Добавляем обработчик для модального окна просмотра изображений
		
		// Обработчик для кнопки закрытия
		const closeModalBtn = document.getElementById('close-modal');
		if (closeModalBtn) {
			closeModalBtn.addEventListener('click', window.closeImageModal);
		}
		
		// Обработчик клика на затемненной области модального окна
		const imageModal = document.getElementById('image-modal');
		if (imageModal) {
			imageModal.addEventListener('click', function(event) {
				// Проверяем, что клик был именно на затемненной области, а не на содержимом
				if (event.target === this) {
					// Закрытие при клике на затемненной области отключено
					// window.closeImageModal();
				}
			});
		}
		
		// Обработчик нажатия клавиши Escape для закрытия модального окна
		document.addEventListener('keydown', function(event) {
			if (event.key === 'Escape') {
				window.closeImageModal();
			}
		});
		
		// Добавляем обработчики клика для всех изображений в постах
		function addClickHandlersToImages() {
			// Обработчики для изображений в постах
			document.querySelectorAll('.post-image-item img, .post-image').forEach(function(img) {
				img.addEventListener('click', function() {
					const postElement = this.closest('.post-item');
					// Находим все изображения в этом посте
					const allPostImages = postElement.querySelectorAll('.post-image-item img, .post-image');
					// Определяем индекс текущего изображения в коллекции
					const currentIndex = Array.from(allPostImages).indexOf(this);
					window.openImageModal(this.src, postElement, currentIndex);
				});
			});
			
			// Обработчики для изображений в комментариях
			document.querySelectorAll('.comment-image-item img, .comment-image').forEach(function(img) {
				img.addEventListener('click', function() {
					const commentElement = this.closest('.comment-item, .comment');
					// Находим все изображения в этом комментарии
					const allCommentImages = commentElement.querySelectorAll('.comment-image-item img, .comment-image');
					// Определяем индекс текущего изображения в коллекции
					const currentIndex = Array.from(allCommentImages).indexOf(this);
					window.openImageModal(this.src, commentElement, currentIndex);
				});
			});
		}
		
		// Изначально добавляем обработчики
		addClickHandlersToImages();
		
		// Наблюдаем за добавлением новых элементов на страницу
		const observer = new MutationObserver(function(mutations) {
			mutations.forEach(function(mutation) {
				if (mutation.addedNodes.length) {
					mutation.addedNodes.forEach(function(node) {
						if (node.nodeType === Node.ELEMENT_NODE) {
							// Если добавлен новый элемент, проверяем, содержит ли он изображения
							const images = node.querySelectorAll('.post-image-item img, .post-image, .comment-image-item img, .comment-image');
							images.forEach(function(img) {
								img.addEventListener('click', function() {
									const parentElement = this.closest('.post-item, .comment-item, .comment');
									
									// Определяем, является ли родитель постом или комментарием
									const isPost = parentElement.classList.contains('post-item');
									const imageSelector = isPost ? '.post-image-item img, .post-image' : '.comment-image-item img, .comment-image';
									
									// Находим все изображения в родителе
									const allImages = parentElement.querySelectorAll(imageSelector);
									// Определяем индекс текущего изображения
									const currentIndex = Array.from(allImages).indexOf(this);
									
									window.openImageModal(this.src, parentElement, currentIndex);
								});
							});
						}
					});
				}
			});
		});
		
		// Запускаем наблюдение за всем содержимым страницы
		observer.observe(document.body, { childList: true, subtree: true });
	});
</script>

</html>

