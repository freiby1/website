<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<title>Просмотр теста</title>
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet" />
	<link rel="stylesheet" href="styles.css">
	<link rel="preload" href="./sidebar.js" as="script" crossorigin="anonymous">

	<style>
		/* Скрываем кнопки до полной загрузки теста */
		.test-actions .start-test-btn,
		.test-actions #start-cooperative-btn,
		.test-actions #join-cooperative-btn {
			display: none;
		}

		.test-header {
			position: relative;
			border-radius: 12px;
			overflow: hidden;
			margin-bottom: 30px;
		}

		/* Стили для улучшенного блока с метаданными теста */
		.test-meta {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
			gap: 15px;
			margin-top: 15px;
			padding-top: 15px;
			border-top: 1px solid rgba(0, 0, 0, 0.1);
		}

		.test-meta span {
			display: flex;
			align-items: center;
			gap: 8px;
			font-size: 14px;
			color: var(--text-secondary);
		}

		.author-info {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.author-avatar {
			width: 32px;
			height: 32px;
			border-radius: 50%;
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.author-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.dark-mode .test-meta {
			border-top-color: rgba(255, 255, 255, 0.1);
		}

		.meta-item {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.meta-item-label {
			font-size: 12px;
			color: var(--text-secondary);
			opacity: 0.8;
		}

		.meta-item-value {
			display: flex;
			align-items: center;
			gap: 5px;
			font-weight: 500;
		}

		.test-cover {
			width: 100%;
			height: 100%;
			background-color: #e9e9e9;
			display: flex;
			align-items: center;
			justify-content: center;
			position: relative;
		}

		.test-cover img {
			width: 100%;
			height: 100%;
		}

		.test-info {
			padding: 25px;
			background-color: var(--card-background);
			position: relative;
			z-index: 2;
		}

		.test-title {
			margin: 0 0 15px 0;
			font-size: 28px;
			font-weight: 700;
			color: var(--text-color);
		}

		.test-description {
			margin: 0 0 20px 0;
			font-size: 16px;
			line-height: 1.5;
			color: rgba(33, 33, 33, 0.7);
		}

		.test-actions {
			display: flex;
			margin-top: 20px;
			gap: 10px;
			flex-wrap: wrap;
			/* Добавляем перенос кнопок */
		}

		.start-test-btn,
		.edit-test-btn,
		.stats-test-btn {
			flex: 1;
			min-width: 150px;
			/* Минимальная ширина кнопки */
			padding: 14px 20px;
			margin-bottom: 10px;
			/* Отступ между строками кнопок */
			font-size: clamp(14px, 3vw, 16px);
			/* Адаптивный размер шрифта */
			background-color: var(--primary-color);
			color: white;
			border: none;
			border-radius: 8px;
			font-weight: 600;
			cursor: pointer;
			transition: background-color 0.3s, transform 0.2s;
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
		}

		.start-test-btn:hover,
		.edit-test-btn:hover,
		.stats-test-btn:hover {
			background-color: #1976D2;
			transform: translateY(-2px);
		}

		/* Добавляем отдельные стили для кнопок редактирования и статистики */
		.edit-test-btn,
		.stats-test-btn {
			background-color: var(--card-background);
			color: var(--text-color);
			border: 1px solid var(--primary-color);
		}

		.edit-test-btn:hover,
		.stats-test-btn:hover {
			background-color: var(--primary-color);
			color: white;
		}

		.edit-test-btn i,
		.stats-test-btn i {
			color: var(--primary-color);
		}

		.edit-test-btn:hover i,
		.stats-test-btn:hover i {
			color: white;
		}

		.test-container {
			max-width: 800px;
			margin: 30px auto;
			padding: 0 20px;
		}

		.dark-mode .test-cover {
			background-color: #2c2c2c;
		}

		.dark-mode .test-description {
			color: rgba(236, 240, 241, 0.7);
		}

		/* Стили для прохождения теста */
		.test-taking-container {
			display: none;
		}

		.test-taking-container.active {
			display: block;
		}

		.test-question {
			background-color: var(--card-background);
			border-radius: 12px;
			padding: 25px;
			margin-bottom: 20px;
			box-shadow: var(--card-shadow);
		}

		.question-text {
			font-size: 20px;
			font-weight: 600;
			color: var(--text-color);
			margin-bottom: 20px;
		}

		.answers-list {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.answer-option {
			display: flex;
			align-items: center;
			padding: 12px 16px;
			border-radius: 8px;
			background-color: rgba(255, 255, 255, 0.5);
			cursor: pointer;
			transition: background-color 0.3s;
		}

		.answer-option:hover {
			background-color: rgba(255, 255, 255, 0.8);
		}

		.answer-option.selected {
			background-color: rgba(33, 150, 243, 0.15);
			border: 1px solid var(--primary-color);
		}

		.answer-checkbox {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 22px;
			height: 22px;
			border: 2px solid rgba(33, 33, 33, 0.3);
			border-radius: 4px;
			margin-right: 15px;
			transition: background-color 0.3s, border-color 0.3s;
			position: relative;
		}

		.answer-option.selected .answer-checkbox {
			background-color: var(--primary-color);
			border-color: var(--primary-color);
		}

		.answer-option.selected .answer-checkbox::after {
			content: '\f00c';
			font-family: 'Font Awesome 5 Free';
			font-weight: 900;
			color: white;
			font-size: 12px;
		}

		.answer-option-text {
			font-size: 16px;
			color: var(--text-color);
		}

		.navigation-buttons {
			display: flex;
			justify-content: space-between;
			margin-top: 30px;
		}

		.nav-btn {
			padding: 12px 24px;
			border: none;
			border-radius: 8px;
			font-size: 16px;
			font-weight: 600;
			cursor: pointer;
			transition: background-color 0.3s, transform 0.2s;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.prev-btn {
			background-color: #e0e0e0;
			color: #424242;
		}

		.prev-btn:hover {
			background-color: #d5d5d5;
			transform: translateY(-2px);
		}

		.next-btn,
		.submit-btn {
			background-color: var(--primary-color);
			color: white;
		}

		.next-btn:hover,
		.submit-btn:hover {
			background-color: #1976D2;
			transform: translateY(-2px);
		}

		.progress-indicator {
			margin-bottom: 25px;
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.progress-bar {
			height: 8px;
			background-color: #e0e0e0;
			border-radius: 4px;
			overflow: hidden;
		}

		.progress-bar-inner {
			height: 100%;
			background-color: var(--primary-color);
			width: 0%;
			transition: width 0.3s ease;
		}

		.progress-text {
			font-size: 14px;
			color: rgba(33, 33, 33, 0.6);
			display: flex;
			justify-content: space-between;
		}

		/* Стили для результатов теста */
		.results-container {
			display: none;
		}

		.results-container.active {
			display: block;
		}

		.results-card {
			background-color: var(--card-background);
			border-radius: 12px;
			padding: 30px;
			box-shadow: var(--card-shadow);
			text-align: center;
		}

		.results-header {
			margin-bottom: 20px;
		}

		.results-title {
			font-size: 28px;
			font-weight: 700;
			color: var(--text-color);
			margin-bottom: 5px;
		}

		.results-subtitle {
			font-size: 16px;
			color: rgba(33, 33, 33, 0.7);
		}

		.score-container {
			display: flex;
			justify-content: center;
			align-items: center;
			margin: 30px 0;
		}

		.score-circle {
			width: 150px;
			height: 150px;
			border-radius: 50%;
			border: 10px solid var(--primary-color);
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			color: var(--text-color);
		}

		.score-value {
			font-size: 36px;
			font-weight: 700;
			line-height: 1;
		}

		.score-text {
			font-size: 14px;
			margin-top: 5px;
		}

		.results-actions {
			display: flex;
			justify-content: center;
			gap: 15px;
			margin-top: 30px;
		}

		.dark-mode .answer-option {
			background-color: rgba(48, 48, 48, 0.7);
		}

		.dark-mode .answer-option:hover {
			background-color: rgba(48, 48, 48, 0.9);
		}

		.dark-mode .answer-checkbox {
			border-color: rgba(236, 240, 241, 0.3);
		}

		.dark-mode .prev-btn {
			background-color: #424242;
			color: #e0e0e0;
		}

		.dark-mode .prev-btn:hover {
			background-color: #525252;
		}

		.dark-mode .progress-bar {
			background-color: #3a3a3a;
		}

		.dark-mode .progress-text {
			color: rgba(236, 240, 241, 0.6);
		}

		.dark-mode .results-subtitle {
			color: rgba(236, 240, 241, 0.7);
		}

		/* Стили для совместного прохождения */
		.cooperative-mode-badge {
			display: inline-flex;
			align-items: center;
			gap: 5px;
			background-color: rgba(33, 150, 243, 0.1);
			color: var(--primary-color);
			padding: 5px 10px;
			border-radius: 10px;
			font-size: 14px;
			font-weight: 500;
			margin-bottom: 15px;
		}

		.cooperative-mode-badge i {
			color: var(--primary-color);
		}

		.dark-mode .cooperative-mode-badge {
			color: white;
		}

		.dark-mode .cooperative-mode-badge i {
			color: var(--primary-color);
		}

		.cooperative-lobby {
			background-color: var(--card-background);
			border-radius: 12px;
			padding: 20px;
			margin-top: 20px;
			box-shadow: var(--card-shadow);
		}

		.cooperative-lobby-title {
			font-size: 18px;
			font-weight: 600;
			color: var(--text-color);
			margin-bottom: 15px;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.lobby-code {
			background-color: rgba(33, 150, 243, 0.1);
			color: var(--text-color);
			padding: 10px 15px;
			border-radius: 8px;
			font-family: monospace;
			font-size: 18px;
			font-weight: 600;
			display: inline-block;
			margin: 10px 0;
			min-width: 120px;
			text-align: center;
		}

		.lobby-participants {
			margin: 15px 0;
			border-top: 1px solid rgba(0, 0, 0, 0.1);
			padding-top: 15px;
		}

		.participant-item {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 12px 15px;
			margin-bottom: 8px;
			background-color: rgba(255, 255, 255, 0.5);
			border-radius: 8px;
			transition: all 0.2s;
		}

		.participant-item:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			background-color: rgba(255, 255, 255, 0.8);
		}

		.participant-avatar {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			background-color: var(--primary-color);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-weight: 500;
			overflow: hidden;
			/* Добавляем overflow: hidden для обрезки изображения по границе контейнера */
			border: 2px solid transparent;
			/* Добавляем прозрачную рамку для всех аватаров */
		}

		/* Добавляем стили для изображений внутри participant-avatar */
		.participant-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			border-radius: 50%;
		}

		.participant-name {
			font-size: 16px;
			font-weight: 500;
			color: var(--text-color);
		}

		.host-badge {
			font-size: 12px;
			color: white;
			background-color: var(--primary-color);
			padding: 2px 6px;
			border-radius: 4px;
			margin-left: 5px;
		}

		.join-test-container {
			margin-top: 20px;
		}

		.join-test-input {
			padding: 12px;
			border-radius: 8px;
			border: 1px solid rgba(0, 0, 0, 0.2);
			width: 100%;
			font-size: 16px;
			margin-bottom: 10px;
		}

		.dark-mode .cooperative-lobby {
			background-color: rgba(48, 48, 48, 0.9);
		}

		.dark-mode .lobby-participants {
			border-top-color: rgba(255, 255, 255, 0.1);
		}

		.dark-mode .join-test-input {
			background-color: rgba(48, 48, 48, 0.7);
			color: white;
			border-color: rgba(255, 255, 255, 0.2);
		}

		/* Стили для отображения ответов участников */
		.participants-answers {
			margin-top: 20px;
			border-top: 1px solid rgba(0, 0, 0, 0.1);
			padding-top: 15px;
		}

		.participants-answers h3 {
			margin-bottom: 12px;
			font-size: 18px;
			font-weight: 600;
			color: var(--text-color);
		}

		.participant-answer {
			display: flex;
			align-items: center;
			margin-bottom: 10px;
			padding: 12px;
			border-radius: 8px;
			background-color: var(--card-background);
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
		}

		.participant-avatar {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			margin-right: 10px;
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.participant-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		/* Стили для аватара участника, который вышел со страницы */
		.participant-avatar.left-page {
			opacity: 0.5;
			filter: grayscale(100%);
		}

		/* Стиль для бейджа "Вышел со страницы" */
		.left-page-badge {
			background-color: #ff5252;
			color: white;
			font-size: 12px;
			padding: 3px 8px;
			border-radius: 12px;
			margin-left: 10px;
			white-space: nowrap;
		}

		.participant-name {
			font-weight: 500;
			margin-right: auto;
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.participant-status {
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 0.85rem;
			margin-left: auto;
			white-space: nowrap;
			text-overflow: ellipsis;
			overflow: hidden;
			max-width: 150px;
		}

		.status-waiting {
			background-color: #e0e0e0;
			color: #757575;
		}

		.status-answered {
			background-color: #4a6ee0;
			color: white;
		}

		.status-answered-complete {
			background-color: #4caf50;
			color: white;
		}

		.status-left-page {
			background-color: #ff5252;
			color: white;
		}

		.status-afk {
			background-color: #ff9800;
			color: white;
		}

		.dark-mode .participants-answers {
			border-top-color: rgba(255, 255, 255, 0.1);
		}

		.dark-mode .participant-answer {
			background-color: rgba(48, 48, 48, 0.7);
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		}

		.dark-mode .participant-answer:hover {
			background-color: rgba(48, 48, 48, 0.9);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
		}

		.answer-status {
			display: inline-flex;
			align-items: center;
			gap: 5px;
			padding: 4px 8px;
			border-radius: 12px;
			font-size: 12px;
			font-weight: 500;
			margin-left: auto;
		}

		.status-waiting {
			background-color: rgba(255, 193, 7, 0.1);
			color: #ffc107;
		}

		.status-answered {
			background-color: rgba(76, 175, 80, 0.1);
			color: #4caf50;
		}

		.participant-selected-answer {
			background-color: rgba(33, 150, 243, 0.1);
			color: var(--primary-color);
			border-radius: 8px;
			padding: 6px 10px;
			margin-right: 10px;
			font-weight: 500;
		}

		.timer-container {
			text-align: center;
			margin-bottom: 15px;
			font-size: 16px;
			font-weight: 500;
		}

		.timer {
			display: inline-flex;
			align-items: center;
			gap: 5px;
			padding: 6px 12px;
			border-radius: 12px;
			background-color: rgba(33, 150, 243, 0.1);
			color: var(--primary-color);
		}

		.timer.warning {
			background-color: rgba(255, 152, 0, 0.1);
			color: #ff9800;
			animation: pulse 1s infinite;
		}

		.timer.danger {
			background-color: rgba(244, 67, 54, 0.1);
			color: #f44336;
			animation: pulse 0.5s infinite;
		}

		@keyframes pulse {
			0% {
				opacity: 1;
			}

			50% {
				opacity: 0.7;
			}

			100% {
				opacity: 1;
			}
		}

		.dark-mode .participant-answer {
			background-color: rgba(48, 48, 48, 0.7);
		}

		.dark-mode .participants-answers {
			border-top-color: rgba(255, 255, 255, 0.1);
		}

		/* Стили для рейтинга участников */
		.ranking-list {
			display: flex;
			flex-direction: column;
			gap: 10px;
			margin-top: 10px;
		}

		.ranking-item {
			display: flex;
			align-items: center;
			padding: 12px 15px;
			background-color: rgba(255, 255, 255, 0.5);
			border-radius: 8px;
			transition: transform 0.2s;
		}

		.ranking-item:hover {
			transform: translateY(-2px);
		}

		.rank-position {
			font-size: 16px;
			font-weight: 700;
			color: var(--primary-color);
			min-width: 40px;
			text-align: center;
		}

		.rank-medal {
			font-size: 20px;
			margin-right: 8px;
		}

		.rank-gold {
			color: #FFD700;
		}

		.rank-silver {
			color: #C0C0C0;
		}

		.rank-bronze {
			color: #CD7F32;
		}

		.participant-details {
			display: flex;
			align-items: center;
			flex-grow: 1;
		}

		.rank-avatar {
			width: 35px;
			height: 35px;
			border-radius: 50%;
			background-color: var(--primary-color);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-weight: 500;
			margin-right: 10px;
			overflow: hidden;
			/* Добавляем overflow: hidden для обрезки изображения */
		}

		/* Добавляем стили для изображений внутри аватаров в рейтинге */
		.rank-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			border-radius: 50%;
		}

		.rank-name {
			font-weight: 500;
			color: var(--text-color);
		}

		.rank-score {
			margin-left: auto;
			font-weight: 700;
			color: var(--primary-color);
		}

		.dark-mode .ranking-item {
			background-color: rgba(48, 48, 48, 0.7);
		}

		/* Стили для мини-аватаров участников возле вариантов ответов */
		.answer-participants {
			display: flex;
			margin-left: auto;
			margin-right: 10px;
			gap: 5px;
		}

		.participant-mini-avatar {
			width: 30px;
			height: 30px;
			border-radius: 50%;
			background-color: var(--primary-color);
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-weight: 500;
			margin-right: 5px;
			font-size: 12px;
			overflow: hidden;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			border: 2px solid white;
			transition: transform 0.2s;
		}

		.participant-mini-avatar:hover {
			transform: scale(1.2);
			z-index: 2;
		}

		.participant-mini-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			border-radius: 50%;
		}

		.participant-mini-avatar.host-avatar {
			border: 2px solid gold;
		}

		.host-avatar {
			border: 2px solid var(--primary-color);
		}

		.answer-option {
			display: flex;
			align-items: center;
			margin-bottom: 10px;
			padding: 12px 16px;
			border-radius: 8px;
			background-color: rgba(255, 255, 255, 0.5);
			cursor: pointer;
			transition: background-color 0.3s;
		}

		.answer-option .answer-checkbox {
			width: 24px;
			height: 24px;
			border-radius: 50%;
			border: 2px solid var(--primary-color);
			display: flex;
			align-items: center;
			justify-content: center;
			margin-right: 15px;
			flex-shrink: 0;
		}

		.answer-option.selected .answer-checkbox {
			background-color: var(--primary-color);
		}

		.answer-option.selected .answer-checkbox::after {
			content: "";
			width: 10px;
			height: 10px;
			background-color: white;
			border-radius: 50%;
		}

		.answer-option .answer-option-text {
			flex-grow: 1;
			font-size: 16px;
			color: var(--text-color);
		}

		.answer-option .participant-mini-avatar:nth-child(n+4) {
			margin-left: -10px;
		}

		.dark-mode .participant-mini-avatar {
			border-color: #303030;
		}

		.dark-mode .answer-option {
			background-color: rgba(48, 48, 48, 0.7);
		}

		/* Стили для правильных и неправильных ответов */
		.answer-option.correct {
			background-color: rgba(76, 175, 80, 0.2);
			border-color: #4CAF50;
		}

		.answer-option.correct .answer-checkbox {
			background-color: #4CAF50;
			border-color: #4CAF50;
		}

		.answer-option.incorrect {
			background-color: rgba(244, 67, 54, 0.2);
			border-color: #F44336;
		}

		.answer-option.incorrect .answer-checkbox {
			background-color: #F44336;
			border-color: #F44336;
		}

		/* Адаптивные стили для мобильных устройств */
		@media (max-width: 768px) {
			.test-actions {
				flex-direction: column;
			}

			.cooperative-lobby {
				padding: 15px;
			}

			/* Адаптация кнопок в лобби */
			.lobby-buttons {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				margin-top: 10px;
			}

			#copy-code-btn,
			#leave-lobby-btn {
				flex: 1;
				min-width: 140px;
				margin: 0 0 10px 0;
				font-size: 13px;
				padding: 8px 10px;
			}

			/* Адаптация для навигационных кнопок */
			.navigation-buttons {
				flex-wrap: wrap;
				gap: 10px;
			}

			.nav-btn {
				font-size: 14px;
				padding: 10px 15px;
				min-width: 120px;
			}

			.test-title {
				font-size: 24px;
			}

			.results-card {
				padding: 15px;
			}
		}

		@media (max-width: 480px) {
			.test-cover {
				height: 120px;
			}

			.question-text {
				font-size: 18px;
			}

			.answer-option-text {
				font-size: 14px;
			}
		}

		/* Стиль для аватара хоста */
		.host-avatar {
			border: 2px solid gold !important;
			box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
		}

		.dark-mode .participant-item {
			background-color: rgba(48, 48, 48, 0.7);
		}

		.dark-mode .participant-item:hover {
			background-color: rgba(48, 48, 48, 0.9);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
		}

		/* Стили для уведомлений */
		.notification {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 9999;
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 15px 20px;
			border-radius: 5px;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
			transform: translateX(100px);
			opacity: 0;
			transition: all 0.3s ease;
			max-width: 300px;
			margin-bottom: 10px;
		}

		.notification.show {
			transform: translateX(0);
			opacity: 1;
		}

		.notification-content {
			display: flex;
			align-items: center;
			font-size: 14px;
		}

		.dark-mode .notification {
			background-color: rgba(50, 50, 50, 0.9);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
		}

		/* Стили для элементов управления участниками */
		.participant-item {
			position: relative;
		}

		.participant-controls {
			position: absolute;
			right: 10px;
			top: 50%;
			transform: translateY(-50%);
			display: none;
			gap: 8px;
		}

		.participant-item:hover .participant-controls {
			display: flex;
		}

		.control-btn {
			width: 32px;
			height: 32px;
			border-radius: 50%;
			border: none;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			color: white;
			transition: background-color 0.2s;
			font-size: 14px;
		}

		.make-host-btn {
			background-color: #ffc107;
		}

		.make-host-btn:hover {
			background-color: #ffb300;
		}

		.kick-btn {
			background-color: #dc3545;
		}

		.kick-btn:hover {
			background-color: #d32f2f;
			color: white;
		}

		.error-notification {
			background-color: rgba(220, 53, 69, 0.9);
		}

		/* Стили для активных лобби */
		.active-lobbies-container {
			width: 100%;
			background-color: #f9f9f9;
			border-radius: 8px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
			margin-top: 20px;
			overflow: hidden;
			padding: 20px;
		}

		.active-lobbies-header {
			margin-bottom: 15px;
		}

		.active-lobbies-header h3 {
			margin: 0;
			font-size: 18px;
		}

		.active-lobbies-description {
			margin: 5px 0 0;
			color: #666;
			font-size: 14px;
		}

		.active-lobbies-list {
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.active-lobby-item {
			padding: 15px;
			background-color: white;
			border-radius: 8px;
			box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
			display: flex;
			align-items: center;
			justify-content: space-between;
			transition: transform 0.2s, box-shadow 0.2s;
			position: relative;
		}

		.active-lobby-item:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
		}

		/* Стили для бейджа "Вы здесь" */
		.user-in-lobby-badge {
			background-color: var(--primary-color);
			color: white;
			padding: 2px 8px;
			border-radius: 4px;
			font-size: 0.75rem;
			margin-top: 5px;
			display: inline-block;
		}

		/* Стили для отключенной кнопки лобби */
		.join-lobby-btn.disabled {
			opacity: 0.6;
			cursor: not-allowed;
			position: relative;
		}

		/* Стили для всплывающей подсказки */
		.lobby-button-tooltip {
			position: absolute;
			bottom: -30px;
			right: 0;
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 5px 10px;
			border-radius: 4px;
			font-size: 0.75rem;
			white-space: nowrap;
			z-index: 10;
			opacity: 0;
			transition: opacity 0.2s;
			pointer-events: none;
		}

		.join-lobby-btn.disabled:hover .lobby-button-tooltip {
			opacity: 1;
		}

		.active-lobby-info {
			display: flex;
			flex-direction: column;
		}

		.active-lobby-code {
			font-size: 16px;
			font-weight: bold;
			color: #444;
		}

		.active-lobby-meta {
			display: flex;
			gap: 15px;
			margin-top: 5px;
			font-size: 14px;
			color: #666;
		}

		.join-lobby-btn {
			background-color: #007bff;
			color: white;
			border: none;
			padding: 8px 15px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			transition: background-color 0.2s;
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.join-lobby-btn:hover {
			background-color: #0069d9;
		}

		.active-lobby-host-info {
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.active-lobby-host-avatar {
			width: 24px;
			height: 24px;
			border-radius: 50%;
			background-color: #ddd;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 12px;
			font-weight: bold;
			color: #666;
			overflow: hidden;
		}

		.active-lobby-host-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		/* Стили для темного режима */
		.dark-mode .active-lobbies-container {
			background-color: #2a2a2a;
		}

		.dark-mode .active-lobbies-description {
			color: #aaa;
		}

		.dark-mode .active-lobby-item {
			background-color: #333;
		}

		.dark-mode .active-lobby-code {
			color: #eee;
		}

		.dark-mode .active-lobby-meta {
			color: #bbb;
		}

		.dark-mode .multiple-choice-info {
			background-color: rgba(33, 150, 243, 0.1);
		}

		/* Стили для отображения аватарок участников рядом с ответами */
		.answer-participants {
			display: flex;
			flex-wrap: wrap;
			margin-top: 5px;
			margin-left: 10px;
			gap: 5px;
			margin-right: 30px;
			/* Оставляем место для маркеров */
		}

		.participant-mini-avatar {
			width: 28px;
			height: 28px;
			border-radius: 50%;
			overflow: hidden;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
			transition: transform 0.2s ease;
		}

		.participant-mini-avatar:hover {
			transform: scale(1.2);
			z-index: 2;
		}

		.participant-mini-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.host-avatar {
			border: 2px solid var(--primary-color);
		}

		.dark-mode .participant-mini-avatar {
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
		}

		.multiple-choice .answer-participants {
			margin-top: 8px;
		}

		/* Стили для ответов в режиме совместной работы */
		.answer-item.correct {
			background-color: rgba(38, 177, 44, 0.2);
			border-color: #4CAF50;
		}

		.answer-item.incorrect {
			background-color: rgba(255, 72, 59, 0.2);
			border-color: #F44336;
		}

		/* Маркеры для ответов */
		.answer-marker {
			position: absolute;
			right: 10px;
			top: 50%;
			transform: translateY(-50%);
			width: 24px;
			height: 24px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			color: white;
			font-size: 12px;
			z-index: 2;
		}

		.correct-marker {
			background-color: #4CAF50;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		}

		.incorrect-marker {
			background-color: #F44336;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		}

		/* Сдвигаем аватары участников, если есть маркер */
		.answer-item.correct .answer-participants,
		.answer-item.incorrect .answer-participants {
			margin-right: 32px;
		}

		/* Темная тема для правильных и неправильных ответов */
		.dark-mode .answer-item.correct {
			background-color: rgba(76, 175, 80, 0.3);
			border-color: #4CAF50;
		}

		.dark-mode .answer-item.incorrect {
			background-color: rgba(244, 67, 54, 0.3);
			border-color: #F44336;
		}

		/* Стили для отображения результатов теста */
		.correct-answers-container {
			background-color: var(--card-background);
			border-radius: 12px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			padding: 20px;
			margin: 20px 0;
			max-width: 100%;
		}

		.question-result {
			margin-bottom: 20px;
			padding: 15px;
			border-radius: 8px;
			background-color: rgba(0, 0, 0, 0.03);
			border-left: 4px solid var(--primary-color);
		}

		.dark-mode .question-result {
			background-color: rgba(255, 255, 255, 0.05);
		}

		.question-result-number {
			font-weight: bold;
			color: var(--primary-color);
			margin-bottom: 5px;
			font-size: 1.1rem;
		}

		.question-result-text {
			font-size: 1.1rem;
			margin-bottom: 15px;
			font-weight: 500;
			line-height: 1.4;
		}

		.answer-options {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		.answer-option-result {
			display: flex;
			align-items: center;
			padding: 10px;
			border-radius: 6px;
			background-color: var(--card-background);
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
			transition: all 0.2s ease;
		}

		.answer-mark {
			width: 24px;
			height: 24px;
			min-width: 24px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			margin-right: 10px;
			color: white;
			font-size: 0.8rem;
		}

		.answer-text {
			flex: 1;
			font-size: 1rem;
		}

		/* Стили для разных типов ответов */
		.user-correct {
			background-color: rgba(76, 175, 80, 0.1);
			border-left: 3px solid #4CAF50;
		}

		.user-correct .answer-mark {
			background-color: #4CAF50;
		}

		.user-incorrect {
			background-color: rgba(244, 67, 54, 0.1);
			border-left: 3px solid #F44336;
		}

		.user-incorrect .answer-mark {
			background-color: #F44336;
		}

		.correct-not-selected {
			background-color: rgba(255, 235, 59, 0.1);
			border-left: 3px solid #FFEB3B;
		}

		.correct-not-selected .answer-mark {
			background-color: #FFEB3B;
			color: #333;
		}

		.dark-mode .user-correct {
			background-color: rgba(76, 175, 80, 0.2);
		}

		.dark-mode .user-incorrect {
			background-color: rgba(244, 67, 54, 0.2);
		}

		.dark-mode .correct-not-selected {
			background-color: rgba(255, 235, 59, 0.2);
		}

		.multiple-choice-info {
			background-color: rgba(33, 150, 243, 0.1);
			padding: 8px 12px;
			border-radius: 6px;
			margin-bottom: 10px;
			font-size: 0.9rem;
			display: flex;
			align-items: center;
			gap: 8px;
			color: #4a6ee0;
		}

		.dark-mode .multiple-choice-info {
			background-color: rgba(33, 150, 243, 0.2);
		}

		.time-info {
			margin-top: 8px;
			font-size: 0.9rem;
			color: var(--text-secondary);
			display: flex;
			align-items: center;
			gap: 5px;
		}

		/* Адаптивность для мобильных устройств */
		@media (max-width: 768px) {
			.correct-answers-container {
				padding: 15px;
			}

			.question-result {
				padding: 12px;
			}

			.question-result-text {
				font-size: 1rem;
			}

			.answer-option-result {
				padding: 8px;
			}

			.answer-text {
				font-size: 0.95rem;
			}
		}

		/* Стили для сводки результатов */
		.test-summary {
			background-color: rgba(0, 0, 0, 0.03);
			border-radius: 8px;
			padding: 15px;
			margin-bottom: 25px;
			border-left: 4px solid var(--primary-color);
		}

		.dark-mode .test-summary {
			background-color: rgba(255, 255, 255, 0.05);
		}

		.test-summary-content {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
		}

		.summary-item {
			flex: 1;
			min-width: 200px;
		}

		.summary-label {
			font-weight: 500;
			color: var(--text-secondary);
			margin-bottom: 5px;
			font-size: 0.9rem;
		}

		.summary-value {
			font-size: 1.2rem;
			font-weight: 600;
			color: var(--text-primary);
		}

		/* Стили для индикаторов правильности */
		.result-indicator {
			display: inline-flex;
			width: 20px;
			height: 20px;
			border-radius: 50%;
			align-items: center;
			justify-content: center;
			font-size: 0.7rem;
			color: white;
			margin-left: 8px;
		}

		.result-indicator.correct {
			background-color: #4CAF50;
		}

		.result-indicator.incorrect {
			background-color: #F44336;
		}

		@media (max-width: 600px) {
			.summary-item {
				min-width: 100%;
			}
		}

		/* Добавляем относительное позиционирование для вариантов ответов */
		.answer-item {
			position: relative;
			overflow: visible;
			/* Чтобы маркеры не обрезались */
		}

		/* Увеличиваем правый отступ для вариантов ответов, чтобы маркеры не перекрывали текст */
		.question-content .answer-item {
			padding-right: 40px;
		}

		/* Стили для модального окна подтверждения */
		.modal-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s, visibility 0.3s;
		}

		.modal-overlay.active {
			opacity: 1;
			visibility: visible;
		}

		.modal-content {
			background-color: white;
			border-radius: 8px;
			padding: 20px;
			max-width: 400px;
			width: 100%;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
			text-align: center;
		}

		.modal-title {
			font-size: 18px;
			font-weight: bold;
			margin-bottom: 15px;
		}

		.modal-buttons {
			display: flex;
			justify-content: center;
			gap: 15px;
			margin-top: 20px;
		}

		.modal-btn {
			padding: 8px 20px;
			border-radius: 4px;
			border: none;
			cursor: pointer;
			font-weight: bold;
			transition: background-color 0.2s;
		}

		.modal-btn-yes {
			background-color: #f44336;
			color: white;
		}

		.modal-btn-no {
			background-color: #e0e0e0;
			color: #333;
		}

		.modal-btn:hover {
			opacity: 0.9;
		}

		/* Стили для модального окна в темной теме */
		.dark-mode .modal-content {
			background-color: #2c2c2c;
			color: #f0f0f0;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
		}

		.dark-mode .modal-btn-no {
			background-color: #444;
			color: #f0f0f0;
		}

		.dark-mode .modal-btn-yes {
			background-color: #c62828;
		}

		/* Стили для обратного отсчета перед началом теста */
		.countdown-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.5s;
		}

		.countdown-overlay.active {
			opacity: 1;
			visibility: visible;
		}

		.countdown-number {
			font-size: 180px;
			font-weight: bold;
			color: white;
			opacity: 0;
			transform: scale(0.5);
			transition: all 0.5s ease-out;
			text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
		}

		.countdown-number.active {
			opacity: 1;
			transform: scale(1);
		}

		.countdown-number.fade-out {
			opacity: 0;
			transform: scale(1.5);
		}

		.countdown-text {
			font-size: 80px;
			font-weight: bold;
			color: white;
			opacity: 0;
			transform: scale(0.5);
			transition: all 0.5s ease-out;
			text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
		}

		.countdown-text.active {
			opacity: 1;
			transform: scale(1);
		}

		.dark-mode .countdown-overlay {
			background-color: rgba(0, 0, 0, 0.8);
		}

		.dark-mode .countdown-number,
		.dark-mode .countdown-text {
			color: #f0f0f0;
			text-shadow: 0 0 20px rgba(200, 200, 200, 0.6);
		}

		/* Стили для статуса ВЫШЕЛ */
		.status-left {
			background-color: #d32f2f;
			color: white;
		}

		.left-avatar {
			opacity: 0.4;
			filter: grayscale(100%);
		}

		.left-badge {
			background-color: #d32f2f;
			color: white;
			padding: 1px 4px;
			font-size: 10px;
			border-radius: 2px;
			margin-left: 5px;
		}

		/* Дополнительные стили для статуса лобби */
		.active-lobby-status {
			margin-top: 5px;
			margin-bottom: 5px;
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.status-label {
			padding: 2px 8px;
			border-radius: 4px;
			font-size: 12px;
			font-weight: 600;
			color: white;
		}

		.status-label.in-progress {
			background-color: #f5a623;
		}

		.status-progress {
			font-size: 13px;
			color: #666;
		}

		.spectate-lobby-btn {
			background-color: #6c757d;
			color: white;
			border: none;
			padding: 8px 15px;
			border-radius: 4px;
			font-size: 14px;
			display: flex;
			align-items: center;
			gap: 5px;
			opacity: 0.8;
		}

		/* Стили для темного режима */
		.dark-mode .status-progress {
			color: #bbb;
		}

		.status-label.in-progress {
			background-color: #f5a623;
		}

		.status-label.active {
			background-color: #f5a623;
		}

		.status-label.loading {
			background-color: #3498db;
		}

		.status-label.waiting {
			background-color: #7f8c8d;
		}

		.status-label.finishing {
			background-color: #27ae60;
		}

		/* Стили для статуса хоста */
		.host-avatar {
			border: 2px solid #4a6ee0;
		}

		.host-badge {
			background-color: #4a6ee0;
			color: white;
			padding: 1px 4px;
			font-size: 10px;
			border-radius: 2px;
			margin-left: 5px;
		}

		/* Стили для контейнера исключенных участников */
		.kicked-participants {
			margin: 15px 0;
			border-top: 1px solid rgba(0, 0, 0, 0.1);
			padding-top: 15px;
			display: none;
			/* По умолчанию скрыт */
		}

		.kicked-participant-item {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 12px 15px;
			margin-bottom: 8px;
			background-color: rgba(255, 240, 240, 0.5);
			border-radius: 8px;
			transition: all 0.2s;
		}

		.kicked-participant-item:hover {
			transform: translateY(-2px);
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
			background-color: rgba(255, 240, 240, 0.8);
		}

		.kicked-participants-title {
			font-size: 16px;
			font-weight: 600;
			color: var(--text-color);
			margin-bottom: 10px;
			display: flex;
			align-items: center;
			gap: 8px;
		}

		.no-kicked-participants {
			color: #888;
			font-style: italic;
			padding: 10px;
		}

		.dark-mode .kicked-participant-item {
			background-color: rgba(90, 50, 50, 0.3);
		}

		.dark-mode .kicked-participant-item:hover {
			background-color: rgba(90, 50, 50, 0.5);
		}

		/* Стили для счетчика исключенных пользователей */
		.kicked-count-badge {
			display: inline-block;
			margin-bottom: 10px;
			padding: 3px 8px;
			background-color: #f5f5f5;
			border-radius: 10px;
			font-size: 12px;
			color: #666;
		}

		.dark-mode .kicked-count-badge {
			background-color: #444;
			color: #ccc;
		}

		/* Стили для кнопки разблокировки участника */
		.unban-btn {
			margin-left: auto;
			padding: 5px 10px;
			border: none;
			background-color: #4CAF50;
			color: white;
			border-radius: 4px;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.2s;
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.unban-btn:hover {
			background-color: #3e8e41;
			transform: translateY(-2px);
		}

		.dark-mode .unban-btn {
			background-color: #3e8e41;
		}

		.dark-mode .unban-btn:hover {
			background-color: #2d682f;
		}

		.left-page-badge {
			background-color: #d32f2f;
			color: white;
			padding: 2px 6px;
			border-radius: 4px;
			font-size: 12px;
			margin-left: 5px;
		}

		/* Стили для изображений в вопросах и ответах */
		.question-image {
			width: 100%;
			max-height: 300px;
			margin: 15px 0;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: var(--card-secondary-bg);
			border-radius: 8px;
			overflow: hidden;
		}

		.question-image img {
			max-width: 100%;
			max-height: 300px;
			object-fit: contain;
			border: 2px solid var(--primary-color);
			border-radius: 8px;
		}

		/* Модальное окно для увеличенного просмотра */
		.image-modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.8);
			z-index: 1000;
			justify-content: center;
			align-items: center;
		}

		.image-modal.active {
			display: flex;
		}

		.image-modal-content {
			max-width: 90%;
			max-height: 90%;
			animation: zoom-in 0.3s ease;
		}

		@keyframes zoom-in {
			from {transform: scale(0.8); opacity: 0;}
			to {transform: scale(1); opacity: 1;}
		}

		.image-modal-close {
			position: absolute;
			top: 20px;
			right: 30px;
			color: white;
			font-size: 40px;
			font-weight: bold;
			cursor: pointer;
		}

		.dark-mode .question-image img,
		.dark-mode .answer-option-image img {
			border-color: var(--primary-color);
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
		}

		.answer-content {
			display: flex;
			flex-direction: column;
			width: 100%;
		}

		.answer-option-image {
			width: 100%;
			max-height: 150px;
			margin-top: 8px;
			display: flex;
			justify-content: left;
			align-items: center;
			background-color: var(--card-secondary-bg);
			border-radius: 4px;
			overflow: hidden;
		}

		.answer-option-image img {
			max-width: 100%;
			max-height: 150px;
			object-fit: contain;
			border: 2px solid var(--primary-color);
			border-radius: 8px;
		}

		/* Обновленные стили для списка ответов, чтобы учесть изображения */
		.answers-list .answer-item {
			padding: 12px 15px;
		}

		/* Для правильных ответов после прохождения теста */
		.answer-item.correct .answer-option-image,
		.answer-item.selected.correct .answer-option-image {
			background-color: rgba(40, 167, 69, 0.1);
		}

		/* Для неправильных ответов после прохождения теста */
		.answer-item.selected.incorrect .answer-option-image {
			background-color: rgba(220, 53, 69, 0.1);
		}

		/* Стили для блока отзывов */
		.feedback-container {
			margin: 25px 0;
			padding: 20px;
			background-color: var(--card-background);
			border-radius: 12px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		}

		.feedback-title {
			font-size: 18px;
			font-weight: 600;
			margin-bottom: 15px;
			color: var(--text-color);
		}

		.rating-container,
		.comment-container {
			margin-bottom: 15px;
		}

		.rating-container p,
		.comment-container p {
			font-size: 14px;
			color: var(--text-secondary);
			margin-bottom: 5px;
		}

		.stars-container {
			display: flex;
			gap: 10px;
		}

		.star-rating {
			font-size: 24px;
			color: #ffc107;
			cursor: pointer;
			transition: transform 0.2s, color 0.2s;
		}

		.star-rating:hover {
			transform: scale(1.2);
		}

		.star-rating.selected {
			color: #ffc107;
		}

		.feedback-comment {
			width: 100%;
			min-height: 100px;
			padding: 12px;
			border-radius: 8px;
			border: 1px solid rgba(0, 0, 0, 0.1);
			background-color: var(--card-secondary-bg);
			resize: vertical;
			font-family: inherit;
			font-size: 14px;
			color: var(--text-color);
		}

		.submit-feedback-btn {
			background-color: var(--primary-color);
			color: white;
			border: none;
			border-radius: 8px;
			padding: 10px 15px;
			font-size: 14px;
			font-weight: 500;
			cursor: pointer;
			display: flex;
			align-items: center;
			gap: 8px;
			margin-top: 10px;
			transition: background-color 0.3s, transform 0.2s;
		}

		.submit-feedback-btn:hover:not(:disabled) {
			background-color: #1976D2;
			transform: translateY(-2px);
		}

		.submit-feedback-btn:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}

		.dark-mode .feedback-comment {
			background-color: rgba(48, 48, 48, 0.7);
			border-color: rgba(255, 255, 255, 0.1);
			color: #f0f0f0;
		}

		.feedback-success {
			background-color: rgba(76, 175, 80, 0.1);
			color: #4CAF50;
			padding: 10px 15px;
			border-radius: 8px;
			margin-top: 15px;
			text-align: center;
			display: none;
		}

		.dark-mode .feedback-success {
			background-color: rgba(76, 175, 80, 0.2);
		}

		/* Стили для отображения отзывов */
		.test-reviews-container {
			background-color: var(--card-background);
			border-radius: 12px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			padding: 20px;
			margin-top: 20px;
			margin-bottom: 20px;
		}

		.reviews-header {
			display: flex;
			align-items: center;
			gap: 10px;
			margin-bottom: 15px;
			font-size: 18px;
			font-weight: 600;
			color: var(--text-color);
		}

		.avg-rating-badge {
			background-color: #ffc107;
			color: #212121;
			border-radius: 15px;
			padding: 3px 8px;
			font-size: 14px;
			font-weight: bold;
			display: inline-flex;
			align-items: center;
			gap: 3px;
		}

		.reviews-list {
			display: flex;
			flex-direction: column;
			gap: 15px;
		}

		.review-item {
			border-bottom: 1px solid rgba(0, 0, 0, 0.1);
			padding-bottom: 15px;
		}

		.review-header {
			display: flex;
			justify-content: space-between;
			margin-bottom: 10px;
		}

		.reviewer-info {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.reviewer-avatar {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			overflow: hidden;
			display: flex;
			align-items: center;
			justify-content: center;
			background-color: var(--primary-color);
			color: white;
			font-weight: 500;
		}

		.reviewer-avatar img {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		.reviewer-name {
			font-weight: 500;
			color: var(--text-color);
		}

		.review-date {
			font-size: 12px;
			color: var(--text-secondary);
		}

		.review-rating {
			display: flex;
			gap: 3px;
			color: #ffc107;
		}

		.review-comment {
			margin-top: 8px;
			font-size: 14px;
			line-height: 1.5;
			color: var(--text-color);
		}

		.no-reviews {
			text-align: center;
			color: var(--text-secondary);
			padding: 20px;
			font-style: italic;
		}

		.show-more-reviews {
			background-color: transparent;
			border: 1px solid var(--primary-color);
			color: var(--primary-color);
			border-radius: 8px;
			padding: 8px 15px;
			margin-top: 15px;
			cursor: pointer;
			font-size: 14px;
			transition: all 0.2s;
			align-self: center;
		}

		.show-more-reviews:hover {
			background-color: var(--primary-color);
			color: white;
		}

		.dark-mode .test-reviews-container {
			background-color: rgba(48, 48, 48, 0.7);
		}

		.dark-mode .review-item {
			border-bottom-color: rgba(255, 255, 255, 0.1);
		}

		.dark-mode .review-date {
			color: rgba(255, 255, 255, 0.6);
		}

		.dark-mode .no-reviews {
			color: rgba(255, 255, 255, 0.6);
		}

		.review-actions {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.delete-review-btn {
			background: none;
			border: none;
			color: #f44336;
			cursor: pointer;
			font-size: 16px;
			opacity: 0.7;
			transition: all 0.2s;
			padding: 4px;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.delete-review-btn:hover {
			opacity: 1;
			transform: scale(1.1);
		}

		.dark-mode .delete-review-btn {
			color: #ff6b6b;
		}

		.feedback-message {
			background-color: rgba(33, 150, 243, 0.1);
			padding: 15px;
			border-radius: 8px;
			text-align: center;
			color: var(--text-color);
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
			font-size: 16px;
		}

		.feedback-message i {
			color: var(--primary-color);
			font-size: 20px;
		}

		.dark-mode .feedback-message {
			background-color: rgba(33, 150, 243, 0.2);
		}

		.author-reply {
			margin-top: 10px;
			margin-left: 20px;
			padding: 10px 15px;
			background-color: rgba(33, 150, 243, 0.1);
			border-left: 3px solid var(--primary-color);
			border-radius: 0 8px 8px 0;
		}

		.author-reply-header {
			display: flex;
			align-items: center;
			margin-bottom: 5px;
			font-size: 12px;
			color: var(--text-secondary);
		}

		.author-badge {
			background-color: var(--primary-color);
			color: white;
			padding: 2px 6px;
			border-radius: 4px;
			font-size: 11px;
			margin-right: 5px;
		}

		.author-reply-text {
			font-size: 14px;
			line-height: 1.4;
		}

		.reply-button {
			background-color: transparent;
			border: 1px solid var(--primary-color);
			color: var(--primary-color);
			padding: 4px 8px;
			font-size: 12px;
			border-radius: 4px;
			cursor: pointer;
			margin-top: 8px;
		}

		.reply-button:hover {
			background-color: var(--primary-color);
			color: white;
		}

		.reply-form {
			margin-top: 10px;
			display: none;
		}

		.reply-form textarea {
			width: 100%;
			padding: 8px;
			border-radius: 4px;
			border: 1px solid rgba(0, 0, 0, 0.2);
			margin-bottom: 8px;
			min-height: 80px;
			resize: vertical;
		}

		.reply-form-actions {
			display: flex;
			justify-content: flex-end;
			gap: 8px;
		}

		.dark-mode .author-reply {
			background-color: rgba(33, 150, 243, 0.2);
			border-color: var(--primary-color);
		}

		.dark-mode .reply-form textarea {
			background-color: rgba(48, 48, 48, 0.7);
			border-color: rgba(255, 255, 255, 0.2);
			color: white;
		}

		.reply-form-actions button {
			padding: 6px 12px;
			border-radius: 4px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s;
		}

		.cancel-reply-btn {
			background-color: #f5f5f5;
			border: 1px solid #ddd;
			color: #666;
		}

		.cancel-reply-btn:hover {
			background-color: #e0e0e0;
		}

		.submit-reply-btn {
			background-color: var(--primary-color);
			border: 1px solid var(--primary-color);
			color: white;
		}

		.submit-reply-btn:hover {
			background-color: #1976D2;
		}

		.dark-mode .cancel-reply-btn {
			background-color: #444;
			border-color: #555;
			color: #eee;
		}

		.dark-mode .cancel-reply-btn:hover {
			background-color: #555;
		}

		.delete-reply-btn {
			background: none;
			border: none;
			color: #f44336;
			cursor: pointer;
			font-size: 12px;
			padding: 2px 5px;
			margin-left: auto;
			opacity: 0.7;
			transition: all 0.2s;
		}

		.delete-reply-btn:hover {
			opacity: 1;
		}

		.edit-review-btn,
		.edit-reply-btn {
			background: none;
			border: none;
			color: #4a6ee0;
			cursor: pointer;
			font-size: 14px;
			opacity: 0.7;
			transition: all 0.2s;
			padding: 4px;
			margin-left: 5px;
		}

		.edit-review-btn:hover,
		.edit-reply-btn:hover {
			opacity: 1;
			transform: scale(1.1);
		}

		.edit-form {
			margin-top: 10px;
			margin-bottom: 10px;
		}

		.edit-form textarea {
			width: 100%;
			padding: 8px;
			border-radius: 4px;
			border: 1px solid rgba(0, 0, 0, 0.2);
			margin-bottom: 8px;
			min-height: 80px;
			resize: vertical;
		}

		.edit-form-actions {
			display: flex;
			justify-content: flex-end;
			gap: 8px;
		}

		.edit-form-actions button {
			padding: 6px 12px;
			border-radius: 4px;
			font-size: 13px;
			cursor: pointer;
			transition: all 0.2s;
		}

		.cancel-edit-btn,
		.cancel-edit-reply-btn {
			background-color: #f5f5f5;
			border: 1px solid #ddd;
			color: #666;
		}

		.cancel-edit-btn:hover,
		.cancel-edit-reply-btn:hover {
			background-color: #e0e0e0;
		}

		.save-edit-btn,
		.save-edit-reply-btn {
			background-color: var(--primary-color);
			border: 1px solid var(--primary-color);
			color: white;
		}

		.save-edit-btn:hover,
		.save-edit-reply-btn:hover {
			background-color: #1976D2;
		}

		.dark-mode .edit-form textarea {
			background-color: rgba(48, 48, 48, 0.7);
			border-color: rgba(255, 255, 255, 0.2);
			color: white;
		}

		.dark-mode .cancel-edit-btn,
		.dark-mode .cancel-edit-reply-btn {
			background-color: #444;
			border-color: #555;
			color: #eee;
		}

		.dark-mode .cancel-edit-btn:hover,
		.dark-mode .cancel-edit-reply-btn:hover {
			background-color: #555;
		}

		.edited-info {
			font-style: italic;
			color: var(--text-secondary);
			font-size: 0.9em;
		}
	</style>

	<!-- Добавляем синхронную инициализацию темы -->
	<script>
		(function () {
			const savedTheme = localStorage.getItem('theme');
			const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

			if (savedTheme === 'system') {
				document.documentElement.style.visibility = 'hidden';
				document.documentElement.classList.add(prefersDark ? 'dark-mode' : 'light-mode');

				document.addEventListener('DOMContentLoaded', () => {
					document.body.classList.add(prefersDark ? 'dark-mode' : 'light-mode');
					document.documentElement.classList.remove(prefersDark ? 'dark-mode' : 'light-mode');
					document.documentElement.style.visibility = 'visible';
				});
			} else {
				const theme = savedTheme || (prefersDark ? 'dark-mode' : 'light-mode');
				document.documentElement.style.visibility = 'hidden';
				document.documentElement.classList.add(theme);

				document.addEventListener('DOMContentLoaded', () => {
					document.body.classList.add(theme);
					document.documentElement.classList.remove(theme);
					document.documentElement.style.visibility = 'visible';
				});
			}

			// Добавляем слушатель изменения системной темы
			if (savedTheme === 'system') {
				window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
					document.body.classList.remove('dark-mode', 'light-mode');
					document.body.classList.add(e.matches ? 'dark-mode' : 'light-mode');
				});
			}
		})();
	</script>
</head>

<body>
	<div class="test-container">
		<!-- Информация о тесте -->
		<div id="test-info-container" class="test-info-container">
			<div class="test-header">
				<div class="test-cover" id="test-cover">
					<i class="fas fa-image" style="font-size: 48px; color: #bdbdbd;"></i>
				</div>
				<div class="test-info">
					<h1 class="test-title" id="test-title">Загрузка...</h1>
					<p class="test-description" id="test-description"></p>
					<div id="cooperative-badge" class="cooperative-mode-badge" style="display: none;">
						<i class="fas fa-users"></i>
						Совместное прохождение
					</div>
					<div id="time-limit-badge" class="cooperative-mode-badge" style="display: none;">
						<i class="fas fa-clock"></i>
						Ограничение по времени: <span id="time-limit-value">0</span> сек.
					</div>
					<div class="test-meta">
						<span><i class="fas fa-question-circle"></i> <span id="test-questions-count">0</span>вопросов</span>
						<span><i class="fas fa-user"></i> <span id="test-author">Загрузка...</span></span>
						<span><i class="fas fa-calendar-alt"></i> <span id="test-date">Загрузка...</span></span>
						<span id="test-category-badge"><i class="fas fa-globe"></i> <span id="test-category">Общее</span></span>
					</div>
					<div class="test-actions">
						<button id="start-test-btn" class="start-test-btn">
							<i class="fas fa-play"></i>
							Начать тест
						</button>
						<button id="start-cooperative-btn" class="start-test-btn" style="display: none;">
							<i class="fas fa-users"></i>
							Начать совместное прохождение
						</button>
						<button id="join-cooperative-btn" class="start-test-btn" style="display: none;">
							<i class="fas fa-sign-in-alt"></i>
							Присоединиться
						</button>
						<button id="edit-test-btn" class="edit-test-btn" style="display: none;">
							<i class="fas fa-edit"></i>
							Редактировать
						</button>
						<button id="stats-test-btn" class="stats-test-btn" style="display: none;">
							<i class="fas fa-chart-bar"></i>
							Статистика
						</button>
					</div>

					<!-- Лобби для совместного прохождения -->
					<div id="cooperative-lobby" class="cooperative-lobby" style="display: none;">
						<div class="cooperative-lobby-title">
							<i class="fas fa-users"></i> Лобби совместного прохождения
						</div>
						<p>Код для подключения:</p>
						<div class="lobby-code" id="lobby-code">XXXXXX</div>
						<div class="lobby-buttons">
							<button id="copy-code-btn" class="btn btn-secondary" style="padding: 8px 15px; font-size: 14px;">
								<i class="fas fa-copy"></i> Копировать код
							</button>

							<button id="leave-lobby-btn" class="btn btn-danger"
								style="padding: 8px 15px; font-size: 14px; margin-left: 10px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer;">
								<i class="fas fa-sign-out-alt"></i> Выйти из лобби
							</button>
						</div>

						<div class="lobby-participants">
							<h3>Участники: <span id="participants-count">0</span></h3>
							<div id="participants-list">
								<!-- Сюда будут добавляться участники -->
							</div>
						</div>

						<div class="kicked-participants" id="kicked-participants">
							<div class="kicked-participants-title">
								<i class="fas fa-ban"></i> Исключенные участники
							</div>
							<div id="kicked-participants-list" class="kicked-participants-list">
								<div class="no-kicked-participants">Нет исключенных участников</div>
							</div>
						</div>

						<div class="lobby-actions">
							<button id="start-cooperative-test-btn" class="start-test-btn" style="margin-top: 15px;">
								<i class="fas fa-play"></i> Начать тест
							</button>
						</div>
					</div>

					<!-- Форма для ввода кода и присоединения к совместному прохождению -->
					<div id="join-cooperative-container" class="join-test-container" style="display: none;">
						<p>Введите код совместного прохождения:</p>
						<input type="text" id="join-code-input" class="join-test-input" placeholder="Введите 6-значный код">
						<button id="join-by-code-btn" class="start-test-btn">
							<i class="fas fa-sign-in-alt"></i> Присоединиться
						</button>
					</div>
				</div>
			</div>

			<!-- Активные лобби для данного теста -->
			<div id="active-lobbies-container" class="active-lobbies-container" style="display: none;">
				<div class="active-lobbies-header">
					<h3>
						<i class="fas fa-door-open"></i>
						Активные лобби (<span id="active-lobbies-count">0</span>)
					</h3>
					<p class="active-lobbies-description">Вы можете присоединиться к существующему лобби</p>
				</div>
				<div id="active-lobbies-list" class="active-lobbies-list">
					<!-- Сюда будут добавляться активные лобби -->
				</div>
			</div>

			<div id="test-reviews-container" class="test-reviews-container" style="display: none;">
				<h3 class="reviews-header">
					<i class="fas fa-star"></i> Отзывы о тесте
					<span id="avg-rating-badge" class="avg-rating-badge">0.0</span>
				</h3>
				<div id="reviews-list" class="reviews-list">
					<!-- Сюда будут добавляться отзывы -->
					<div class="no-reviews">Отзывов пока нет</div>
				</div>
				<button id="show-more-reviews" class="show-more-reviews" style="display: none;">
					Показать больше отзывов
				</button>
			</div>
		</div>

		<!-- Прохождение теста -->
		<div id="test-taking-container" class="test-taking-container">
			<div class="progress-indicator">
				<div class="progress-bar">
					<div class="progress-bar-inner" id="progress-bar"></div>
				</div>
				<div class="progress-text">
					<span>Вопрос <span id="current-question-num">1</span> из <span id="total-questions">10</span></span>
					<span>Прогресс: <span id="progress-percentage">0%</span></span>
				</div>
			</div>

			<!-- Таймер для ограничения времени -->
			<div id="timer-container" class="timer-container" style="display: none;">
				<div class="timer">
					<i class="fas fa-clock"></i>
					<span id="timer-display">00:00</span>
				</div>
			</div>

			<div class="test-question" id="question-container">
				<!-- Здесь будут динамически создаваться вопросы -->
			</div>

			<!-- Блок для отображения ответов участников в совместном режиме -->
			<div id="participants-answers" class="participants-answers" style="display: none;">
				<h3>Ответы участников:</h3>
				<div id="answers-list">
					<!-- Здесь будут отображаться ответы участников -->
				</div>
			</div>

			<div class="navigation-buttons">
				<button class="nav-btn next-btn" id="next-question-btn">
					Следующий <i class="fas fa-arrow-right"></i>
				</button>
				<button class="nav-btn submit-btn" id="submit-test-btn" style="display: none">
					Завершить тест <i class="fas fa-check"></i>
				</button>
			</div>
		</div>

		<!-- Результаты теста -->
		<div id="results-container" class="results-container">
			<div class="results-card">
				<div class="results-header">
					<h2 class="results-title">Результаты теста</h2>
					<p class="results-subtitle">Тест "<span id="result-test-title">Загрузка...</span>"</p>
					<p id="lobby-close-timer" style="display: none; color: #ff5722; margin-top: 5px; font-weight: bold;">Лобби
						будет автоматически закрыто через 30 секунд...</p>
				</div>

				<div class="score-container">
					<div class="score-circle">
						<div class="score-value" id="score-value">0/0</div>
						<div class="score-text" id="score-percentage">0%</div>
					</div>
				</div>

				<!-- Добавляем рейтинг участников для совместного режима -->
				<div id="participants-ranking" style="display: none; margin: 20px 0;">
					<h3 style="margin-bottom: 15px;">Рейтинг участников</h3>
					<div id="ranking-list" class="ranking-list">
						<!-- Сюда будут добавляться участники с их местами -->
					</div>
				</div>

				<!-- Добавляем блок для отображения правильных ответов -->
				<div id="correct-answers-container" class="correct-answers-container" style="display: none;">
					<h3 style="margin-bottom: 15px;">Результаты теста</h3>
					<div id="test-summary" class="test-summary">
						<!-- Сюда будет добавлена сводка по результатам теста -->
					</div>
					<div id="correct-answers-list">
						<!-- Сюда будут добавляться вопросы и правильные ответы -->
					</div>
				</div>

				<!-- Блок для оставления отзыва -->
				<div id="feedback-container" class="feedback-container">
					<h3 class="feedback-title">Оставьте отзыв о тесте</h3>
					<div class="rating-container">
						<p>Оценка:</p>
						<div class="stars-container" id="rating-stars">
							<i class="far fa-star star-rating" data-rating="1"></i>
							<i class="far fa-star star-rating" data-rating="2"></i>
							<i class="far fa-star star-rating" data-rating="3"></i>
							<i class="far fa-star star-rating" data-rating="4"></i>
							<i class="far fa-star star-rating" data-rating="5"></i>
						</div>
					</div>
					<div class="comment-container">
						<p>Комментарий (необязательно):</p>
						<textarea id="feedback-comment" class="feedback-comment"
							placeholder="Напишите ваше мнение о тесте..."></textarea>
					</div>
					<button id="submit-feedback-btn" class="submit-feedback-btn" disabled>
						<i class="fas fa-paper-plane"></i> Отправить отзыв
					</button>
				</div>

				<div class="results-actions">
					<button class="nav-btn prev-btn" onclick="handleHomeButtonClick()">
						<i class="fas fa-home"></i> На главную
					</button>
				</div>
			</div>
		</div>
	</div>

	<!-- Модальное окно подтверждения выхода из лобби -->
	<div id="leave-confirmation-modal" class="modal-overlay">
		<div class="modal-content">
			<div class="modal-title">Подтверждение</div>
			<div class="modal-message">Вы точно хотите покинуть лобби?</div>
			<div class="modal-buttons">
				<button id="leave-confirm-yes" class="modal-btn modal-btn-yes">Да</button>
				<button id="leave-confirm-no" class="modal-btn modal-btn-no">Нет</button>
			</div>
		</div>
	</div>

	<!-- Обратный отсчет перед началом теста -->
	<div id="test-countdown-overlay" class="countdown-overlay">
		<div id="countdown-display" class="countdown-number"></div>
	</div>

	<script type="module">
		import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js';
		import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js';
		import { getDatabase, ref, get, child, push, set, onValue, update, onDisconnect, off, serverTimestamp, query, orderByChild, equalTo, limitToLast } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js';
		import { initializeSidebar } from './sidebar.js';
		import { getStorage, ref as storageRef, getDownloadURL } from 'https://www.gstatic.com/firebasejs/9.6.1/firebase-storage.js';

		// Инициализация Firebase
		const firebaseConfig = {
			apiKey: "AIzaSyAR-ui1g1VurKML1wQwZFdon_2Bgcrz-ms",
			authDomain: "tpoproject-35957.firebaseapp.com",
			databaseURL: "https://tpoproject-35957-default-rtdb.europe-west1.firebasedatabase.app",
			projectId: "tpoproject-35957",
			storageBucket: "tpoproject-35957.appspot.com",
			messagingSenderId: "683982725892",
			appId: "1:683982725892:web:4d4e07e6ea913ddff5a2f7"
		};

		const app = initializeApp(firebaseConfig);
		const auth = getAuth(app);
		const db = getDatabase(app);

		// Проверка авторизации
		onAuthStateChanged(auth, (user) => {
			if (!user) {
				window.location.href = 'index.html';
			}
		});

		let currentUser = null;
		let currentTest = null;
		let currentQuestionIndex = 0;
		let userAnswers = [];
		let questionStartTime = 0;
		let questionTimeSpent = [];

		// Переменные для совместного прохождения
		let isCooperativeMode = false;
		let isHost = false;
		let lobbyCode = null;
		let lobbyRef = null;
		let participants = {};
		let participantsAnswers = {};
		let everyoneAnswered = false;

		// Переменные для таймера
		let timeLimit = 0;
		let timerInterval = null;
		let remainingTime = 0;
		let timeExpired = false;
		let timerDisplay = null;

		// Получаем данные пользователя из localStorage
		const savedUserData = localStorage.getItem('userData');
		if (savedUserData) {
			currentUser = JSON.parse(savedUserData);
		} else {
			window.location.href = 'index.html';
		}

		// Получаем ID теста из URL
		const urlParams = new URLSearchParams(window.location.search);
		const testId = urlParams.get('id');

		if (!testId) {
			window.location.href = 'home.html';
		}

		// Элементы DOM
		const testInfoContainer = document.getElementById('test-info-container');
		const testTakingContainer = document.getElementById('test-taking-container');
		const resultsContainer = document.getElementById('results-container');

		const testTitle = document.getElementById('test-title');
		const testDescription = document.getElementById('test-description');
		const testQuestionsCount = document.getElementById('test-questions-count');
		const testAuthor = document.getElementById('test-author');
		const testDate = document.getElementById('test-date');
		const testCover = document.getElementById('test-cover');

		const startTestBtn = document.getElementById('start-test-btn');
		const nextQuestionBtn = document.getElementById('next-question-btn');
		const submitTestBtn = document.getElementById('submit-test-btn');

		const progressBar = document.getElementById('progress-bar');
		const currentQuestionNum = document.getElementById('current-question-num');
		const totalQuestions = document.getElementById('total-questions');
		const progressPercentage = document.getElementById('progress-percentage');

		const questionContainer = document.getElementById('question-container');

		const resultTestTitle = document.getElementById('result-test-title');
		const scoreValue = document.getElementById('score-value');
		const scorePercentage = document.getElementById('score-percentage');

		// Глобальная переменная для хранения массива активных уведомлений
		let activeNotifications = [];

		// Функция для отображения уведомления
		function showNotification(message, type = 'info', duration = 2000) {
			// Проверяем, не было ли уже показано такое же уведомление в течение последней секунды
			// Это поможет избежать дублирования уведомлений
			const existingNotification = activeNotifications.find(n => {
				const content = n.querySelector('.notification-content');
				if (content && content.textContent === message) {
					const timeDiff = Date.now() - (n.displayTime || 0);
					return timeDiff < 1000; // Проверяем, что уведомление было показано менее секунды назад
				}
				return false;
			});

			// Если такое уведомление уже показывается, не создаём новое
			if (existingNotification) {
				return existingNotification;
			}

			const notification = document.createElement('div');
			notification.className = type === 'error' ? 'notification error-notification' : 'notification';
			notification.innerHTML = `<div class="notification-content">${message}</div>`;
			notification.displayTime = Date.now(); // Сохраняем время отображения
			document.body.appendChild(notification);

			// Добавляем уведомление в массив активных
			activeNotifications.push(notification);

			// Обновляем позиции всех уведомлений
			updateNotificationsPosition();

			// Показываем уведомление
			setTimeout(() => {
				notification.classList.add('show');
			}, 10);

			// Скрываем через указанное время
			setTimeout(() => {
				notification.classList.remove('show');

				// Удаляем из DOM и из массива активных
				setTimeout(() => {
					notification.remove();
					activeNotifications = activeNotifications.filter(n => n !== notification);

					// Обновляем позиции оставшихся уведомлений
					updateNotificationsPosition();
				}, 300);
			}, duration);

			return notification;
		}

		// Функция для обновления позиций уведомлений
		function updateNotificationsPosition() {
			let topOffset = 20; // Начальное смещение от верха

			// Сначала сортируем уведомления по их текущей позиции сверху вниз
			const sortedNotifications = [...activeNotifications].sort((a, b) => {
				const aTop = parseInt(window.getComputedStyle(a).top) || 0;
				const bTop = parseInt(window.getComputedStyle(b).top) || 0;
				return aTop - bTop;
			});

			// Теперь обновляем позиции всех уведомлений
			sortedNotifications.forEach(notification => {
				notification.style.top = `${topOffset}px`;

				// Учитываем высоту уведомления и отступ для следующего
				const height = notification.offsetHeight;
				const marginBottom = 10; // Фиксированный отступ между уведомлениями

				// Увеличиваем смещение для следующего уведомления
				topOffset += height + marginBottom;
			});
		}

		// Загрузка данных теста
		async function loadTestData() {
			try {
				const testSnapshot = await get(ref(db, `tests/${testId}`));

				if (!testSnapshot.exists()) {
					alert('Тест не найден');
					window.location.href = 'home.html';
					return;
				}

				currentTest = testSnapshot.val();
				console.log('Загружен тест:', currentTest);

				if (!currentTest.questions || !Array.isArray(currentTest.questions) || currentTest.questions.length === 0) {
					console.error('Тест не содержит вопросов или вопросы не в формате массива:', currentTest);
					alert('Ошибка: тест не содержит вопросов');
					window.location.href = 'home.html';
					return;
				}

				// Проверяем формат вопросов
				console.log('Первый вопрос теста:', currentTest.questions[0]);

				// Отображаем данные теста
				testTitle.textContent = currentTest.title;
				resultTestTitle.textContent = currentTest.title;

				if (currentTest.description) {
					testDescription.textContent = currentTest.description;
				} else {
					testDescription.textContent = 'Описание отсутствует';
				}

				testQuestionsCount.textContent = currentTest.questionsCount;
				totalQuestions.textContent = currentTest.questionsCount;

				// Загружаем обложку
				if (currentTest.coverURL) {
					testCover.innerHTML = `<img src="${currentTest.coverURL}" alt="${currentTest.title}">`;
				}

				// Загружаем данные автора в функции loadTestData
				const authorSnapshot = await get(ref(db, `users/${currentTest.createdBy}`));
				if (authorSnapshot.exists()) {
					const authorData = authorSnapshot.val();

					// Создаем HTML для блока с автором
					const authorName = authorData.name || authorData.email;

					// Создаем аватарку автора
					let authorAvatarHtml = '';
					if (authorData.photoURL) {
						authorAvatarHtml = `<img src="${authorData.photoURL}" alt="${authorName}">`;
					} else {
						// Первая буква имени или email для аватарки
						const firstLetter = authorName.charAt(0).toUpperCase();

						// Генерируем цвет на основе имени
						const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#4a6ee0', '#03a9f4', '#00bcd4', '#009688', '#4caf50'];
						const colorIndex = Math.abs(authorName.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) % colors.length;

						authorAvatarHtml = `<div style="background-color: ${colors[colorIndex]}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${firstLetter}</div>`;
					}

					// Обновляем HTML для блока информации о тесте
					testAuthor.innerHTML = `
    <div class="author-info">
      <div class="author-avatar">
        ${authorAvatarHtml}
      </div>
      <span>${authorName}</span>
    </div>
  `;
				} else {
					testAuthor.textContent = 'Неизвестный автор';
				}

				// Форматируем дату
				const testDateTime = new Date(currentTest.createdAt);
				testDate.textContent = testDateTime.toLocaleDateString();

				// Устанавливаем категорию теста с переводом на русский язык и правильной иконкой
				if (currentTest.category) {
					// Маппинг категорий на русские названия и иконки
					const categoryMapping = {
						'general': { name: 'Общее', icon: 'fas fa-globe' },
						'education': { name: 'Образование', icon: 'fas fa-graduation-cap' },
						'science': { name: 'Наука', icon: 'fas fa-flask' },
						'technology': { name: 'Технологии', icon: 'fas fa-laptop-code' },
						'history': { name: 'История', icon: 'fas fa-landmark' },
						'geography': { name: 'География', icon: 'fas fa-map-marked-alt' },
						'art': { name: 'Искусство', icon: 'fas fa-palette' },
						'sports': { name: 'Спорт', icon: 'fas fa-running' },
						'entertainment': { name: 'Развлечения', icon: 'fas fa-film' },
						'other': { name: 'Другое', icon: 'fas fa-ellipsis-h' }
					};

					const category = categoryMapping[currentTest.category] || { name: 'Общее', icon: 'fas fa-globe' };

					// Обновляем текст и иконку категории
					document.getElementById('test-category').textContent = category.name;
					const categoryBadge = document.getElementById('test-category-badge');
					categoryBadge.innerHTML = `<i class="${category.icon}"></i> <span id="test-category">${category.name}</span>`;
				} else {
					document.getElementById('test-category').textContent = 'Общее';
					const categoryBadge = document.getElementById('test-category-badge');
					categoryBadge.innerHTML = `<i class="fas fa-globe"></i> <span id="test-category">Общее</span>`;
				}

				// Загружаем отзывы для теста
				loadTestReviews(testId);

				// Инициализируем массив ответов пользователя
				userAnswers = new Array(currentTest.questions.length).fill(null);

				// Проверяем ограничение времени
				if (currentTest.timeLimit && currentTest.timeLimit > 0) {
					timeLimit = currentTest.timeLimit;
					timerDisplay = document.getElementById('timer-display');

					// Показываем бейдж с ограничением времени
					const timeLimitBadge = document.getElementById('time-limit-badge');
					const timeLimitValue = document.getElementById('time-limit-value');
					timeLimitValue.textContent = timeLimit;
					timeLimitBadge.style.display = 'inline-flex';
				}

				// Проверяем, поддерживает ли тест совместное прохождение
				if (currentTest.cooperativeMode) {
					isCooperativeMode = true;

					// Показываем значок совместного режима
					document.getElementById('cooperative-badge').style.display = 'inline-flex';

					// Показываем кнопки для совместного режима
					document.getElementById('start-cooperative-btn').style.display = 'flex';
					document.getElementById('join-cooperative-btn').style.display = 'flex';

					// Отображаем активные лобби для данного теста
					loadActiveLobbies(testId);
				} else {
					// Если режим не совместный, показываем обычную кнопку старта
					document.getElementById('start-test-btn').style.display = 'flex';
				}

			} catch (error) {
				console.error('Ошибка при загрузке теста:', error);
				alert('Произошла ошибка при загрузке теста');
			}
		}

		// Функции для работы с таймером

		// Запуск таймера для вопроса
		function startTimer() {
			// Если таймер уже запущен, останавливаем его
			if (timerInterval) {
				clearInterval(timerInterval);
			}

			// Если нет ограничения по времени, не запускаем таймер
			if (!timeLimit || timeLimit <= 0) {
				document.getElementById('timer-container').style.display = 'none';
				return;
			}

			// Показываем таймер
			document.getElementById('timer-container').style.display = 'block';

			// Инициализируем оставшееся время
			remainingTime = timeLimit;
			timeExpired = false;

			// Обновляем отображение таймера
			updateTimerDisplay();

			// В обычном режиме проверяем, есть ли уже ответ пользователя, и если есть, останавливаем таймер
			if (!isCooperativeMode && userAnswers[currentQuestionIndex] !== null) {
				stopTimer();
				return;
			}

			// В совместном режиме проверяем, все ли ответили, и если да, останавливаем таймер
			if (isCooperativeMode && everyoneAnswered) {
				stopTimer();
				// Показываем правильный ответ и аватары
				displayParticipantAvatarsOnAnswers();
				return;
			}

			// Запускаем интервал
			timerInterval = setInterval(() => {
				remainingTime--;

				// Обновляем отображение
				updateTimerDisplay();

				// Проверяем, не истекло ли время
				if (remainingTime <= 0) {
					clearInterval(timerInterval);
					timeExpired = true;

					// В совместном режиме автоматически отправляем текущий ответ
					if (isCooperativeMode) {
						// Сначала отправляем ответ (даже если не выбран)
						submitAnswer();

						// После истечения времени для всех показываем правильный ответ
						if (everyoneAnswered) {
							displayParticipantAvatarsOnAnswers();
						}
					} else {
						// В обычном режиме автоматически переходим к следующему вопросу
						if (currentQuestionIndex < currentTest.questions.length - 1) {
							goToNextQuestion();
						} else {
							finishTest();
						}
					}
				}
			}, 1000);
		}

		// Обновление отображения таймера
		function updateTimerDisplay() {
			if (!timerDisplay) return;

			// Форматируем время
			const minutes = Math.floor(remainingTime / 60);
			const seconds = remainingTime % 60;

			// Обновляем текст
			timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

			// Обновляем класс для стилизации
			const timerElement = timerDisplay.parentElement;

			if (remainingTime <= 10) {
				timerElement.className = 'timer danger';
			} else if (remainingTime <= 30) {
				timerElement.className = 'timer warning';
			} else {
				timerElement.className = 'timer';
			}
		}

		// Остановка таймера
		function stopTimer() {
			if (timerInterval) {
				clearInterval(timerInterval);
				timerInterval = null;
			}
		}

		// Отображение текущего вопроса
		function displayCurrentQuestion() {
			// Проверка на корректность индекса
			if (!currentTest || !currentTest.questions || currentQuestionIndex >= currentTest.questions.length) {
				console.error('Ошибка: некорректный индекс вопроса или вопросы отсутствуют', {
					currentTest: currentTest,
					currentQuestionIndex: currentQuestionIndex
				});
				alert('Ошибка при отображении вопроса');
				return;
			}

			// Сбрасываем флаг everyoneAnswered при переходе к новому вопросу
			everyoneAnswered = false;

			const question = currentTest.questions[currentQuestionIndex];
			console.log('Отображаем вопрос:', question);
			console.log('Текущий индекс вопроса:', currentQuestionIndex, 'Всего вопросов:', currentTest.questionsCount);

			// Обновляем прогресс
			currentQuestionNum.textContent = currentQuestionIndex + 1;
			const progress = ((currentQuestionIndex + 1) / currentTest.questionsCount) * 100;
			progressBar.style.width = `${progress}%`;
			progressPercentage.textContent = `${Math.round(progress)}%`;

			// Проверяем формат данных вопроса и определяем варианты ответов
			let answerOptions = [];
			if (question.options) {
				// Новый формат
				answerOptions = question.options.map((option, index) => ({
					text: option,
					index: index,
					imageURL: question.optionImages && question.optionImages[index] ? question.optionImages[index] : null
				}));
			} else if (question.answers) {
				// Старый формат
				answerOptions = question.answers.map((answer, index) => ({
					text: answer.text || answer,
					index: index,
					imageURL: question.optionImages && question.optionImages[index] ? question.optionImages[index] : null
				}));
			} else {
				// Если нет ни options, ни answers, создаем пустой массив
				console.error('Формат вопроса не распознан:', question);
				answerOptions = [];
			}

			// Проверяем, является ли вопрос с множественным выбором
			const isMultipleChoice = question.isMultipleChoice ||
				(Array.isArray(question.correctAnswer) && question.correctAnswer.length > 1);

			// Если это вопрос с множественным выбором, добавляем подсказку сверху
			let multipleChoiceInfo = '';
			if (isMultipleChoice) {
				multipleChoiceInfo = `
          <div class="multiple-choice-info">
            <i class="fas fa-info-circle"></i> Этот вопрос содержит несколько правильных ответов
          </div>
        `;
			}

			// В совместном режиме сначала проверяем, есть ли уже сохраненный ответ в Firebase
			if (isCooperativeMode && lobbyCode) {
				// Получаем ответ текущего пользователя из Firebase для синхронизации
				console.log("Проверяем сохраненные ответы в Firebase для вопроса", currentQuestionIndex);

				get(ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}/${currentUser.uid}`))
					.then(snapshot => {
						if (snapshot.exists()) {
							const savedAnswer = snapshot.val();

							if (savedAnswer.answered) {
								// Если ответ существует, используем его
								const answerIndex = savedAnswer.answer !== undefined ? savedAnswer.answer : savedAnswer.answerIndex;

								console.log("Найден сохраненный ответ в Firebase:", answerIndex);

								// Обновляем локальный массив ответов
								userAnswers[currentQuestionIndex] = answerIndex;

								// После получения данных из Firebase обновляем UI
								updateUIWithSavedAnswer(answerIndex);
							}
						} else {
							console.log("Сохраненный ответ не найден для вопроса", currentQuestionIndex);
						}
					})
					.catch(error => {
						console.error("Ошибка при получении сохраненного ответа:", error);
					});
			}

			// Определяем, выбраны ли ответы для данного вопроса
			const userAnswer = userAnswers[currentQuestionIndex];
			const selectedIndexes = Array.isArray(userAnswer) ? userAnswer : (userAnswer !== null ? [userAnswer] : []);

			// Подготавливаем HTML для изображения вопроса
			let questionImageHTML = '';
			if (question.imageURL) {
				questionImageHTML = `
          <div class="question-image">
            <img src="${question.imageURL}" alt="Изображение к вопросу">
          </div>
        `;
			}

			// Обновляем контейнер вопроса с правильной структурой для отображения вариантов ответов
			questionContainer.innerHTML = `
        <div class="question-text">${question.text}</div>
        ${questionImageHTML}
        ${multipleChoiceInfo}
        <div class="answers-list ${isMultipleChoice ? 'multiple-choice' : ''}">
          ${answerOptions.map(option => {
				// Подготавливаем HTML для изображения варианта ответа
				let optionImageHTML = '';
				if (option.imageURL) {
					optionImageHTML = `
                <div class="answer-option-image">
                  <img src="${option.imageURL}" alt="Изображение варианта ответа">
                </div>
              `;
				}

				return `
              <div class="answer-item ${selectedIndexes.includes(option.index) ? 'selected' : ''}" 
                 data-index="${option.index}">
                <div class="answer-checkbox"></div>
                <div class="answer-content">
                  <div class="answer-option-text">${option.text}</div>
                  ${optionImageHTML}
                </div>
              </div>
            `;
			}).join('')}
        </div>
      `;

			// Функция для обновления UI с сохраненным ответом
			function updateUIWithSavedAnswer(savedAnswer) {
				const answerOptionElements = questionContainer.querySelectorAll('.answer-item');

				answerOptionElements.forEach(option => {
					const optionIndex = parseInt(option.dataset.index);

					// Для множественного выбора
					if (isMultipleChoice && Array.isArray(savedAnswer)) {
						if (savedAnswer.includes(optionIndex)) {
							option.classList.add('selected');
						}
					}
					// Для единичного выбора
					else if (optionIndex === savedAnswer) {
						answerOptionElements.forEach(opt => opt.classList.remove('selected'));
						option.classList.add('selected');
					}
				});

				// Обновляем состояние кнопок после загрузки сохраненного ответа
				updateButtonsAfterAnswer();
			}

			// Удаляем все аватары и подсветку при переходе к новому вопросу
			const existingAvatarContainers = document.querySelectorAll('.answer-participants');
			existingAvatarContainers.forEach(container => {
				container.remove();
			});

			// Получаем новые варианты ответов после обновления DOM
			const answerOptionElements = questionContainer.querySelectorAll('.answer-item');

			// Добавляем обработчики для вариантов ответов
			answerOptionElements.forEach(option => {
				option.addEventListener('click', () => {
					// Проверяем, можно ли изменить ответ (только если пользователь еще не ответил на этот вопрос)
					if (isCooperativeMode && participantsAnswers && participantsAnswers[currentUser.uid] && participantsAnswers[currentUser.uid].answered) {
						console.log("Ответ уже отправлен и не может быть изменен");
						return; // Пользователь уже ответил, не позволяем изменить ответ
					}

					const index = parseInt(option.dataset.index);

					// Для вопросов с множественным выбором
					if (isMultipleChoice) {
						// Инициализируем массив, если его еще нет
						if (!Array.isArray(userAnswers[currentQuestionIndex])) {
							userAnswers[currentQuestionIndex] = [];
						}

						// Если этот ответ уже выбран, убираем его; иначе добавляем
						if (userAnswers[currentQuestionIndex].includes(index)) {
							userAnswers[currentQuestionIndex] = userAnswers[currentQuestionIndex].filter(i => i !== index);
							option.classList.remove('selected');

							// Проверяем, остались ли выбранные ответы после снятия выбора
							if (isCooperativeMode && userAnswers[currentQuestionIndex].length === 0) {
								// Если не осталось выбранных ответов, меняем текст на "Выберите вариант ответа"
								if (currentQuestionIndex === currentTest.questions.length - 1) {
									submitTestBtn.textContent = 'Выберите вариант ответа';
									submitTestBtn.disabled = false;
								} else {
									nextQuestionBtn.textContent = 'Выберите вариант ответа';
									nextQuestionBtn.disabled = false;
								}
								return; // Прерываем выполнение, чтобы не изменять текст ниже
							}
						} else {
							userAnswers[currentQuestionIndex].push(index);
							option.classList.add('selected');
						}
					} else {
						// Для вопросов с одним вариантом ответа
						// Проверяем, выбираем мы уже выбранный вариант (тогда снимаем выбор)
						if (userAnswers[currentQuestionIndex] === index) {
							// Снимаем выбор варианта
							userAnswers[currentQuestionIndex] = null;
							option.classList.remove('selected');

							// В совместном режиме меняем текст кнопки
							if (isCooperativeMode) {
								if (currentQuestionIndex === currentTest.questions.length - 1) {
									submitTestBtn.textContent = 'Выберите вариант ответа';
									submitTestBtn.disabled = false;
								} else {
									nextQuestionBtn.textContent = 'Выберите вариант ответа';
									nextQuestionBtn.disabled = false;
								}
								return; // Прерываем выполнение, чтобы не изменять текст ниже
							}
						} else {
							// Выбираем новый вариант
							userAnswers[currentQuestionIndex] = index;

							// Обновляем UI
							answerOptionElements.forEach(opt => opt.classList.remove('selected'));
							option.classList.add('selected');
						}
					}

					// В совместном режиме включаем кнопку подтверждения ответа
					if (isCooperativeMode) {
						if (currentQuestionIndex === currentTest.questions.length - 1) {
							submitTestBtn.textContent = 'Подтвердить ответ';
							submitTestBtn.disabled = false;
						} else {
							nextQuestionBtn.textContent = 'Подтвердить ответ';
							nextQuestionBtn.disabled = false;
						}
					}
				});
			});

			// Если все ответили, отображаем аватары участников возле выбранных вариантов
			if (isCooperativeMode && everyoneAnswered) {
				displayParticipantAvatarsOnAnswers();
			}


			if (currentQuestionIndex === currentTest.questionsCount - 1) {
				nextQuestionBtn.style.display = 'none';
				submitTestBtn.style.display = 'flex';
			} else {
				nextQuestionBtn.style.display = 'flex';
				submitTestBtn.style.display = 'none';
			}

			// В совместном режиме
			if (isCooperativeMode) {
				// Показываем блок для ответов участников (изначально скрытый)
				document.getElementById('participants-answers').style.display = 'block';

				// Очищаем список ответов
				document.getElementById('answers-list').innerHTML = '';

				// Изначально отключаем кнопки навигации, пока все не ответят
				nextQuestionBtn.disabled = true;
				submitTestBtn.disabled = true;

				// Устанавливаем начальный текст кнопок в зависимости от того, ответил ли пользователь
				const currentUserAnswered = participantsAnswers &&
					participantsAnswers[currentUser.uid] &&
					participantsAnswers[currentUser.uid].answered;

				// Если пользователь еще не ответил, показываем "Выберите вариант ответа"
				if (!currentUserAnswered) {
					if (currentQuestionIndex === currentTest.questions.length - 1) {
						submitTestBtn.textContent = 'Выберите вариант ответа';
						submitTestBtn.disabled = false;
					} else {
						nextQuestionBtn.textContent = 'Выберите вариант ответа';
						nextQuestionBtn.disabled = false;
					}
				} else {
					// Если пользователь уже ответил, показываем "Ожидание других участников"
					if (currentQuestionIndex === currentTest.questions.length - 1) {
						submitTestBtn.textContent = 'Ожидание других участников...';
					} else {
						nextQuestionBtn.textContent = 'Ожидание других участников...';
					}
				}

				// Проверяем, является ли это соло-режимом (только хост)
				get(ref(db, `test_lobbies/${lobbyCode}/soloMode`)).then((snapshot) => {
					const isSoloMode = snapshot.exists() && snapshot.val() === true;

					if (isSoloMode && isHost) {
						// Если хост один, показываем упрощенный интерфейс
						document.getElementById('participants-answers').style.display = 'none';
					} else {
						// Обновляем список участников и их статусы
						updateParticipantsAnswerStatus();
					}
				});

				// Создаем или обновляем ссылку на ответы в Firebase
				const answersRef = ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}`);

				// Слушаем изменения в ответах участников
				onValue(answersRef, (snapshot) => {
					if (snapshot.exists()) {
						participantsAnswers = snapshot.val();
						updateParticipantsAnswerStatus();

						// Проверяем, есть ли ответ текущего пользователя, и если есть, обновляем UI
						if (participantsAnswers[currentUser.uid] && participantsAnswers[currentUser.uid].answered) {
							// Получаем ответ пользователя из Firebase
							const savedAnswer = participantsAnswers[currentUser.uid].answer !== undefined ?
								participantsAnswers[currentUser.uid].answer :
								participantsAnswers[currentUser.uid].answerIndex;

							// Обновляем локальный массив ответов
							userAnswers[currentQuestionIndex] = savedAnswer;

							// Обновляем UI с сохраненным ответом
							updateUIWithSavedAnswer(savedAnswer);

							// Делаем все варианты ответов неактивными
							const answerOptions = questionContainer.querySelectorAll('.answer-item');
							answerOptions.forEach(option => {
								option.classList.add('disabled');
								option.style.cursor = 'not-allowed';
								option.style.opacity = '0.7';
								// Удаляем обработчики событий
								option.replaceWith(option.cloneNode(true));
							});
						}

						// Проверяем, все ли ответили
						checkIfAllAnswered();
					}
				});
			}

			// Запускаем таймер для вопроса
			startTimer();
		}

		// Обновление статусов ответов участников
		function updateParticipantsAnswerStatus() {
			if (!isCooperativeMode) return;

			const answersList = document.getElementById('answers-list');
			// Проверяем существование элемента списка ответов
			if (!answersList) {
				console.log("Список ответов не найден, тест ещё не начался");
				return; // Выходим из функции, если список не найден (тест не начался)
			}

			answersList.innerHTML = '';

			Object.values(participants).forEach(participant => {
				const participantAnswer = document.createElement('div');
				participantAnswer.className = 'participant-answer';

				// Получаем данные участника для аватарки
				const avatarInitial = participant.name ? participant.name.charAt(0).toUpperCase() : 'U';
				let avatarHtml = '';

				// Приоритет изображения: photoURL, затем avatarUrl
				if (participant.photoURL) {
					avatarHtml = `<img src="${participant.photoURL}" alt="${participant.name}">`;
				} else if (participant.avatarUrl) {
					avatarHtml = `<img src="${participant.avatarUrl}" alt="${participant.name}">`;
				} else {
					// Генерируем цвет фона на основе uid участника
					const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#4a6ee0', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
					const colorIndex = Math.abs(participant.uid.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) % colors.length;
					avatarHtml = `<div style="background-color: ${colors[colorIndex]}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${avatarInitial}</div>`;
				}

				// Проверяем, ответил ли участник на текущий вопрос
				const hasAnswered = participantsAnswers &&
					participantsAnswers[participant.uid] &&
					participantsAnswers[participant.uid].answered;

				// Проверяем AFK статус и статус выхода
				const isAfk = participant.isAfk === true;
				const hasLeft = participant.hasLeft === true;

				// Добавляем класс для затемнения аватара если пользователь вышел со страницы
				const avatarClass = participant.leftPage ? 'participant-avatar left-page' : 'participant-avatar';

				// Формируем HTML для статуса ответа с разными классами для разных статусов
				let statusHtml = '';
				let statusClass = '';
				let statusText = '';

				if (participant.leftPage) {
					statusClass = 'status-left-page';
					statusText = 'Вышел со страницы';
				} else if (isAfk) {
					statusClass = 'status-afk';
					statusText = 'AFK';
				} else if (everyoneAnswered && hasAnswered) {
					// Если все ответили, показываем ответ участника
					statusClass = 'status-answered-complete';

					// Получаем информацию о выбранном варианте ответа
					const answerData = participantsAnswers[participant.uid];
					const answerIndex = answerData.answer !== undefined ? answerData.answer : answerData.answerIndex;
					const answerText = getAnswerTextByIndex(answerIndex);

					statusText = `Ответил: ${answerText}`;
				} else if (hasAnswered) {
					statusClass = 'status-answered';
					statusText = 'Ответил';
				} else {
					statusClass = 'status-waiting';
					statusText = 'Ожидает ответа';
				}

				// Формируем HTML для отображения статуса
				statusHtml = `<div class="participant-status ${statusClass}">${statusText}</div>`;

				participantAnswer.innerHTML = `
          <div class="${avatarClass}">${avatarHtml}</div>
          <div class="participant-name">
            ${participant.name || 'Пользователь'} 
            ${participant.isHost ? '<span class="host-badge">Хост</span>' : ''}
            ${participant.leftPage ? '<span class="left-page-badge">Вышел со страницы</span>' : ''}
          </div>
          ${statusHtml}
        `;

				answersList.appendChild(participantAnswer);
			});
		}

		// Проверка, все ли участники ответили
		function checkIfAllAnswered() {
			// Получаем актуальные данные ответов
			get(ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}`)).then((snapshot) => {
				if (snapshot.exists()) {
					const answers = snapshot.val();
					participantsAnswers = answers;

					// Обновляем состояние кнопок на основе ответов участников
					updateButtonsAfterAnswer();

					// Проверяем, все ли ответили
					const allAnswered = Object.values(participants).every(participant =>
						(participant.hasLeft === true) ||
						(answers[participant.uid] && answers[participant.uid].answered)
					);

					if (allAnswered && !everyoneAnswered) {
						console.log("Все участники ответили!");
						everyoneAnswered = true;

						// Останавливаем таймер
						stopTimer();

						// Обновляем статус ответов участников
						updateParticipantsAnswerStatus();

						// Отображаем аватары участников рядом с их ответами
						displayParticipantAvatarsOnAnswers();
					}
				}
			}).catch(error => {
				console.error("Ошибка при проверке ответов всех участников:", error);
			});
		}

		// Получение текста ответа по индексу
		function getAnswerTextByIndex(index) {
			if (!currentTest || !currentTest.questions || currentQuestionIndex >= currentTest.questions.length) {
				return 'Неизвестный ответ';
			}

			const question = currentTest.questions[currentQuestionIndex];

			// Если индекс является массивом (множественный выбор)
			if (Array.isArray(index)) {
				// Собираем тексты всех выбранных ответов
				const selectedTexts = index.map(idx => {
					if (question.options && question.options[idx]) {
						return question.options[idx];
					} else if (question.answers && question.answers[idx]) {
						return question.answers[idx].text || `Ответ ${idx + 1}`;
					} else {
						return `Ответ ${idx + 1}`;
					}
				});

				// Объединяем тексты через запятую
				return selectedTexts.join(', ');
			}

			// Обработка единичного индекса
			if (question.options && question.options[index]) {
				return question.options[index];
			} else if (question.answers && question.answers[index]) {
				return question.answers[index].text || 'Ответ ' + (index + 1);
			} else {
				return 'Ответ ' + (index + 1);
			}
		}

		// Функция для отображения аватаров участников рядом с их выбранными вариантами
		function displayParticipantAvatarsOnAnswers() {
			if (!isCooperativeMode) return;

			console.log("Отображаем аватары участников рядом с их ответами");

			// Сбрасываем существующие аватары и стили ответов
			const existingAvatarContainers = document.querySelectorAll('.answer-participants');
			existingAvatarContainers.forEach(container => {
				container.remove();
			});

			// Сбрасываем предыдущие подсветки ответов и маркеры
			const answerOptions = document.querySelectorAll('.answer-item');
			answerOptions.forEach(option => {
				option.classList.remove('correct', 'incorrect');

				// Удаляем существующие маркеры
				const markers = option.querySelectorAll('.answer-marker');
				markers.forEach(marker => marker.remove());
			});

			// Создаем объект для группировки участников по ответам
			const answerParticipants = {};

			// Получаем актуальные данные о пользователях из Firebase
			get(ref(db, `test_lobbies/${lobbyCode}/participants`)).then((snapshot) => {
				if (!snapshot.exists()) {
					console.log("Нет данных о пользователях в лобби");
					return;
				}

				const latestParticipants = snapshot.val();
				console.log("Данные о пользователях:", latestParticipants);

				// Получаем информацию о текущих ответах из Firebase
				get(ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}`)).then((answersSnapshot) => {
					if (!answersSnapshot.exists()) {
						console.log("Нет данных об ответах для текущего вопроса");
						return;
					}

					const participantAnswers = answersSnapshot.val();
					console.log("Ответы участников из Firebase:", participantAnswers);

					// Группируем участников по ответам
					Object.keys(participantAnswers).forEach(userId => {
						const answerData = participantAnswers[userId];
						if (!answerData || answerData.answered !== true) return;

						// Получаем данные участника из списка участников
						const participant = latestParticipants[userId];

						// Пропускаем вышедших участников
						if (participant && participant.hasLeft === true) return;

						// Получаем ответ участника (может быть массивом для множественного выбора)
						const userAnswer = answerData.answer !== undefined ? answerData.answer : answerData.answerIndex;

						// Преобразуем в массив, если это не массив
						const answerIndices = Array.isArray(userAnswer) ? userAnswer : [userAnswer];

						// Добавляем участника к каждому выбранному им ответу
						answerIndices.forEach(answerIndex => {
							if (answerIndex === null || answerIndex === undefined || answerIndex === -1) return;

							if (!answerParticipants[answerIndex]) {
								answerParticipants[answerIndex] = [];
							}

							if (latestParticipants[userId]) {
								answerParticipants[answerIndex].push({
									id: userId,
									...latestParticipants[userId]
								});
							}
						});
					});

					console.log("Сгруппированные ответы участников:", answerParticipants);

					// Получаем текущий вопрос
					const currentQuestion = currentTest.questions[currentQuestionIndex];

					// Определяем правильный ответ для текущего вопроса
					let correctAnswerIndexes = [];

					if (currentQuestion.correctAnswer !== undefined) {
						// Новый формат
						if (Array.isArray(currentQuestion.correctAnswer)) {
							correctAnswerIndexes = currentQuestion.correctAnswer;
						} else {
							correctAnswerIndexes = [currentQuestion.correctAnswer];
						}
					} else if (currentQuestion.answers) {
						// Старый формат
						currentQuestion.answers.forEach((answer, index) => {
							if (answer && answer.isCorrect) {
								correctAnswerIndexes.push(index);
							}
						});
					}

					console.log("Правильные ответы:", correctAnswerIndexes);

					// Отображаем аватары и подсвечиваем правильные/неправильные ответы
					answerOptions.forEach(option => {
						const answerIndex = parseInt(option.dataset.index);
						const participants = answerParticipants[answerIndex] || [];

						// Проверяем, выбрал ли текущий пользователь этот вариант
						const currentUserSelected = participants.some(p => p.id === currentUser.uid);

						// Подсвечиваем варианты ответов: 
						// 1) правильные - для всех (зеленым)
						// 2) неправильные - только для текущего пользователя, если он их выбрал (красным)
						if (correctAnswerIndexes.includes(answerIndex)) {
							// Правильный ответ - подсвечиваем зеленым для всех
							option.classList.add('correct');

							// Добавляем маркер правильного ответа, если его еще нет
							if (!option.querySelector('.answer-marker')) {
								const marker = document.createElement('div');
								marker.className = 'answer-marker correct-marker';
								marker.innerHTML = '<i class="fas fa-check"></i>';
								option.appendChild(marker);
							}
						} else if (currentUserSelected) {
							// Неправильный ответ, выбранный текущим пользователем - подсвечиваем красным только для него
							option.classList.add('incorrect');

							// Добавляем маркер неправильного ответа, если его еще нет
							if (!option.querySelector('.answer-marker')) {
								const marker = document.createElement('div');
								marker.className = 'answer-marker incorrect-marker';
								marker.innerHTML = '<i class="fas fa-times"></i>';
								option.appendChild(marker);
							}
						}

						if (participants.length > 0) {
							// Создаем контейнер для аватаров участников
							const avatarContainer = document.createElement('div');
							avatarContainer.className = 'answer-participants';

							// Добавляем аватары участников
							participants.forEach(participant => {
								const miniAvatar = document.createElement('div');
								miniAvatar.className = 'participant-mini-avatar';
								if (participant.isHost) {
									miniAvatar.classList.add('host-avatar');
								}

								// Используем аватарку из профиля пользователя
								const avatarInitial = participant.name ? participant.name.charAt(0).toUpperCase() : 'U';
								let avatarHtml = '';

								if (participant.photoURL) {
									avatarHtml = `<img src="${participant.photoURL}" alt="${participant.name}">`;
								} else if (participant.avatarUrl) {
									avatarHtml = `<img src="${participant.avatarUrl}" alt="${participant.name}">`;
								} else {
									// Используем цвет на основе имени для консистентности
									const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#4a6ee0', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
									const colorIndex = Math.abs((participant.name?.charCodeAt(0) || 0) % colors.length);
									avatarHtml = `<div style="background-color: ${colors[colorIndex]}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${avatarInitial}</div>`;
								}

								miniAvatar.innerHTML = avatarHtml;
								miniAvatar.title = participant.name;

								avatarContainer.appendChild(miniAvatar);
							});

							// Добавляем контейнер после текста варианта ответа
							option.appendChild(avatarContainer);
						}
					});
				}).catch(error => {
					console.error("Ошибка при получении ответов из Firebase:", error);
				});
			}).catch(error => {
				console.error("Ошибка при получении данных о пользователях:", error);
			});
		}

		// Отправка ответа пользователя в совместном режиме
		function submitAnswer() {
			if (!isCooperativeMode || !lobbyCode) {
				console.log("Отправка ответа доступна только в совместном режиме");
				return;
			}

			// Проверяем, выбран ли ответ
			const answer = userAnswers[currentQuestionIndex];
			if (answer === null || answer === undefined) {
				if (timeExpired) {
					// Если время вышло, отправляем -1 как индекс (не выбран ответ)
					sendAnswerToFirebase(-1);
				} else {
					alert('Выберите вариант ответа');
					return;
				}
			} else {
				// Отправляем выбранный ответ
				sendAnswerToFirebase(answer);
			}
		}

		// Отправка ответа в Firebase
		function sendAnswerToFirebase(answerIndex) {
			// Проверяем, что мы еще не отправляли ответ на этот вопрос
			if (participantsAnswers && participantsAnswers[currentUser.uid] && participantsAnswers[currentUser.uid].answered) {
				console.log("Ответ уже был отправлен ранее");
				return;
			}

			console.log(`Отправляем ответ для вопроса ${currentQuestionIndex + 1}: ${answerIndex}`);

			// Создаем или обновляем ссылку на ответы в Firebase
			const answerRef = ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}/${currentUser.uid}`);

			// Отправляем ответ
			const answerData = {
				answer: answerIndex, // Используем поле answer вместо answerIndex
				answerIndex: answerIndex, // Оставляем для обратной совместимости
				answered: true,
				timestamp: Date.now()
			};

			update(answerRef, answerData).then(() => {
				console.log('Ответ успешно отправлен');

				// Обновляем текст кнопок в зависимости от роли пользователя
				updateButtonsAfterAnswer();

				// Проверяем, ответили ли все участники
				checkAllParticipantsAnswered();
			}).catch(error => {
				console.error('Ошибка при отправке ответа:', error);
				alert('Ошибка при отправке ответа. Попробуйте еще раз.');
			});
		}

		// Функция для обновления текста кнопок после ответа
		function updateButtonsAfterAnswer() {
			// Проверяем, находимся ли мы на последнем вопросе
			const isLastQuestion = currentQuestionIndex === currentTest.questions.length - 1;

			// Проверяем, остался ли хост один активный (все остальные участники вышли или AFK)
			const activeParticipants = Object.values(participants).filter(participant =>
				!participant.hasLeft
			);

			const hostIsAlone = isHost && activeParticipants.length === 1 && activeParticipants[0].uid === currentUser.uid;

			// Если хост остался один активный участник, переключаем в соло-режим
			if (hostIsAlone && isHost) {
				console.log("Хост остался один активный участник, переключаем в соло-режим");
				// Устанавливаем soloMode для лобби
				update(lobbyRef, { soloMode: true }).then(() => {
					console.log("Лобби переключено в соло-режим");

					// В соло-режиме хост может продолжать тест самостоятельно
					if (isLastQuestion) {
						submitTestBtn.disabled = false;
						submitTestBtn.textContent = 'Завершить тест';
					} else {
						nextQuestionBtn.disabled = false;
						nextQuestionBtn.textContent = 'Следующий вопрос';
					}
				}).catch(error => {
					console.error("Ошибка при переключении в соло-режим:", error);
				});

				return;
			}

			// Проверяем, ответили ли все участники (с учетом AFK и вышедших)
			const allAnswered = Object.values(participants).every(participant =>
				(participant.hasLeft === true) ||
				(participantsAnswers &&
					participantsAnswers[participant.uid] &&
					participantsAnswers[participant.uid].answered)
			);

			// Если хост и все ответили, то можно перейти к следующему вопросу или завершить тест
			if (isHost && allAnswered) {
				if (isLastQuestion) {
					submitTestBtn.disabled = false;
					submitTestBtn.textContent = 'Завершить тест';
				} else {
					nextQuestionBtn.disabled = false;
					nextQuestionBtn.textContent = 'Следующий вопрос';
				}
				return;
			}

			// Проверяем, выбрал ли текущий пользователь вариант ответа в базе данных
			const currentUserAnswered = participantsAnswers &&
				participantsAnswers[currentUser.uid] &&
				participantsAnswers[currentUser.uid].answered;

			// Проверяем, выбран ли вариант ответа локально (но еще не подтвержден)
			const hasLocalAnswer = userAnswers[currentQuestionIndex] !== null &&
				userAnswers[currentQuestionIndex] !== undefined &&
				(Array.isArray(userAnswers[currentQuestionIndex]) ?
					userAnswers[currentQuestionIndex].length > 0 : true);

			// Если пользователь еще не подтвердил ответ, но выбрал вариант
			if (!currentUserAnswered && hasLocalAnswer) {
				if (isLastQuestion) {
					submitTestBtn.disabled = false;
					submitTestBtn.textContent = 'Подтвердить ответ';
				} else {
					nextQuestionBtn.disabled = false;
					nextQuestionBtn.textContent = 'Подтвердить ответ';
				}
				return;
			}

			// Если пользователь еще не выбрал вариант ответа
			if (!currentUserAnswered && !hasLocalAnswer) {
				if (isLastQuestion) {
					submitTestBtn.disabled = false;
					submitTestBtn.textContent = 'Выберите вариант ответа';
				} else {
					nextQuestionBtn.disabled = false;
					nextQuestionBtn.textContent = 'Выберите вариант ответа';
				}
				return;
			}

			// Для случаев, когда пользователь ответил, но ждет других участников или хоста
			if (allAnswered && !isHost) {
				// Если все ответили и текущий пользователь не хост, показываем "Ожидание хоста..."
				if (isLastQuestion) {
					submitTestBtn.disabled = true;
					submitTestBtn.textContent = 'Ожидание хоста...';
				} else {
					nextQuestionBtn.disabled = true;
					nextQuestionBtn.textContent = 'Ожидание хоста...';
				}
			} else {
				// Если еще не все ответили
				if (isLastQuestion) {
					submitTestBtn.disabled = true;
					submitTestBtn.textContent = 'Ожидание других участников...';
				} else {
					nextQuestionBtn.disabled = true;
					nextQuestionBtn.textContent = 'Ожидание других участников...';
				}
			}
		}

		// Переход к следующему вопросу
		function goToNextQuestion() {
			// В совместном режиме работаем по-другому
			if (isCooperativeMode) {
				if (!everyoneAnswered) {
					// Если еще не все ответили, отправляем текущий ответ
					submitAnswer();
					return;
				} else if (!isHost) {
					// Если пользователь не хост, он не может переходить к следующему вопросу
					return;
				}

				console.log("Переход к следующему вопросу. Текущий индекс:", currentQuestionIndex);

				// Хост может перейти к следующему вопросу, когда все ответили
				// Останавливаем текущий таймер
				stopTimer();

				// Сохраняем время, потраченное на вопрос
				const endTime = Date.now();
				questionTimeSpent[currentQuestionIndex] = endTime - questionStartTime;
				questionStartTime = endTime;

				// Переходим к следующему вопросу
				currentQuestionIndex++;

				console.log("Новый индекс вопроса:", currentQuestionIndex);

				// Сбрасываем флаг, что все ответили
				everyoneAnswered = false;

				// Инициализируем ответы для следующего вопроса если в соло-режиме или есть другие участники
				get(ref(db, `test_lobbies/${lobbyCode}/soloMode`)).then((snapshot) => {
					const isSoloMode = snapshot.exists() && snapshot.val() === true;

					const nextQuestionUpdates = { currentQuestion: currentQuestionIndex };

					// Если не в соло-режиме, инициализируем ответы для всех участников
					if (!isSoloMode) {
						const initialAnswers = {};
						Object.values(participants).forEach(participant => {
							initialAnswers[participant.uid] = {
								answered: false,
								answerIndex: null,
								answeredAt: null,
								timeSpent: 0
							};
						});

						nextQuestionUpdates[`answers/${currentQuestionIndex}`] = initialAnswers;
					}

					console.log("Обновления для следующего вопроса:", nextQuestionUpdates);

					// Обновляем статус текущего вопроса в лобби
					update(lobbyRef, nextQuestionUpdates).then(() => {
						// Отображаем следующий вопрос
						displayCurrentQuestion();
					});
				});

				return;
			}

			// Обычный режим
			// Убираем проверку на ответ пользователя, чтобы можно было пропускать вопросы без ответа

			// Останавливаем текущий таймер
			stopTimer();

			// Сохраняем время, потраченное на вопрос
			const endTime = Date.now();
			questionTimeSpent[currentQuestionIndex] = endTime - questionStartTime;
			questionStartTime = endTime;

			currentQuestionIndex++;
			displayCurrentQuestion();
		}

		// Проверка результатов теста
		function checkResults() {
			let correctAnswers = 0;
			let totalTime = 0;
			const answers = [];

			// Останавливаем таймер
			stopTimer();

			// Сохраняем время последнего вопроса
			const endTime = Date.now();
			if (typeof currentQuestionIndex !== 'undefined') {
				questionTimeSpent[currentQuestionIndex] = (questionTimeSpent[currentQuestionIndex] || 0) + (endTime - questionStartTime);
			}

			console.log("Начинаю проверку результатов...");
			console.log("Все ответы пользователя:", userAnswers);
			console.log("Вопросы теста:", currentTest.questions);

			for (let i = 0; i < currentTest.questions.length; i++) {
				const question = currentTest.questions[i];
				const userAnswer = userAnswers[i];

				console.log(`Проверка вопроса ${i + 1}: "${question.text}"`);
				console.log(`Ответ пользователя: ${userAnswer}`);

				// Определяем правильный ответ в зависимости от формата данных
				let isCorrect = false;
				let correctAnswerIndex = null;

				if (question.correctAnswer !== undefined) {
					// Новый формат
					correctAnswerIndex = question.correctAnswer;

					// Проверка для множественного выбора
					if (question.isMultipleChoice || Array.isArray(correctAnswerIndex)) {
						// Правильные ответы - массив индексов
						const correctAnswers = Array.isArray(correctAnswerIndex) ? correctAnswerIndex : [correctAnswerIndex];

						// Ответы пользователя - должны быть массивом
						const userAnswerArray = Array.isArray(userAnswer) ? userAnswer : (userAnswer !== null ? [userAnswer] : []);

						// Проверяем совпадение: должны быть выбраны все правильные ответы и только они
						isCorrect = userAnswerArray.length === correctAnswers.length &&
							correctAnswers.every(answer => userAnswerArray.includes(answer)) &&
							userAnswerArray.every(answer => correctAnswers.includes(answer));

						console.log(`Множественный выбор. Правильные ответы: [${correctAnswers}], ответы пользователя: [${userAnswerArray}], правильно? ${isCorrect}`);
					} else {
						// Обычный вопрос с одним ответом
						isCorrect = userAnswers[i] !== null && userAnswers[i] === question.correctAnswer;
						console.log(`Новый формат. Правильный ответ: ${correctAnswerIndex}, ответ пользователя: ${userAnswers[i]}, правильно? ${isCorrect}`);
					}
				} else if (question.answers) {
					// Старый формат
					for (let j = 0; j < question.answers.length; j++) {
						if (question.answers[j] && question.answers[j].isCorrect) {
							correctAnswerIndex = j;
							break;
						}
					}
					isCorrect = userAnswers[i] !== null && question.answers[userAnswers[i]] && question.answers[userAnswers[i]].isCorrect;
					console.log(`Старый формат. Правильный ответ: ${correctAnswerIndex}, ответ пользователя: ${userAnswers[i]}, правильно? ${isCorrect}`);
				}

				const timeSpent = questionTimeSpent[i] || 30000; // Если нет данных, предполагаем 30 секунд

				totalTime += timeSpent;

				// Сохраняем информацию по каждому вопросу для статистики
				answers.push({
					questionIndex: i,
					questionText: question.text,
					userAnswer: userAnswer,
					correctAnswerIndex: correctAnswerIndex,
					isCorrect: isCorrect,
					timeSpent: Math.round(timeSpent / 1000) // Переводим в секунды
				});

				if (isCorrect) {
					correctAnswers++;
					console.log(`Вопрос ${i + 1}: Ответ правильный! Текущий счет: ${correctAnswers}`);
				} else {
					console.log(`Вопрос ${i + 1}: Ответ неправильный.`);
				}
			}

			const score = Math.round((correctAnswers / currentTest.questionsCount) * 100);
			console.log(`Итоговый результат: ${correctAnswers}/${currentTest.questionsCount} (${score}%)`);

			// Отображаем результаты
			scoreValue.textContent = `${correctAnswers}/${currentTest.questionsCount}`;
			scorePercentage.textContent = `${score}%`;

			// Проверяем, нужно ли показывать правильные ответы
			if (currentTest.showCorrectAnswers) {
				displayCorrectAnswers(answers);
			}

			// Сохраняем результат в базу данных
			saveTestResult(correctAnswers, score, Math.round(totalTime / 1000), answers);

			// В совместном режиме
			if (isCooperativeMode) {
				// Получаем photoURL из Firebase Auth
				let userPhotoURL = null;
				const auth = getAuth();
				const currentFirebaseUser = auth.currentUser;
				if (currentFirebaseUser) {
					userPhotoURL = currentFirebaseUser.photoURL;
				}

				// Получаем актуальные данные пользователя из БД
				(async () => {
					let userName = currentUser.name || currentUser.email;
					let userEmail = currentUser.email;

					// Явно запрашиваем актуальное имя пользователя из базы данных
					try {
						const userSnapshot = await get(ref(db, `users/${currentUser.uid}`));
						if (userSnapshot.exists()) {
							const userData = userSnapshot.val();
							if (userData.name) {
								userName = userData.name;
								console.log('Используем имя из базы данных:', userName);
							} else {
								console.log('В базе данных не найдено имя, используем:', userName);
							}
						}
					} catch (error) {
						console.error("Ошибка при получении данных пользователя:", error);
					}

					// Сохраняем детальную информацию о каждом ответе для правильного сравнения
					const detailedAnswers = answers.map(answer => {
						return {
							questionIndex: answer.questionIndex,
							isCorrect: answer.isCorrect,
							correctAnswerIndex: answer.correctAnswerIndex,
							userAnswer: answer.userAnswer
						};
					});

					// Сохраняем свой результат в результатах лобби
					const resultData = {
						userId: currentUser.uid,
						name: userName,
						email: userEmail,
						avatarUrl: currentUser.avatarUrl || null,
						photoURL: userPhotoURL, // Добавляем photoURL для использования в рейтинге
						correctAnswers: correctAnswers,
						totalQuestions: currentTest.questionsCount,
						score: score,
						totalTime: Math.round(totalTime / 1000),
						detailedAnswers: detailedAnswers // Добавляем детальную информацию
					};

					// Проверяем все поля на undefined перед отправкой
					Object.keys(resultData).forEach(key => {
						if (resultData[key] === undefined) {
							console.warn(`Поле ${key} имеет значение undefined, заменяем на null`);
							resultData[key] = null;
						}
					});

					console.log("Отправляем результаты в Firebase:", resultData);

					// Обновляем свой результат
					update(ref(db, `test_lobbies/${lobbyCode}/results/${currentUser.uid}`), resultData).then(() => {
						// Если хост, обновляем статус лобби на "finished"
						if (isHost) {
							console.log("Обновляем статус лобби на 'finished'");
							update(lobbyRef, { status: 'finished' });

							// Сначала показываем рейтинг с имеющимися данными
							showParticipantsRanking();

							// После установки статуса finished, получаем все результаты и обеспечиваем их согласованность
							setTimeout(async () => {
								try {
									// Получаем все результаты
									const allResultsSnapshot = await get(ref(db, `test_lobbies/${lobbyCode}/results`));
									if (allResultsSnapshot.exists()) {
										const results = allResultsSnapshot.val();
										console.log("Хост: Все результаты получены для синхронизации:", results);

										// Обновляем рейтинг участников с новыми данными
										showParticipantsRanking();
									}
								} catch (error) {
									console.error("Ошибка при синхронизации результатов:", error);
								}

								// Запускаем таймер закрытия лобби и показываем его
								startLobbyCloseTimer(lobbyCode);
							}, 300); // Уменьшенная задержка для более быстрого отображения
						} else {
							// Обычный участник - сначала показываем имеющиеся данные
							showParticipantsRanking();

							// Затем обновляем после задержки с новыми данными
							setTimeout(async () => {
								try {
									// Получаем все результаты
									const allResultsSnapshot = await get(ref(db, `test_lobbies/${lobbyCode}/results`));
									if (allResultsSnapshot.exists()) {
										console.log("Участник: Результаты получены для обновления рейтинга:", allResultsSnapshot.val());
										showParticipantsRanking();
									}
								} catch (error) {
									console.error("Ошибка при обновлении рейтинга:", error);
								}
							}, 500);
						}
					}).catch(error => {
						console.error("Ошибка при сохранении результатов:", error);
						// Все равно пытаемся показать рейтинг участников
						showParticipantsRanking();
					});
				})();
			}
		}

		// Сохранение результата теста
		async function saveTestResult(correctAnswers, score, totalTime, answers) {
			try {
				const resultData = {
					testId: testId,
					testTitle: currentTest.title,
					correctAnswers: correctAnswers,
					totalQuestions: currentTest.questionsCount,
					score: score,
					totalTime: totalTime,
					answers: answers,
					completedAt: Date.now(),
					userId: currentUser.uid,
					userName: currentUser.name || currentUser.email || 'Неизвестный пользователь',
					userEmail: currentUser.email || 'Неизвестный пользователь'
				};

				const newResultRef = push(ref(db, 'test_results'));
				await set(newResultRef, resultData);

				console.log('Результат теста сохранен:', resultData);
			} catch (error) {
				console.error('Ошибка при сохранении результата:', error);
			}
		}

		// Начало теста
		function startTest() {
			testInfoContainer.style.display = 'none';

			// Показываем обратный отсчет перед началом теста
			showSynchronizedCountdown().then(() => {
				testTakingContainer.classList.add('active');

				currentQuestionIndex = 0;
				userAnswers = new Array(currentTest.questions.length).fill(null);

				// Инициализируем массив для отслеживания времени
				questionStartTime = Date.now();
				questionTimeSpent = new Array(currentTest.questions.length).fill(0);

				displayCurrentQuestion();
			});
		}

		// Завершение теста
		function finishTest() {
			// В совместном режиме
			if (isCooperativeMode) {
				// Если пользователь не хост, просто отправляем ответ и ожидаем завершения от хоста
				if (!isHost) {
					if (!everyoneAnswered) {
						submitAnswer();
					}
					return;
				}

				// Хост может завершить тест
				if (!everyoneAnswered) {
					// Если не все ответили, сначала отправляем свой ответ
					submitAnswer();
					return;
				}

				// Все ответили, завершаем тест
				update(lobbyRef, { status: 'finished' }).then(() => {
					testTakingContainer.classList.remove('active');
					resultsContainer.classList.add('active');
					resultTestTitle.textContent = currentTest.title || 'Тест';
					checkResults();
				});

				return;
			}

			// Обычный режим - безусловно завершаем тест
			testTakingContainer.classList.remove('active');
			resultsContainer.classList.add('active');
			resultTestTitle.textContent = currentTest.title || 'Тест';

			checkResults();
		}

		// Функция для отображения рейтинга участников
		function showParticipantsRanking() {
			if (!isCooperativeMode) return;

			const rankingContainer = document.getElementById('participants-ranking');
			const rankingList = document.getElementById('ranking-list');

			// Показываем контейнер с рейтингом
			rankingContainer.style.display = 'block';
			rankingList.innerHTML = '';

			console.log("Получаем результаты из Firebase для отображения рейтинга, текущий лобби код:", lobbyCode);
			console.log("Текущий пользователь:", currentUser.uid, "isHost:", isHost);

			// Обращаемся напрямую к корню результатов лобби, чтобы получить все результаты сразу
			get(ref(db, `test_lobbies/${lobbyCode}/results`)).then((resultsSnapshot) => {
				if (!resultsSnapshot.exists()) {
					console.warn("Результаты не найдены");
					rankingList.innerHTML = '<div style="text-align: center; padding: 20px;">Ожидание результатов от участников...</div>';

					// Повторяем запрос через 2 секунды, если результатов нет
					setTimeout(() => {
						showParticipantsRanking();
					}, 2000);

					return;
				}

				const results = resultsSnapshot.val();
				console.log("Полученные результаты напрямую:", results);

				// Получаем актуальные данные о участниках для дополнительной информации
				get(ref(db, `test_lobbies/${lobbyCode}/participants`)).then((participantsSnapshot) => {
					const latestParticipants = participantsSnapshot.exists() ? participantsSnapshot.val() : {};
					console.log("Актуальные данные о участниках:", latestParticipants);

					// Создаем массив для рейтинга
					const rankingData = [];

					// Объединяем данные результатов и участников
					Object.entries(results).forEach(([userId, resultData]) => {
						// Создаем базовую запись участника
						const participantRank = {
							userId: userId,
							name: resultData.name || 'Участник',
							correctAnswers: resultData.correctAnswers || 0,
							totalQuestions: resultData.totalQuestions || currentTest.questionsCount,
							score: resultData.score || 0,
							totalTime: resultData.totalTime || 0,
							detailedAnswers: resultData.detailedAnswers || []
						};

						// Дополнительная проверка данных для обеспечения согласованности
						if (participantRank.detailedAnswers && participantRank.detailedAnswers.length > 0) {
							// Пересчитываем количество правильных ответов из детальных данных
							const correctCount = participantRank.detailedAnswers.filter(ans => ans.isCorrect).length;
							if (correctCount > 0 && correctCount !== participantRank.correctAnswers) {
								console.log(`Обнаружено несоответствие для ${participantRank.name}: correctAnswers=${participantRank.correctAnswers}, но в detailedAnswers найдено ${correctCount} правильных ответов`);
								participantRank.correctAnswers = correctCount;
								participantRank.score = Math.round((correctCount / participantRank.totalQuestions) * 100);
							}
						}

						// Если есть данные об этом участнике, добавляем их
						if (latestParticipants[userId]) {
							participantRank.isHost = latestParticipants[userId].isHost || false;
							participantRank.photoURL = latestParticipants[userId].photoURL || resultData.photoURL;
							participantRank.avatarUrl = latestParticipants[userId].avatarUrl || resultData.avatarUrl;
						} else {
							participantRank.isHost = false;
							participantRank.photoURL = resultData.photoURL;
							participantRank.avatarUrl = resultData.avatarUrl;
						}

						rankingData.push(participantRank);
					});

					console.log("Данные для рейтинга до сортировки:", rankingData);

					// Сортируем по убыванию очков, при равенстве - по возрастанию времени
					console.log("ПЕРЕД СОРТИРОВКОЙ - проверим значения для каждого участника:");
					rankingData.forEach((p, i) => {
						console.log(`Участник ${p.name}: score=${p.score}, time=${p.totalTime}, correctAnswers=${p.correctAnswers}, totalQuestions=${p.totalQuestions}`);
					});

					rankingData.sort((a, b) => {
						if (a.score !== b.score) {
							return b.score - a.score; // По убыванию очков
						} else {
							return a.totalTime - b.totalTime; // При равенстве очков, по возрастанию времени
						}
					});

					console.log("ПОСЛЕ СОРТИРОВКИ - проверим значения для каждого участника:");
					rankingData.forEach((p, i) => {
						console.log(`Участник ${p.name}: score=${p.score}, time=${p.totalTime}, correctAnswers=${p.correctAnswers}, totalQuestions=${p.totalQuestions}`);
					});

					if (rankingData.length === 0) {
						rankingList.innerHTML = '<div style="text-align: center; padding: 20px;">Пока никто не завершил тест</div>';
						return;
					}

					// Алгоритм определения рангов
					// Округляем проценты до целых чисел, чтобы избежать проблем с точностью
					rankingData.forEach(participant => {
						// Принудительно округляем проценты до целых
						participant.roundedScore = Math.round(participant.score);
					});

					// Назначаем ранги с учетом округленных процентов
					if (rankingData.length > 0) {
						rankingData[0].rank = 1; // Первый участник всегда получает ранг 1
					}

					for (let i = 1; i < rankingData.length; i++) {
						const prev = rankingData[i - 1];
						const current = rankingData[i];

						// Сравниваем округленные проценты вместо точных
						if (current.roundedScore === prev.roundedScore) {
							// При равенстве округленных процентов, даем тот же ранг
							current.rank = prev.rank;
							console.log(`Участники с одинаковыми процентами: ${prev.name}(${prev.roundedScore}%) и ${current.name}(${current.roundedScore}%), ранг: ${current.rank}`);
						} else {
							// Присваиваем ранг равный позиции в списке
							current.rank = i + 1;
							console.log(`Участники с разными процентами: ${prev.name}(${prev.roundedScore}%) и ${current.name}(${current.roundedScore}%), ранг: ${current.rank}`);
						}
					}

					console.log("Финальные данные с назначенными рангами:", rankingData);

					// Отображаем участников с учетом рассчитанных рангов
					rankingData.forEach((participant, index) => {
						const rankingItem = document.createElement('div');
						rankingItem.className = 'ranking-item';

						// Определяем, какую медаль показывать (по рангу)
						let medalHTML = '';
						if (participant.rank === 1) {
							medalHTML = '<span class="rank-medal rank-gold">🥇</span>';
						} else if (participant.rank === 2) {
							medalHTML = '<span class="rank-medal rank-silver">🥈</span>';
						} else if (participant.rank === 3) {
							medalHTML = '<span class="rank-medal rank-bronze">🥉</span>';
						}

						// Получаем данные для отображения аватара
						const avatarInitial = participant.name ? participant.name.charAt(0).toUpperCase() : 'U';
						const isHost = participant.isHost;
						const isCreator = participant.userId === currentTest.createdBy;

						// Создаем HTML для аватарки с приоритетом: photoURL -> avatarUrl -> инициалы
						let avatarHtml = '';
						if (participant.photoURL) {
							console.log(`Использую photoURL для участника ${participant.name}:`, participant.photoURL);
							avatarHtml = `<img src="${participant.photoURL}" alt="${participant.name}">`;
						} else if (participant.avatarUrl) {
							console.log(`Использую avatarUrl для участника ${participant.name}:`, participant.avatarUrl);
							avatarHtml = `<img src="${participant.avatarUrl}" alt="${participant.name}">`;
						} else {
							console.log(`Использую инициал для участника ${participant.name}:`, avatarInitial);
							// Генерируем цвет фона на основе uid участника
							const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#4a6ee0', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
							const colorIndex = Math.abs(participant.userId.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) % colors.length;
							avatarHtml = `<div style="background-color: ${colors[colorIndex]}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${avatarInitial}</div>`;
						}

						rankingItem.innerHTML = `
              <div class="rank-position">${participant.rank}</div>
              ${medalHTML}
              <div class="participant-details">
                <div class="rank-avatar">${avatarHtml}</div>
                <div class="rank-name">${participant.name || 'Участник'} ${isCreator ? ' (Создатель)' : ''} ${isHost ? ' (Хост)' : ''}</div>
              </div>
              <div class="rank-score">${participant.correctAnswers}/${participant.totalQuestions} (${participant.score}%)</div>
            `;

						// Логирование для отладки
						console.log(`Отображаю участника в рейтинге: id=${participant.userId}, name=${participant.name}, isHost=${isHost}, место=${participant.rank}, счет=${participant.score}%, правильных=${participant.correctAnswers}/${participant.totalQuestions}`);

						// Выделяем текущего пользователя
						if (participant.userId === currentUser.uid) {
							rankingItem.style.display = 'flex';
							rankingItem.style.border = '2px solid var(--primary-color)';
						}

						rankingList.appendChild(rankingItem);
					});
				}).catch(error => {
					console.error("Ошибка при получении данных о участниках:", error);
					rankingList.innerHTML = '<div style="text-align: center; padding: 20px; color: #f44336;">Не удалось загрузить результаты</div>';
				});
			}).catch(error => {
				console.error("Ошибка при получении результатов:", error);
				rankingList.innerHTML = '<div style="text-align: center; padding: 20px; color: #f44336;">Не удалось загрузить результаты</div>';
			});
		}

		// Функция для отображения правильных ответов
		function displayCorrectAnswers(userAnswers) {
			const correctAnswersContainer = document.getElementById('correct-answers-container');
			const correctAnswersList = document.getElementById('correct-answers-list');
			const testSummary = document.getElementById('test-summary');

			// Подготавливаем суммарную статистику
			let totalCorrect = 0;
			let totalTime = 0;

			userAnswers.forEach(answer => {
				if (answer.isCorrect) totalCorrect++;
				totalTime += answer.timeSpent;
			});

			const percentCorrect = Math.round((totalCorrect / userAnswers.length) * 100);
			const timeInMinutes = Math.floor(totalTime / 60);
			const timeInSeconds = totalTime % 60;

			// Создаем HTML для сводки
			testSummary.innerHTML = `
        <div class="test-summary-content">
          <div class="summary-item">
            <div class="summary-label">Правильных ответов:</div>
            <div class="summary-value">${totalCorrect} из ${userAnswers.length} (${percentCorrect}%)</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Затраченное время:</div>
            <div class="summary-value">${timeInMinutes}мин ${timeInSeconds}сек</div>
          </div>
        </div>
      `;

			// Показываем контейнер
			correctAnswersContainer.style.display = 'block';
			correctAnswersList.innerHTML = '';

			console.log("Отображение правильных ответов, данные:", userAnswers);

			// Создаем элементы для каждого вопроса
			currentTest.questions.forEach((question, index) => {
				// Находим соответствующий ответ пользователя
				const userAnswer = userAnswers.find(ans => ans.questionIndex === index);
				if (!userAnswer) {
					console.warn(`Не найден ответ пользователя для вопроса ${index + 1}`);
					return;
				}

				console.log(`Отображение вопроса ${index + 1}, данные ответа:`, userAnswer);

				// Определяем правильный ответ
				let correctAnswerIndex = userAnswer.correctAnswerIndex;
				if (correctAnswerIndex === null || correctAnswerIndex === undefined) {
					// Если не передан в userAnswer, получаем из вопроса
					if (question.correctAnswer !== undefined) {
						// Новый формат
						correctAnswerIndex = question.correctAnswer;
					} else if (question.answers) {
						// Старый формат
						correctAnswerIndex = question.answers.findIndex(answer => answer.isCorrect === true);
					}
				}

				// Если не удалось определить правильный ответ, пропускаем
				if (correctAnswerIndex === null || correctAnswerIndex === -1) {
					console.warn(`Не удалось определить правильный ответ для вопроса ${index + 1}`);
					return;
				}

				// Получаем ответ пользователя
				let userAnswerIndex = userAnswer.userAnswer;

				console.log(`Вопрос ${index + 1}: правильный ответ=${correctAnswerIndex}, ответ пользователя=${userAnswerIndex}, верно=${userAnswer.isCorrect}`);

				// Создаем элемент вопроса
				const questionElement = document.createElement('div');
				questionElement.className = 'question-result';

				// Заголовок вопроса
				let questionHeader = `<div class="question-result-number">Вопрос ${index + 1}`;

				// Добавляем индикатор правильности
				if (userAnswer.isCorrect) {
					questionHeader += ` <span class="result-indicator correct"><i class="fas fa-check"></i></span>`;
				} else {
					questionHeader += ` <span class="result-indicator incorrect"><i class="fas fa-times"></i></span>`;
				}

				questionHeader += `</div>`;

				// Добавляем текст вопроса и информацию о времени
				const timeSpentText = `${userAnswer.timeSpent} сек`;

				questionElement.innerHTML = `
          ${questionHeader}
          <div class="question-result-text">${question.text}</div>
          <div class="time-info">
            <i class="fas fa-clock"></i> Затраченное время: ${timeSpentText}
          </div>
        `;

				// Получаем все варианты ответов
				let answerOptions = [];
				if (question.options) {
					// Новый формат
					answerOptions = question.options;
				} else if (question.answers) {
					// Старый формат
					answerOptions = question.answers.map(answer => answer.text || answer);
				}

				// Создаем элементы для каждого варианта ответа
				const answerOptionsDiv = document.createElement('div');
				answerOptionsDiv.className = 'answer-options';

				// Проверяем, является ли вопрос с множественным выбором
				const isMultipleChoice = question.isMultipleChoice ||
					Array.isArray(question.correctAnswer) ||
					Array.isArray(correctAnswerIndex);

				// Получаем массив правильных ответов
				const correctAnswerIndexes = Array.isArray(correctAnswerIndex) ? correctAnswerIndex : [correctAnswerIndex];

				// Получаем массив ответов пользователя
				const userAnswerIndexes = Array.isArray(userAnswerIndex) ? userAnswerIndex : [userAnswerIndex];

				// Если это вопрос с множественным выбором, добавляем информацию
				if (isMultipleChoice) {
					const multipleChoiceInfo = document.createElement('div');
					multipleChoiceInfo.className = 'multiple-choice-info';
					multipleChoiceInfo.innerHTML = '<i class="fas fa-info-circle"></i> Вопрос с несколькими правильными ответами';
					questionElement.appendChild(multipleChoiceInfo);
				}

				answerOptions.forEach((option, optIndex) => {
					const answerOptionDiv = document.createElement('div');
					answerOptionDiv.className = 'answer-option-result';

					// Определяем, выбрал ли пользователь этот вариант
					const isUserAnswer = userAnswerIndexes.includes(optIndex);

					// Определяем, является ли вариант правильным
					const isCorrectAnswer = correctAnswerIndexes.includes(optIndex);

					// Добавляем соответствующие классы
					if (isUserAnswer) {
						if (isCorrectAnswer) {
							answerOptionDiv.classList.add('user-correct');
						} else {
							answerOptionDiv.classList.add('user-incorrect');
						}
					} else if (isCorrectAnswer) {
						// Подсвечиваем правильные ответы, которые пользователь не выбрал
						answerOptionDiv.classList.add('correct-not-selected');
					}

					// Определяем иконку для ответа
					let iconHTML = '';
					if (isCorrectAnswer) {
						iconHTML = '<i class="fas fa-check"></i>';
					} else if (isUserAnswer && !isCorrectAnswer) {
						iconHTML = '<i class="fas fa-times"></i>';
					}

					answerOptionDiv.innerHTML = `
            <div class="answer-mark">${iconHTML}</div>
            <div class="answer-text">${option}</div>
          `;

					answerOptionsDiv.appendChild(answerOptionDiv);
				});

				questionElement.appendChild(answerOptionsDiv);
				correctAnswersList.appendChild(questionElement);
			});
		}

		// Загрузка данных при загрузке страницы
		window.addEventListener('DOMContentLoaded', () => {
			// Сначала скрываем все кнопки старта теста
			document.getElementById('start-test-btn').style.display = 'none';
			document.getElementById('start-cooperative-btn').style.display = 'none';
			document.getElementById('join-cooperative-btn').style.display = 'none';

			// Загружаем данные теста (кнопки будут показаны в loadTestData)
			loadTestData();
			initializeSidebar();
		});

		// В секции JavaScript после инициализации Firebase
		// Проверяем, является ли пользователь создателем теста
		if (currentUser && currentUser.uid) {
			const testRef = ref(db, `tests/${testId}`);
			get(testRef).then((snapshot) => {
				if (snapshot.exists()) {
					const test = snapshot.val();
					if (test.createdBy === currentUser.uid) {
						// Показываем кнопки редактирования и статистики только создателю теста
						document.getElementById('edit-test-btn').style.display = 'flex';
						document.getElementById('stats-test-btn').style.display = 'flex';
					}
				}
			});
		}

		// Обработчики для кнопок совместного режима
		document.getElementById('start-cooperative-btn').addEventListener('click', createLobby);
		document.getElementById('join-cooperative-btn').addEventListener('click', async function () {
			// Проверяем, находится ли пользователь уже в каком-то лобби
			const lobbiesRef = ref(db, 'test_lobbies');
			const snapshot = await get(lobbiesRef);

			if (snapshot.exists()) {
				const allLobbies = snapshot.val();

				// Проверяем все лобби на наличие текущего пользователя
				for (const [code, lobbyData] of Object.entries(allLobbies)) {
					if (lobbyData.participants && lobbyData.participants[currentUser.uid]) {
						// Пользователь уже находится в лобби
						// Показываем уведомление
						const alreadyInLobbyNotification = document.createElement('div');
						alreadyInLobbyNotification.className = 'notification error-notification';
						alreadyInLobbyNotification.innerHTML = `<div class="notification-content">Вы уже находитесь в лобби ${code}. Сначала покиньте текущее лобби, чтобы присоединиться к другому.</div>`;
						document.body.appendChild(alreadyInLobbyNotification);

						setTimeout(() => {
							alreadyInLobbyNotification.classList.add('show');
						}, 100);

						setTimeout(() => {
							alreadyInLobbyNotification.classList.remove('show');
							setTimeout(() => {
								alreadyInLobbyNotification.remove();
							}, 500);
						}, 5000);

						// Обновляем список активных лобби, чтобы пользователь видел своё текущее лобби
						loadActiveLobbies(testId);

						return; // Прерываем открытие формы присоединения
					}
				}
			}

			// Если пользователь не находится в лобби, показываем форму для ввода кода
			document.getElementById('join-cooperative-container').style.display = 'block';
		});
		document.getElementById('join-by-code-btn').addEventListener('click', joinLobbyByCode);
		document.getElementById('copy-code-btn').addEventListener('click', copyLobbyCode);
		document.getElementById('leave-lobby-btn').addEventListener('click', leaveLobby);

		// Сохраняем ссылку на функцию-обработчик beforeunload, чтобы иметь возможность удалить ее
		function beforeUnloadHandler(e) {
			if (isHost && lobbyCode) {
				// Только обновляем статус, без диалогового окна
				update(ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`), {
					leftPage: true
				});
			} else if (lobbyCode) {
				// Для обычных участников просто обновляем их статус
				update(ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`), {
					leftPage: true
				});
			}
		}

		// Обновляем обработчик события beforeunload
		window.addEventListener('beforeunload', beforeUnloadHandler);

		// Добавляем обработчик события unload для передачи прав хоста при выходе
		window.addEventListener('unload', function () {
			// Передаем права хоста только если это добровольный выход из лобби
			if (isHost && lobbyCode && voluntaryLeaving) {
				transferHostRights();
			}
		});

		document.getElementById('start-cooperative-test-btn').addEventListener('click', startCooperativeTest);

		// Обработчики для новых кнопок
		document.getElementById('edit-test-btn').addEventListener('click', () => {
			window.location.href = `edit-test.html?id=${testId}`;
		});

		document.getElementById('stats-test-btn').addEventListener('click', () => {
			window.location.href = `test-stats.html?id=${testId}`;
		});

		// Функции для совместного прохождения

		// Создание лобби для совместного прохождения
		async function createLobby() {
			try {
				// Проверяем, находится ли пользователь уже в каком-то лобби
				const lobbiesRef = ref(db, 'test_lobbies');
				const snapshot = await get(lobbiesRef);

				if (snapshot.exists()) {
					const allLobbies = snapshot.val();

					// Проверяем все лобби на наличие текущего пользователя
					for (const [code, lobbyData] of Object.entries(allLobbies)) {
						if (lobbyData.participants && lobbyData.participants[currentUser.uid]) {
							// Пользователь уже находится в лобби
							// Показываем уведомление
							const alreadyInLobbyNotification = document.createElement('div');
							alreadyInLobbyNotification.className = 'notification error-notification';
							alreadyInLobbyNotification.innerHTML = `<div class="notification-content">Вы уже находитесь в лобби ${code}. Сначала покиньте текущее лобби, чтобы создать новое.</div>`;
							document.body.appendChild(alreadyInLobbyNotification);

							setTimeout(() => {
								alreadyInLobbyNotification.classList.add('show');
							}, 100);

							setTimeout(() => {
								alreadyInLobbyNotification.classList.remove('show');
								setTimeout(() => {
									alreadyInLobbyNotification.remove();
								}, 500);
							}, 5000);

							// Переключаемся на вкладку "Присоединиться", чтобы пользователь мог найти своё лобби
							document.getElementById('join-cooperative-container').style.display = 'block';

							// Обновляем список активных лобби, чтобы пользователь видел своё текущее лобби
							loadActiveLobbies(testId);

							return; // Прерываем создание нового лобби
						}
					}
				}

				// Скрываем форму для ввода кода лобби, если она была открыта
				document.getElementById('join-cooperative-container').style.display = 'none';

				// Генерируем уникальный код лобби (6 цифр)
				let isUnique = false;
				let attempts = 0;
				const maxAttempts = 10; // Максимальное количество попыток для предотвращения бесконечного цикла

				while (!isUnique && attempts < maxAttempts) {
					// Генерируем код (от 100000 до 999999)
					lobbyCode = String(Math.floor(100000 + Math.random() * 900000));

					// Проверяем существование лобби с таким кодом
					const checkRef = ref(db, `test_lobbies/${lobbyCode}`);
					const checkSnapshot = await get(checkRef);

					if (!checkSnapshot.exists()) {
						// Код уникален
						isUnique = true;
					} else {
						attempts++;
						console.log(`Код лобби ${lobbyCode} уже существует, генерируем новый. Попытка ${attempts}/${maxAttempts}`);
					}
				}

				if (!isUnique) {
					// Если после всех попыток не удалось найти уникальный код
					showNotification('Не удалось создать уникальный код лобби. Пожалуйста, попробуйте еще раз.', 'error', 3000);
					return;
				}

				// Создаем ссылку на лобби в Firebase с уникальным кодом
				lobbyRef = ref(db, `test_lobbies/${lobbyCode}`);

				// Получаем актуальные данные пользователя из Firebase
				const auth = getAuth();
				const currentFirebaseUser = auth.currentUser;
				let userPhotoURL = null;
				let userName = currentUser.name || currentUser.email;

				if (currentFirebaseUser) {
					userPhotoURL = currentFirebaseUser.photoURL;

					// Получаем актуальные данные пользователя из базы данных Firebase
					try {
						// Явно получаем данные из базы данных Firebase
						const userSnapshot = await get(ref(db, `users/${currentFirebaseUser.uid}`));
						if (userSnapshot.exists()) {
							const userData = userSnapshot.val();
							if (userData.name) {
								userName = userData.name;
								console.log('Используем имя из базы данных:', userName);
							} else {
								console.log('В базе данных не найдено имя, используем:', userName);
							}
						}
					} catch (e) {
						console.error('Ошибка при получении данных пользователя:', e);
					}
				}

				// Добавляем хоста как первого участника
				const lobbyData = {
					testId: testId,
					testTitle: currentTest.title,
					hostId: currentUser.uid,
					createdAt: Date.now(),
					status: 'waiting', // waiting, started, finished
					currentQuestion: 0, // Индекс текущего вопроса
					participants: {
						[currentUser.uid]: {
							uid: currentUser.uid,
							name: userName,
							avatarUrl: currentUser.avatarUrl || null,
							photoURL: userPhotoURL, // Добавляем photoURL
							isHost: true,
							joinedAt: Date.now()
						}
					}
				};

				// Записываем данные лобби в Firebase
				set(lobbyRef, lobbyData).then(() => {
					// Устанавливаем флаг хоста
					isHost = true;

					// Обновляем UI
					document.getElementById('start-cooperative-btn').style.display = 'none';
					document.getElementById('join-cooperative-btn').style.display = 'none';
					document.getElementById('cooperative-lobby').style.display = 'block';
					document.getElementById('lobby-code').textContent = lobbyCode;

					// Явно показываем кнопку "Начать тест" для хоста
					const startCooperativeTestBtn = document.getElementById('start-cooperative-test-btn');
					if (startCooperativeTestBtn) {
						startCooperativeTestBtn.style.display = 'flex';
						console.log("Кнопка 'Начать тест' отображена для хоста");
					} else {
						console.error("Не найдена кнопка 'Начать тест'");
					}

					// Скрываем контейнер с активными лобби
					document.getElementById('active-lobbies-container').style.display = 'none';

					// Показываем уведомление о успешном создании лобби
					const createdNotification = document.createElement('div');
					createdNotification.className = 'notification';
					createdNotification.innerHTML = '<div class="notification-content">Лобби успешно создано</div>';
					document.body.appendChild(createdNotification);

					setTimeout(() => {
						createdNotification.classList.add('show');
					}, 100);

					setTimeout(() => {
						createdNotification.classList.remove('show');
						setTimeout(() => {
							createdNotification.remove();
						}, 500);
					}, 3000);

					// Добавляем хоста в список участников
					participants[currentUser.uid] = {
						uid: currentUser.uid,
						name: userName,
						avatarUrl: currentUser.avatarUrl || null,
						photoURL: userPhotoURL, // Добавляем photoURL
						isHost: true
					};

					updateParticipantsList();

					// Устанавливаем обработчик отключения
					const userStatusRef = ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`);
					// Удаляем обработчик onDisconnect
					// onDisconnect(userStatusRef).update({ isAfk: true, hasLeft: true });

					// Слушаем изменения в списке участников
					const participantsRef = ref(db, `test_lobbies/${lobbyCode}/participants`);
					onValue(participantsRef, (snapshot) => {
						if (snapshot.exists()) {
							const newParticipants = snapshot.val();

							// Проверяем, не стал ли текущий пользователь хостом
							const userWasHost = isHost;
							const currentParticipant = newParticipants[currentUser.uid];

							// Если пользователь подключился снова, убираем статус AFK 
							if (currentParticipant && currentParticipant.isAfk) {
								update(ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`), { isAfk: false });
							}

							if (currentParticipant && currentParticipant.isHost && !userWasHost) {
								// Пользователь стал новым хостом
								isHost = true;
								console.log("Вы стали новым хостом лобби");

								// Показываем кнопку начала теста, если тест еще не начался
								get(ref(db, `test_lobbies/${lobbyCode}/status`)).then((statusSnapshot) => {
									if (statusSnapshot.exists() && statusSnapshot.val() === 'waiting') {
										document.getElementById('start-cooperative-test-btn').style.display = 'block';
									}
								});

								// Показываем уведомление о том, что пользователь стал хостом
								const notification = document.createElement('div');
								notification.className = 'notification';
								notification.innerHTML = '<div class="notification-content">Вы стали хостом лобби</div>';
								document.body.appendChild(notification);

								setTimeout(() => {
									notification.classList.add('show');
								}, 100);

								setTimeout(() => {
									notification.classList.remove('show');
									setTimeout(() => {
										notification.remove();
									}, 500);
								}, 3000);
							} else if (currentParticipant && !currentParticipant.isHost && userWasHost) {
								// Пользователь был хостом, но перестал им быть
								isHost = false;
								console.log("Вы больше не являетесь хостом лобби");

								// Скрываем кнопку начала теста
								document.getElementById('start-cooperative-test-btn').style.display = 'none';

								// Показываем уведомление
								const notification = document.createElement('div');
								notification.className = 'notification';
								notification.innerHTML = '<div class="notification-content">Вы больше не являетесь хостом лобби</div>';
								document.body.appendChild(notification);

								setTimeout(() => {
									notification.classList.add('show');
								}, 100);

								setTimeout(() => {
									notification.classList.remove('show');
									setTimeout(() => {
										notification.remove();
									}, 500);
								}, 3000);
							}

							participants = newParticipants;
							updateParticipantsList();

							// Обновляем статусы ответов участников при изменении списка участников
							if (isCooperativeMode) {
								updateParticipantsAnswerStatus();
							}

							// Проверяем, остался ли только один участник после того, как были другие участники
							// Используем localStorageKey для сохранения состояния
							const lobbyHadMultipleParticipantsKey = `lobbyHadMultipleParticipants_${lobbyCode}`;

							if (Object.keys(newParticipants).length === 1 && isHost) {
								// Проверяем, было ли раньше более одного участника
								if (localStorage.getItem(lobbyHadMultipleParticipantsKey) === 'true') {
									// Если раньше было больше участников, а теперь остался только один (хост),
									// показываем предупреждение через менеджер уведомлений
									showNotification('Вы остались одни в лобби', 'info', 2000);
								}
							} else if (Object.keys(newParticipants).length > 1) {
								// Если в лобби более одного участника, устанавливаем флаг
								localStorage.setItem(lobbyHadMultipleParticipantsKey, 'true');
							}
						} else {
							// Если участников больше нет, считаем лобби закрытым и удаляем его
							console.log("В лобби не осталось участников, удаляем лобби");
							safeDeleteLobby(lobbyCode)
								.then(() => {
									resetLobbyState();
								})
								.catch(error => {
									console.error("Ошибка при удалении пустого лобби:", error);
								});
						}
					});

					// Слушаем изменения статуса лобби
					const lobbyStatusRef = ref(db, `test_lobbies/${lobbyCode}/status`);
					onValue(lobbyStatusRef, (snapshot) => {
						if (snapshot.exists()) {
							const status = snapshot.val();
							if (status === 'started') {
								// Если статус изменился на "started", начинаем тест для всех (и хоста, и участников)
								startCooperativeTestAsParticipant();
							} else if (status === 'finished' && !isHost) {
								// Если статус изменился на "finished" и пользователь не хост, завершаем тест
								console.log("Тест завершен хостом, показываем результаты");
								testTakingContainer.classList.remove('active');
								resultsContainer.classList.add('active');
								checkResults();

								// Участник тоже видит таймер обратного отсчета
								startLobbyCloseTimer(lobbyCode);
							} else if (status === 'countdown' && !isHost) {
								// Если статус изменился на "countdown" и пользователь не хост, 
								// показываем синхронизированный обратный отсчет
								showSynchronizedCountdown();
							}
						}
					});

					// Слушаем системные сообщения (исключение участников и др.)
					const systemMessagesRef = ref(db, `test_lobbies/${lobbyCode}/systemMessages`);
					onValue(systemMessagesRef, (snapshot) => {
						// Если лобби больше нет или пользователь вышел из лобби, игнорируем сообщения
						if (!lobbyCode || voluntaryLeaving) return;

						if (snapshot.exists()) {
							const messages = snapshot.val();

							// Получаем только новые сообщения (за последние 5 секунд)
							const now = Date.now();
							const recentMessages = Object.values(messages).filter(msg =>
								msg.timestamp && (now - msg.timestamp < 5000)
							);

							// Обрабатываем новые сообщения
							recentMessages.forEach(msg => {
								// Пропускаем сообщения, относящиеся к самому пользователю
								if (msg.participantId === currentUser.uid) return;

								// Проверяем, не исключен ли текущий пользователь
								get(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants/${currentUser.uid}`))
									.then((kickedSnapshot) => {
										// Показываем уведомление только если пользователь не исключен
										if (!kickedSnapshot.exists() || kickedSnapshot.val() !== true) {
											let notificationText = '';

											// Формируем текст уведомления в зависимости от типа сообщения
											if (msg.type === 'participant_kicked') {
												notificationText = `Участник ${msg.participantName} был исключен из лобби`;
											} else if (msg.type === 'participant_left') {
												notificationText = `Участник ${msg.participantName} покинул лобби`;
											}

											// Если есть текст уведомления, показываем его через менеджер уведомлений
											if (notificationText) {
												showNotification(notificationText, 'info', 2000);
											}
										}
									});
							});
						}
					});

					// Проверяем, не выгнали ли пользователя из лобби
					const kickedRef = ref(db, `test_lobbies/${lobbyCode}/kickedParticipants/${currentUser.uid}`);
					onValue(kickedRef, (snapshot) => {
						if (snapshot.exists() && snapshot.val() === true) {
							// Пользователь был выгнан из лобби
							console.log("Вы были исключены из лобби");

							// Показываем уведомление через новую функцию
							showNotification('Вы были исключены из лобби', 'error', 2000);

							// Сначала отключаем слушателей, чтобы они не реагировали на изменения
							if (lobbyCode) {
								// Отключаем всех слушателей Firebase, связанных с лобби
								off(ref(db, `test_lobbies/${lobbyCode}/participants`));
								off(ref(db, `test_lobbies/${lobbyCode}/systemMessages`));
								off(ref(db, `test_lobbies/${lobbyCode}/currentQuestion`));
								off(ref(db, `test_lobbies/${lobbyCode}/status`));
							}

							// Сбрасываем состояние лобби вместо перенаправления на главную страницу
							resetLobbyState();
						}
					});

					// Слушаем изменения текущего вопроса
					const currentQuestionRef = ref(db, `test_lobbies/${lobbyCode}/currentQuestion`);
					onValue(currentQuestionRef, (snapshot) => {
						if (snapshot.exists() && !isHost) {
							const question = parseInt(snapshot.val());
							if (question !== currentQuestionIndex) {
								// Получаем текущий статус лобби
								get(ref(db, `test_lobbies/${lobbyCode}/status`)).then((statusSnapshot) => {
									if (statusSnapshot.exists() && statusSnapshot.val() === 'started') {
										currentQuestionIndex = question;
										displayCurrentQuestion();
									}
								});
							}
						}
					});
				});
			} catch (error) {
				console.error('Ошибка при создании лобби:', error);
				alert('Произошла ошибка при создании лобби');
			}
		}

		// Присоединение к лобби по коду
		async function joinLobbyByCode() {
			const code = document.getElementById('join-code-input').value.trim().toUpperCase();

			if (!code) {
				alert('Введите код лобби');
				return;
			}

			try {
				// Проверяем, был ли пользователь исключен из этого лобби
				const kickedRef = ref(db, `test_lobbies/${code}/kickedParticipants/${currentUser.uid}`);
				const kickedSnapshot = await get(kickedRef);

				if (kickedSnapshot.exists() && kickedSnapshot.val() === true) {
					// Пользователь исключен из этого лобби
					showNotification('Вы были исключены из этого лобби', 'error', 2000);
					return;
				}

				// Проверяем, находится ли пользователь уже в каком-то лобби
				const lobbiesRef = ref(db, 'test_lobbies');
				const lobbiesSnapshot = await get(lobbiesRef);

				if (lobbiesSnapshot.exists()) {
					const allLobbies = lobbiesSnapshot.val();

					// Проверяем все лобби на наличие текущего пользователя
					for (const [existingCode, lobbyData] of Object.entries(allLobbies)) {
						if (lobbyData.participants && lobbyData.participants[currentUser.uid]) {
							// Если пользователь пытается присоединиться к лобби, в котором он уже есть,
							// просто показываем это лобби
							if (existingCode === code) {
								// Обновляем UI, чтобы показать существующее лобби
								lobbyCode = existingCode;
								lobbyRef = ref(db, `test_lobbies/${existingCode}`);

								// Проверяем, является ли пользователь хостом в этом лобби
								const lobbyDataSnapshot = await get(ref(db, `test_lobbies/${existingCode}`));
								if (lobbyDataSnapshot.exists()) {
									const lobbyData = lobbyDataSnapshot.val();

									// Проверяем, совпадает ли ID хоста с ID текущего пользователя
									if (lobbyData.hostId === currentUser.uid) {
										isHost = true;
										console.log("Вы являетесь хостом этого лобби");
									} else {
										isHost = false;
										console.log("Вы не являетесь хостом этого лобби");
									}
								}

								document.getElementById('start-cooperative-btn').style.display = 'none';
								document.getElementById('join-cooperative-btn').style.display = 'none';
								document.getElementById('join-cooperative-container').style.display = 'none';
								document.getElementById('cooperative-lobby').style.display = 'block';
								document.getElementById('lobby-code').textContent = existingCode;

								// Проверяем статус лобби и отображаем кнопку "Начать тест" если пользователь - хост
								if (isHost) {
									get(ref(db, `test_lobbies/${existingCode}/status`)).then((statusSnapshot) => {
										if (statusSnapshot.exists() && statusSnapshot.val() === 'waiting') {
											document.getElementById('start-cooperative-test-btn').style.display = 'flex';
											console.log("Отображаем кнопку 'Начать тест' для хоста");
										} else {
											document.getElementById('start-cooperative-test-btn').style.display = 'none';
										}
									});
								} else {
									document.getElementById('start-cooperative-test-btn').style.display = 'none';
								}

								// Обновляем список участников, чтобы правильно отобразить элементы управления хоста
								updateParticipantsList();
								// Скрываем контейнер с активными лобби
								document.getElementById('active-lobbies-container').style.display = 'none';

								// Обновляем список участников
								const participantsSnapshot = await get(ref(db, `test_lobbies/${existingCode}/participants`));
								if (participantsSnapshot.exists()) {
									participants = participantsSnapshot.val();

									// Проверяем, есть ли пользователь в списке участников
									if (!participants[currentUser.uid]) {
										console.log("Пользователь не найден в списке участников, добавляем его обратно");

										// Если пользователя нет в списке, возможно его исключили
										// Добавляем его обратно и удаляем из списка исключенных
										const auth = getAuth();
										const currentFirebaseUser = auth.currentUser;
										let userPhotoURL = null;
										let userName = currentUser.name || currentUser.email;

										if (currentFirebaseUser) {
											userPhotoURL = currentFirebaseUser.photoURL;

											// Получаем актуальные данные пользователя
											try {
												const userSnapshot = await get(ref(db, `users/${currentFirebaseUser.uid}`));
												if (userSnapshot.exists()) {
													const userData = userSnapshot.val();
													userName = userData.name || userName;
												}
											} catch (e) {
												console.error('Ошибка при получении данных пользователя:', e);
											}
										}

										// Добавляем пользователя в список участников
										const participantData = {
											uid: currentUser.uid,
											name: userName,
											avatarUrl: currentUser.avatarUrl || null,
											photoURL: userPhotoURL,
											isHost: false,
											joinedAt: Date.now()
										};

										await set(ref(db, `test_lobbies/${existingCode}/participants/${currentUser.uid}`), participantData);

										// Удаляем из списка исключенных, если был в нем
										await set(ref(db, `test_lobbies/${existingCode}/kickedParticipants/${currentUser.uid}`), null);
									}

									updateParticipantsList();
								}

								// Устанавливаем слушателей для лобби
								setupLobbyListeners(existingCode);

								// Сбрасываем статус "Вышел со страницы"
								update(ref(db, `test_lobbies/${existingCode}/participants/${currentUser.uid}`), {
									leftPage: false
								}).then(() => {
									// Показываем уведомление
									const notification = document.createElement('div');
									notification.className = 'notification';
									notification.innerHTML = '<div class="notification-content">Вы успешно вернулись в лобби</div>';
									document.body.appendChild(notification);

									setTimeout(() => {
										notification.classList.add('show');
									}, 100);

									setTimeout(() => {
										notification.classList.remove('show');
										setTimeout(() => {
											notification.remove();
										}, 500);
									}, 3000);
								});

								return;
							} else {
								// Если пользователь пытается присоединиться к другому лобби,
								// показываем уведомление и блокируем присоединение
								const alreadyInLobbyNotification = document.createElement('div');
								alreadyInLobbyNotification.className = 'notification error-notification';
								alreadyInLobbyNotification.innerHTML = `<div class="notification-content">Вы уже находитесь в лобби ${existingCode}. Сначала покиньте текущее лобби, чтобы присоединиться к другому.</div>`;
								document.body.appendChild(alreadyInLobbyNotification);

								setTimeout(() => {
									alreadyInLobbyNotification.classList.add('show');
								}, 100);

								setTimeout(() => {
									alreadyInLobbyNotification.classList.remove('show');
									setTimeout(() => {
										alreadyInLobbyNotification.remove();
									}, 500);
								}, 5000);

								return;
							}
						}
					}
				}

				const lobbySnapshot = await get(ref(db, `test_lobbies/${code}`));

				if (!lobbySnapshot.exists()) {
					alert('Лобби с таким кодом не найдено');
					return;
				}

				const lobbyData = lobbySnapshot.val();

				// Проверяем статус лобби
				if (lobbyData.status !== 'waiting') {
					alert('Это лобби уже начало тест или завершило его');
					return;
				}

				// Проверяем, соответствует ли тест
				if (lobbyData.testId !== testId) {
					alert('Код относится к другому тесту');
					return;
				}

				// Устанавливаем код лобби
				lobbyCode = code;
				lobbyRef = ref(db, `test_lobbies/${code}`);

				// Получаем актуальные данные пользователя из Firebase
				const auth = getAuth();
				const currentFirebaseUser = auth.currentUser;
				let userPhotoURL = null;
				let userName = currentUser.name || currentUser.email;

				if (currentFirebaseUser) {
					userPhotoURL = currentFirebaseUser.photoURL;

					// Получаем актуальные данные пользователя из базы данных Firebase
					try {
						const userSnapshot = await get(ref(db, `users/${currentFirebaseUser.uid}`));
						if (userSnapshot.exists()) {
							const userData = userSnapshot.val();
							userName = userData.name || userName;
							console.log('Получены актуальные данные пользователя из Firebase:', userData);
						}
					} catch (e) {
						console.error('Ошибка при получении данных пользователя:', e);
					}
				}

				// Добавляем пользователя в список участников
				const participantData = {
					uid: currentUser.uid,
					name: userName,
					avatarUrl: currentUser.avatarUrl || null,
					photoURL: userPhotoURL, // Добавляем photoURL
					isHost: false,
					joinedAt: Date.now()
				};

				await set(ref(db, `test_lobbies/${code}/participants/${currentUser.uid}`), participantData);

				// Обновляем UI
				document.getElementById('start-cooperative-btn').style.display = 'none';
				document.getElementById('join-cooperative-btn').style.display = 'none';
				document.getElementById('join-cooperative-container').style.display = 'none';
				document.getElementById('cooperative-lobby').style.display = 'block';
				document.getElementById('lobby-code').textContent = code;
				document.getElementById('start-cooperative-test-btn').style.display = isHost ? 'flex' : 'none';

				// Обновляем список участников, чтобы правильно отобразить элементы управления хоста
				updateParticipantsList();

				// Скрываем контейнер с активными лобби
				document.getElementById('active-lobbies-container').style.display = 'none';

				// Устанавливаем слушателей для лобби
				setupLobbyListeners(code);
			} catch (error) {
				console.error('Ошибка при присоединении к лобби:', error);
				alert('Произошла ошибка при присоединении к лобби');
			}
		}

		// Обновление списка участников в UI
		function updateParticipantsList() {
			const participantsList = document.getElementById('participants-list');
			const participantsCount = document.getElementById('participants-count');
			participantsList.innerHTML = '';

			// Обновляем счетчик участников
			const count = Object.keys(participants).length;
			participantsCount.textContent = count;

			// Показываем или скрываем контейнер исключенных участников в зависимости от роли
			const kickedParticipantsContainer = document.getElementById('kicked-participants');
			if (isHost) {
				kickedParticipantsContainer.style.display = 'block';
				updateKickedParticipantsList(); // Обновляем список исключенных участников
			} else {
				kickedParticipantsContainer.style.display = 'none';
			}

			Object.values(participants).forEach((participant) => {
				const participantItem = document.createElement('div');
				participantItem.className = 'participant-item';

				// Используем аватарку из профиля пользователя (приоритет: photoURL -> avatarUrl -> инициалы)
				const avatarInitial = participant.name ? participant.name.charAt(0).toUpperCase() : 'U';

				let avatarContent = avatarInitial;
				if (participant.photoURL) {
					avatarContent = `<img src="${participant.photoURL}" alt="${participant.name}">`;
				} else if (participant.avatarUrl) {
					avatarContent = `<img src="${participant.avatarUrl}" alt="${participant.name}">`;
				}

				// Добавляем класс для затемнения аватара если пользователь вышел со страницы
				const avatarClass = participant.leftPage ? 'participant-avatar left-page' : 'participant-avatar';

				// Основное содержимое элемента участника с добавлением статуса
				participantItem.innerHTML = `
          <div class="${avatarClass} ${participant.isHost ? 'host-avatar' : ''}">
            ${avatarContent}
          </div>
          <div class="participant-name">
            ${participant.name || 'Пользователь'} 
            ${participant.isHost ? '<span class="host-badge">Хост</span>' : ''}
            ${participant.leftPage ? '<span class="left-page-badge">Вышел со страницы</span>' : ''}
          </div>
        `;

				// Проверяем, является ли текущий пользователь хостом, используя глобальную переменную isHost
				// Если текущий пользователь хост и это не он сам, добавляем меню управления
				if (isHost && currentUser.uid !== participant.uid) {
					const controlsContainer = document.createElement('div');
					controlsContainer.className = 'participant-controls';

					// Кнопка "Сделать хостом"
					const makeHostBtn = document.createElement('button');
					makeHostBtn.className = 'control-btn make-host-btn';
					makeHostBtn.innerHTML = '<i class="fas fa-crown"></i>';
					makeHostBtn.title = 'Сделать хостом';
					makeHostBtn.addEventListener('click', () => makeHost(participant.uid));

					// Кнопка "Выгнать"
					const kickBtn = document.createElement('button');
					kickBtn.className = 'control-btn kick-btn';
					kickBtn.innerHTML = '<i class="fas fa-sign-out-alt"></i>';
					kickBtn.title = 'Выгнать';
					kickBtn.addEventListener('click', () => kickParticipant(participant.uid));

					controlsContainer.appendChild(makeHostBtn);
					controlsContainer.appendChild(kickBtn);
					participantItem.appendChild(controlsContainer);
				}

				participantsList.appendChild(participantItem);
			});
		}

		// Функция для назначения нового хоста
		function makeHost(participantId) {
			if (!isHost || !lobbyCode) return;

			// Получаем данные участника
			const participant = participants[participantId];
			if (!participant) return;

			// Показываем подтверждение
			if (confirm(`Сделать участника ${participant.name || 'Пользователь'} хостом? Вы потеряете права хоста.`)) {
				// Обновляем роли
				const updates = {};

				// Новый хост
				updates[`test_lobbies/${lobbyCode}/participants/${participantId}/isHost`] = true;

				// Текущий хост (перестает быть хостом)
				updates[`test_lobbies/${lobbyCode}/participants/${currentUser.uid}/isHost`] = false;

				// Обновляем hostId в лобби
				updates[`test_lobbies/${lobbyCode}/hostId`] = participantId;

				// Применяем изменения
				update(ref(db), updates)
					.then(() => {
						console.log(`Права хоста переданы участнику ${participant.name || 'Пользователь'}`);

						// Обновляем локальное состояние
						isHost = false;

						// Скрываем кнопку начала теста
						document.getElementById('start-cooperative-test-btn').style.display = 'none';

						// Обновляем список участников, чтобы скрыть элементы управления
						updateParticipantsList();

						// Уведомляем о передаче прав
						const notification = document.createElement('div');
						notification.className = 'notification';
						notification.innerHTML = `<div class="notification-content">Вы передали права хоста участнику ${participant.name || 'Пользователь'}</div>`;
						document.body.appendChild(notification);

						setTimeout(() => {
							notification.classList.add('show');
						}, 100);

						setTimeout(() => {
							notification.classList.remove('show');
							setTimeout(() => {
								notification.remove();
							}, 500);
						}, 3000);
					})
					.catch(error => {
						console.error("Ошибка при передаче прав хоста:", error);
						alert("Произошла ошибка при передаче прав хоста");
					});
			}
		}

		// Функция для исключения участника из лобби
		function kickParticipant(participantId) {
			if (!isHost || !lobbyCode) return;

			// Получаем данные участника
			const participant = participants[participantId];
			if (!participant) return;

			// Показываем подтверждение
			if (confirm(`Выгнать участника ${participant.name || 'Пользователь'} из лобби?`)) {
				// Сохраняем имя участника и его аватар перед удалением, чтобы показать их в уведомлении
				const participantName = participant.name || 'Пользователь';
				const participantAvatar = participant.photoURL || participant.avatarUrl;

				// Сначала добавляем участника в список исключенных
				update(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants`), {
					[participantId]: true
				}).then(() => {
					// Затем добавляем информацию о событии исключения в системные сообщения
					const systemMessageData = {
						type: 'participant_kicked',
						participantId: participantId,
						participantName: participantName,
						participantAvatar: participantAvatar,
						byHostId: currentUser.uid,
						byHostName: currentUser.name || 'Хост',
						timestamp: Date.now()
					};

					// Добавляем это сообщение в специальный узел лобби
					return push(ref(db, `test_lobbies/${lobbyCode}/systemMessages`), systemMessageData)
						.then(() => {
							// Удаляем участника из лобби (это вызовет событие в его клиенте)
							return set(ref(db, `test_lobbies/${lobbyCode}/participants/${participantId}`), null);
						});
				}).then(() => {
					console.log(`Участник ${participantName} исключен из лобби`);
					// Обновляем список исключенных участников
					updateKickedParticipantsList();

					// Хост получит уведомление через системные сообщения, поэтому
					// здесь не нужно показывать отдельное уведомление

				}).catch(error => {
					console.error("Ошибка при исключении участника:", error);
					alert("Произошла ошибка при исключении участника");
				});
			}
		}

		// Копирование кода лобби в буфер обмена
		function copyLobbyCode() {
			const code = document.getElementById('lobby-code').textContent;
			const copyBtn = document.getElementById('copy-code-btn');

			navigator.clipboard.writeText(code).then(() => {
				// Создаем элемент для всплывающего сообщения
				const popup = document.createElement('div');
				popup.textContent = 'Скопировано!';
				popup.style.cssText = `
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4a6ee0;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.5s;
            pointer-events: none;
            z-index: 100;
        `;

				// Добавляем элемент рядом с кнопкой
				copyBtn.style.position = 'relative';
				copyBtn.appendChild(popup);

				// Анимация появления
				setTimeout(() => {
					popup.style.opacity = '1';
					popup.style.transform = 'translateX(-50%) translateY(-5px)';
				}, 10);

				// Анимация исчезновения и удаление элемента
				setTimeout(() => {
					popup.style.opacity = '0';
					popup.style.transform = 'translateX(-50%) translateY(-15px)';
					setTimeout(() => {
						popup.remove();
					}, 500);
				}, 1500);
			});
		}

		// Объявляем глобальную переменную для отслеживания добровольного выхода
		let voluntaryLeaving = false;

		// Функция выхода из лобби с подтверждением для всех участников
		function leaveLobby() {
			if (!lobbyCode) return;

			// Показываем кастомное модальное окно подтверждения для всех участников
			showLeaveConfirmationModal().then(confirmed => {
				if (confirmed) {
					// Устанавливаем флаг добровольного выхода
					voluntaryLeaving = true;

					if (isHost) {
						// Если хост выходит, передаем права хоста другому участнику, если он есть
						transferHostRights()
							.then(() => {
								console.log("Лобби передано другому участнику или удалено");

								// Показываем уведомление о выходе из лобби через менеджер уведомлений
								showNotification('Вы вышли из лобби', 'info', 2000);

								resetLobbyState();
								// Сбрасываем флаг после resetLobbyState
								setTimeout(() => {
									voluntaryLeaving = false;
								}, 100);
							})
							.catch(error => {
								console.error("Ошибка при выходе из лобби:", error);
								alert("Произошла ошибка при выходе из лобби");
								// Сбрасываем флаг при ошибке
								voluntaryLeaving = false;
							});
					} else {
						// Если участник выходит, сначала отправляем системное сообщение о выходе
						const userInfo = participants[currentUser.uid] || { name: currentUser.name || 'Пользователь' };

						// Создаем системное сообщение о выходе участника
						const systemMessageData = {
							type: 'participant_left',
							participantId: currentUser.uid,
							participantName: userInfo.name,
							participantAvatar: userInfo.photoURL || userInfo.avatarUrl,
							timestamp: Date.now()
						};

						// Сначала добавляем системное сообщение
						push(ref(db, `test_lobbies/${lobbyCode}/systemMessages`), systemMessageData)
							.then(() => {
								// Затем удаляем участника из лобби
								return set(ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`), null);
							})
							.then(() => {
								console.log("Участник вышел из лобби");

								// Показываем уведомление о выходе из лобби через менеджер уведомлений
								showNotification('Вы вышли из лобби', 'info', 2000);

								resetLobbyState();
								// Сбрасываем флаг после resetLobbyState
								setTimeout(() => {
									voluntaryLeaving = false;
								}, 100);
							})
							.catch(error => {
								console.error("Ошибка при выходе из лобби:", error);
								alert("Произошла ошибка при выходе из лобби");
								// Сбрасываем флаг при ошибке
								voluntaryLeaving = false;
							});
					}
				}
			});
		}

		// Функция передачи прав хоста другому участнику
		async function transferHostRights() {
			if (!isHost || !lobbyCode) return Promise.resolve();

			try {
				// Получаем актуальный список участников
				const participantsSnapshot = await get(ref(db, `test_lobbies/${lobbyCode}/participants`));

				if (participantsSnapshot.exists()) {
					const participantsData = participantsSnapshot.val();
					const otherParticipants = Object.values(participantsData).filter(p => p.uid !== currentUser.uid);

					if (otherParticipants.length > 0) {
						// Если есть другие участники, передаем права хоста первому из них
						const newHost = otherParticipants[0];

						// Обновляем статус нового хоста
						await update(ref(db, `test_lobbies/${lobbyCode}/participants/${newHost.uid}`), {
							isHost: true
						});

						// Обновляем hostId в данных лобби
						await update(ref(db, `test_lobbies/${lobbyCode}`), {
							hostId: newHost.uid
						});

						// Удаляем себя из списка участников
						await set(ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`), null);

						console.log(`Права хоста переданы участнику ${newHost.name} (${newHost.uid})`);
						return Promise.resolve();
					} else {
						// Если других участников нет, удаляем лобби и все его подразделы
						console.log("Других участников нет, удаляем лобби и все его данные");

						// Сначала удаляем participants явно
						await set(ref(db, `test_lobbies/${lobbyCode}/participants`), null);

						// Затем удаляем все остальные подразделы
						const pathsToDelete = ['answers', 'systemMessages', 'kickedParticipants', 'status', 'currentQuestion'];

						for (const path of pathsToDelete) {
							await set(ref(db, `test_lobbies/${lobbyCode}/${path}`), null);
						}

						// Наконец удаляем само лобби
						return set(ref(db, `test_lobbies/${lobbyCode}`), null);
					}
				} else {
					// Если участников нет, удаляем лобби и все его данные
					console.log("Участников нет, удаляем лобби и все его данные");

					// Сначала удаляем participants явно
					await set(ref(db, `test_lobbies/${lobbyCode}/participants`), null);

					// Затем удаляем все остальные подразделы
					const pathsToDelete = ['answers', 'systemMessages', 'kickedParticipants', 'status', 'currentQuestion'];

					for (const path of pathsToDelete) {
						await set(ref(db, `test_lobbies/${lobbyCode}/${path}`), null);
					}

					// Наконец удаляем само лобби
					return set(ref(db, `test_lobbies/${lobbyCode}`), null);
				}
			} catch (error) {
				console.error("Ошибка при передаче прав хоста:", error);
				try {
					// В случае ошибки пытаемся явно удалить все части лобби
					// Сначала удаляем participants явно
					await set(ref(db, `test_lobbies/${lobbyCode}/participants`), null);

					// Затем удаляем все остальные подразделы
					const pathsToDelete = ['answers', 'systemMessages', 'kickedParticipants', 'status', 'currentQuestion'];

					for (const path of pathsToDelete) {
						await set(ref(db, `test_lobbies/${lobbyCode}/${path}`), null);
					}

					// Наконец удаляем само лобби
					return set(ref(db, `test_lobbies/${lobbyCode}`), null);
				} catch (finalError) {
					console.error("Критическая ошибка при удалении лобби:", finalError);
					return Promise.reject(finalError);
				}
			}
		}

		// Сброс состояния лобби и UI
		function resetLobbyState() {
			console.log("Вызвана функция resetLobbyState, текущее состояние - isHost:", isHost, "lobbyCode:", lobbyCode);

			// Если был установлен код лобби, удаляем флаг из localStorage
			if (lobbyCode) {
				const lobbyHadMultipleParticipantsKey = `lobbyHadMultipleParticipants_${lobbyCode}`;
				localStorage.removeItem(lobbyHadMultipleParticipantsKey);

				// Отменяем обработчик onDisconnect для текущего пользователя
				const userStatusRef = ref(db, `test_lobbies/${lobbyCode}/participants/${currentUser.uid}`);
				onDisconnect(userStatusRef).cancel().catch(error => {
					console.warn("Ошибка при отмене onDisconnect обработчика:", error);
				});

				// Отключаем всех слушателей Firebase, связанных с лобби
				off(ref(db, `test_lobbies/${lobbyCode}/participants`));
				off(ref(db, `test_lobbies/${lobbyCode}/systemMessages`));
				off(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants/${currentUser.uid}`));
				off(ref(db, `test_lobbies/${lobbyCode}/status`));
				off(ref(db, `test_lobbies/${lobbyCode}/currentQuestion`));
				off(ref(db, `test_lobbies/${lobbyCode}/host`));
			}

			// Сбрасываем переменные лобби
			lobbyCode = null;
			lobbyRef = null;
			isHost = false;
			participants = {};
			participantsAnswers = {};

			// Удаляем обработчик beforeunload для предотвращения появления предупреждения
			window.removeEventListener('beforeunload', beforeUnloadHandler);

			// Сбрасываем UI
			document.getElementById('start-cooperative-btn').style.display = 'flex';
			document.getElementById('join-cooperative-btn').style.display = 'flex';
			document.getElementById('cooperative-lobby').style.display = 'none';
			document.getElementById('join-cooperative-container').style.display = 'none';

			// Важно: также сбрасываем состояние кнопки начала теста
			const startCooperativeTestBtn = document.getElementById('start-cooperative-test-btn');
			if (startCooperativeTestBtn) {
				startCooperativeTestBtn.style.display = 'none';
			}

			// Сбрасываем флаг добровольного выхода
			voluntaryLeaving = false;

			// Показываем активные лобби, если мы вернулись в исходное состояние
			loadActiveLobbies(testId);

			console.log("Состояние лобби сброшено, новое состояние - isHost:", isHost, "lobbyCode:", lobbyCode);
		}

		// Функция для отображения синхронизированного обратного отсчета
		function showSynchronizedCountdown() {
			return new Promise(async (resolve) => {
				const countdownOverlay = document.getElementById('test-countdown-overlay');
				const countdownDisplay = document.getElementById('countdown-display');
				const storage = getStorage();

				// Предварительно загружаем все звуки
				const sounds = {};
				const soundFiles = ['3.mp3', '2.mp3', '1.mp3', 'start.mp3'];

				try {
					// Загружаем все звуки параллельно
					await Promise.all(soundFiles.map(async (filename) => {
						const audioRef = storageRef(storage, `countdown_sounds/${filename}`);
						const audioUrl = await getDownloadURL(audioRef);
						sounds[filename] = new Audio(audioUrl);
						// Предварительная загрузка
						await sounds[filename].load();
					}));

					// Показываем оверлей после загрузки звуков
					countdownOverlay.classList.add('active');

					// Воспроизведение звука (уже загруженного)
					function playSound(filename) {
						if (sounds[filename]) {
							sounds[filename].currentTime = 0;
							sounds[filename].play().catch(e => console.error('Ошибка воспроизведения:', e));
						}
					}

					// Функция для анимации числа с уже загруженным звуком
					function animateNumber(number) {
						return new Promise(resolve => {
							countdownDisplay.textContent = number;
							countdownDisplay.className = 'countdown-number';

							// Воспроизводим звук в момент показа числа
							playSound(`${number}.mp3`);

							// Задержка перед появлением
							setTimeout(() => {
								countdownDisplay.classList.add('active');

								// Задержка перед исчезновением
								setTimeout(() => {
									countdownDisplay.classList.add('fade-out');
									countdownDisplay.classList.remove('active');

									// Задержка после исчезновения
									setTimeout(() => {
										resolve();
									}, 500);
								}, 800);
							}, 100);
						});
					}

					// Функция для анимации текста "Старт!"
					function animateStartText() {
						return new Promise(resolve => {
							countdownDisplay.textContent = 'Старт!';
							countdownDisplay.className = 'countdown-text';

							// Воспроизводим звук в момент показа текста
							playSound('start.mp3');

							setTimeout(() => {
								countdownDisplay.classList.add('active');

								setTimeout(() => {
									countdownDisplay.classList.add('fade-out');
									countdownDisplay.classList.remove('active');

									setTimeout(() => {
										countdownOverlay.classList.remove('active');
										resolve();
									}, 500);
								}, 800);
							}, 100);
						});
					}

					// Последовательно отображаем 3, 2, 1, Старт!
					await animateNumber(3);
					await animateNumber(2);
					await animateNumber(1);
					await animateStartText();

					// Завершаем обратный отсчет
					resolve();

				} catch (error) {
					console.error('Ошибка загрузки звуков:', error);
					// Если не удалось загрузить звуки, показываем отсчет без звука
					countdownOverlay.classList.add('active');

					await animateNumber(3);
					await animateNumber(2);
					await animateNumber(1);
					await animateStartText();

					resolve();
				}
			});
		}

		// Начало совместного теста хостом
		function startCooperativeTest() {
			console.log("Начинаем совместное прохождение теста как хост");

			// Проверяем количество участников в лобби
			const participantsCount = Object.keys(participants).length;
			if (participantsCount < 2) {
				alert('Для начала совместного теста нужно минимум 2 участника (вы и еще кто-то)');
				return;
			}

			// Проверяем, есть ли участники со статусом "Вышел со страницы"
			const leftPageParticipants = Object.values(participants).filter(p => p.leftPage === true);

			if (leftPageParticipants.length > 0) {
				const leftParticipantsNames = leftPageParticipants
					.map(p => p.name || 'Неизвестный участник')
					.join(', ');

				const message = `Следующие участники находятся вне страницы:\n\n${leftParticipantsNames}\n\n` +
					'Для запуска теста необходимо, чтобы эти участники вернулись на страницу, ' +
					'либо исключите их из лобби, используя кнопку "Выгнать"';

				alert(message);
				return;
			}

			// Инициализируем структуру ответов для первого вопроса
			const initialAnswers = {};
			Object.values(participants).forEach(participant => {
				initialAnswers[participant.uid] = {
					answered: false,
					answerIndex: null,
					answeredAt: null,
					timeSpent: 0
				};
			});

			// Сначала меняем статус на "countdown", чтобы все клиенты показали обратный отсчет
			update(lobbyRef, {
				status: 'countdown',
				countdownStartTime: serverTimestamp(),
				questionsCount: currentTest.questionsCount || currentTest.questions.length // Добавляем информацию о количестве вопросов
			}).then(() => {
				// Показываем обратный отсчет на стороне хоста
				showSynchronizedCountdown().then(() => {
					// После окончания отсчета обновляем статус лобби и начинаем тест
					const updates = {
						status: 'started',
						currentQuestion: 0,
						[`answers/0`]: initialAnswers,
						soloMode: false
					};

					update(lobbyRef, updates).then(() => {
						// Скрываем лобби и показываем интерфейс теста
						document.getElementById('test-info-container').style.display = 'none';
						document.getElementById('test-taking-container').classList.add('active');

						// Начинаем отсчет времени
						currentQuestionIndex = 0;
						questionStartTime = Date.now();
						questionTimeSpent = new Array(currentTest.questions.length).fill(0);

						// Отображаем первый вопрос
						displayCurrentQuestion();
					});
				});
			}).catch(error => {
				console.error("Ошибка при запуске совместного теста:", error);
				alert("Произошла ошибка при запуске совместного теста");
			});
		}

		// Начало совместного теста участником (не хостом)
		function startCooperativeTestAsParticipant() {
			console.log("Начинаем совместное прохождение теста как участник");

			// Убираем вызов обратного отсчета отсюда, так как он уже вызывается при получении статуса 'countdown'
			// Скрываем информацию о тесте, но не скрываем лобби
			document.getElementById('test-info-container').style.display = 'none';
			document.getElementById('test-taking-container').classList.add('active');

			// Сбрасываем флаг everyoneAnswered и очищаем ответы участников
			everyoneAnswered = false;
			participantsAnswers = {};

			// Получаем текущий вопрос из Firebase
			get(ref(db, `test_lobbies/${lobbyCode}/currentQuestion`)).then((snapshot) => {
				if (snapshot.exists()) {
					currentQuestionIndex = parseInt(snapshot.val());
				} else {
					currentQuestionIndex = 0;
				}

				// Начинаем отсчет времени
				questionStartTime = Date.now();
				questionTimeSpent = new Array(currentTest.questions.length).fill(0);

				// Отображаем текущий вопрос
				displayCurrentQuestion();
			});
		}

		// Обработчики событий
		startTestBtn.addEventListener('click', startTest);
		nextQuestionBtn.addEventListener('click', function () {
			if (isCooperativeMode && !everyoneAnswered) {
				submitAnswer();
			} else {
				goToNextQuestion();
			}
		});
		submitTestBtn.addEventListener('click', function () {
			console.log("Нажата кнопка завершения теста");
			console.log("Текущий индекс:", currentQuestionIndex, "Всего вопросов:", currentTest.questionsCount);
			console.log("Флаг everyoneAnswered:", everyoneAnswered);
			console.log("Текст кнопки:", submitTestBtn.textContent);

			// В совместном режиме если не все ответили или это кнопка подтверждения ответа, сначала отправляем свой ответ
			if (isCooperativeMode && (!everyoneAnswered || submitTestBtn.textContent === 'Подтвердить ответ')) {
				console.log("Отправляем ответ на последнем вопросе");
				submitAnswer();
				return;
			}

			// Сохраняем время последнего вопроса
			const endTime = Date.now();
			questionTimeSpent[currentQuestionIndex] = (questionTimeSpent[currentQuestionIndex] || 0) + (endTime - questionStartTime);

			// Останавливаем таймер
			stopTimer();

			// Безусловно завершаем тест, минуя все проверки
			testTakingContainer.classList.remove('active');
			resultsContainer.classList.add('active');

			// Обновляем статус лобби в совместном режиме
			if (isCooperativeMode && isHost) {
				console.log("Обновляем статус лобби на 'finished'");
				update(lobbyRef, { status: 'finished' });
			}

			checkResults();
		});

		// Функция для загрузки и отображения активных лобби
		function loadActiveLobbies(testId) {
			if (!testId) return;

			// Если пользователь уже находится в лобби, скрываем контейнер с активными лобби
			if (lobbyCode) {
				document.getElementById('active-lobbies-container').style.display = 'none';
				return;
			}

			// Получаем ссылку на все лобби
			const lobbiesRef = ref(db, 'test_lobbies');

			// Проверяем, находится ли пользователь уже в каком-то лобби
			let userCurrentLobby = null;
			const checkUserInLobby = async (snapshot = null) => {
				if (!snapshot) {
					snapshot = await get(lobbiesRef);
				}

				userCurrentLobby = null;

				if (snapshot.exists()) {
					const allLobbies = snapshot.val();

					// Проверяем все лобби на наличие текущего пользователя
					for (const [code, lobbyData] of Object.entries(allLobbies)) {
						if (lobbyData.participants && lobbyData.participants[currentUser.uid]) {
							userCurrentLobby = code;

							// Если пользователь уже в лобби, скрываем кнопки создания и присоединения к лобби
							document.getElementById('start-cooperative-btn').style.display = 'none';
							document.getElementById('join-cooperative-btn').style.display = 'none';
							return;
						}
					}

					// Если пользователь не находится ни в одном лобби, показываем кнопки создания и присоединения к лобби
					document.getElementById('start-cooperative-btn').style.display = 'flex';
					document.getElementById('join-cooperative-btn').style.display = 'flex';
				} else {
					// Если нет доступных лобби, показываем кнопки создания и присоединения к лобби
					document.getElementById('start-cooperative-btn').style.display = 'flex';
					document.getElementById('join-cooperative-btn').style.display = 'flex';
				}
			};

			// Устанавливаем слушатель для обновлений в реальном времени
			checkUserInLobby().then(() => {
				onValue(lobbiesRef, (snapshot) => {
					// Проверяем, находится ли пользователь в каком-то лобби при каждом обновлении данных
					checkUserInLobby(snapshot);

					// Еще раз проверяем, не вошел ли пользователь в лобби пока мы ждали данные
					if (lobbyCode) {
						document.getElementById('active-lobbies-container').style.display = 'none';
						return;
					}

					if (!snapshot.exists()) {
						// Если нет активных лобби, скрываем контейнер
						document.getElementById('active-lobbies-container').style.display = 'none';
						return;
					}

					const allLobbies = snapshot.val();
					const activeLobbies = [];

					// Фильтруем лобби, относящиеся к текущему тесту и в статусе "waiting" или "started"
					for (const [lobbyCode, lobbyData] of Object.entries(allLobbies)) {
						if (lobbyData.testId === testId && (lobbyData.status === 'waiting' || lobbyData.status === 'started' || lobbyData.status === 'countdown' || lobbyData.status === 'finished')) {
							// Проверяем, есть ли участники в лобби
							const hasParticipants = lobbyData.participants && Object.keys(lobbyData.participants).length > 0;

							if (hasParticipants) {
								activeLobbies.push({
									code: lobbyCode,
									...lobbyData
								});
							} else {
								// Если лобби пустое, удаляем его
								console.log(`Удаляем пустое лобби: ${lobbyCode}`);
								safeDeleteLobby(lobbyCode)
									.catch(error => {
										console.error(`Ошибка при удалении пустого лобби ${lobbyCode}:`, error);
									});
							}
						}
					}

					// Обновляем счетчик активных лобби
					const activeLobbiesCount = document.getElementById('active-lobbies-count');
					activeLobbiesCount.textContent = activeLobbies.length;

					// Получаем контейнер для списка лобби
					const activeLobbiesList = document.getElementById('active-lobbies-list');
					activeLobbiesList.innerHTML = '';

					if (activeLobbies.length === 0) {
						// Если нет активных лобби для этого теста, скрываем контейнер
						document.getElementById('active-lobbies-container').style.display = 'none';
						return;
					}

					// Показываем контейнер с активными лобби
					document.getElementById('active-lobbies-container').style.display = 'block';

					// Отображаем каждое активное лобби
					activeLobbies.forEach(lobby => {
						const participantsCount = lobby.participants ? Object.keys(lobby.participants).length : 0;

						// Создаем элемент лобби
						const lobbyItem = document.createElement('div');
						lobbyItem.className = 'active-lobby-item';

						// Получаем информацию о хосте
						let hostData = null;
						if (lobby.participants) {
							hostData = Object.values(lobby.participants).find(p => p.isHost);
						}

						// Формируем HTML для элемента лобби
						let hostHTML = '';

						if (hostData) {
							// Используем аватарку из профиля пользователя (приоритет: photoURL -> avatarUrl -> инициалы)
							const avatarInitial = hostData.name ? hostData.name.charAt(0).toUpperCase() : 'U';

							let avatarContent = avatarInitial;
							if (hostData.photoURL) {
								avatarContent = `<img src="${hostData.photoURL}" alt="${hostData.name}">`;
							} else if (hostData.avatarUrl) {
								avatarContent = `<img src="${hostData.avatarUrl}" alt="${hostData.name}">`;
							}

							hostHTML = `
              <div class="active-lobby-host-info">
                <div class="active-lobby-host-avatar">${avatarContent}</div>
                <span>${hostData.name || 'Пользователь'}</span>
              </div>
            `;
						}

						// Добавляем статус лобби и информацию о прогрессе
						let statusHTML = '';
						if (lobby.status === 'started') {
							// Получаем информацию о текущем вопросе и их количестве в тесте
							const currentQuestion = lobby.currentQuestion !== undefined ? lobby.currentQuestion + 1 : 1;
							// Так как количество вопросов может быть неизвестно, используем questionsCount из лобби или из теста
							// или просто знак вопроса, если не можем определить
							const totalQuestions = lobby.questionsCount || '?';

							statusHTML = `
              <div class="active-lobby-status">
                <span class="status-label active">В процессе</span>
                <span class="status-progress">Вопрос ${currentQuestion}/${totalQuestions}</span>
              </div>
            `;
						} else if (lobby.status === 'countdown') {
							statusHTML = `
              <div class="active-lobby-status">
                <span class="status-label loading">Запуск..</span>
              </div>
            `;
						} else if (lobby.status === 'finished') {
							statusHTML = `
              <div class="active-lobby-status">
                <span class="status-label finishing">Завершение...</span>
              </div>
            `;
						} else {
							statusHTML = `
              <div class="active-lobby-status">
                <span class="status-label waiting">Ожидание</span>
              </div>
            `;
						}

						// Определяем, является ли это лобби текущим лобби пользователя
						const isUserLobby = (userCurrentLobby && userCurrentLobby === lobby.code);
						// Определяем, нужно ли заблокировать кнопку присоединения
						const isButtonDisabled = userCurrentLobby && !isUserLobby;

						// Проверяем, не был ли пользователь исключен из этого лобби
						let isUserKicked = false;
						if (lobby.kickedParticipants && lobby.kickedParticipants[currentUser.uid]) {
							isUserKicked = true;
						}

						lobbyItem.innerHTML = `
          <div class="active-lobby-info">
            <div class="active-lobby-code">Лобби: ${lobby.code}</div>
            ${statusHTML}
            <div class="active-lobby-meta">
              <span><i class="fas fa-users"></i> ${participantsCount} участников</span>
              ${hostHTML}
            </div>
              ${isUserLobby ? '<div class="user-in-lobby-badge">Вы здесь</div>' : ''}
          </div>
          ${lobby.status === 'waiting' ? `
            ${isUserKicked ? `
              <button class="join-lobby-btn disabled" disabled>
                <i class="fas fa-ban"></i> Вы были исключены
              </button>
            ` : `
              <button class="join-lobby-btn${isButtonDisabled ? ' disabled' : ''}" data-code="${lobby.code}" ${isButtonDisabled ? 'disabled' : ''}>
                <i class="fas fa-${isUserLobby ? 'arrow-right' : 'sign-in-alt'}"></i> ${isUserLobby ? 'Вернуться в лобби' : 'Присоединиться'}
              </button>
            `}
          ` : `
          <button class="spectate-lobby-btn" data-code="${lobby.code}" ${lobby.participants && lobby.participants[currentUser.uid] ? '' : 'disabled'} ${lobby.status === 'finished' ? 'disabled' : ''}>
            <i class="fas fa-${lobby.participants && lobby.participants[currentUser.uid] ? 'arrow-right' : 'eye'}"></i> ${lobby.participants && lobby.participants[currentUser.uid] ?
								(lobby.status === 'finished' ? 'Ожидание завершения' : 'Вернуться в игру') :
								lobby.status === 'countdown' ? 'Запуск..' :
									lobby.status === 'finished' ? 'Завершение...' :
										'Игра идет'
							}
          </button>
          `}
        `;

						// Добавляем пояснение, если кнопка заблокирована
						if (isButtonDisabled && lobby.status === 'waiting') {
							const disabledTooltip = document.createElement('div');
							disabledTooltip.className = 'lobby-button-tooltip';
							disabledTooltip.textContent = 'Вы уже находитесь в другом лобби';
							lobbyItem.querySelector('.join-lobby-btn').appendChild(disabledTooltip);
						}

						// Добавляем обработчик только для кнопки "Присоединиться" или "Вернуться в лобби" (для лобби в ожидании)
						if (lobby.status === 'waiting' && !isButtonDisabled && !isUserKicked) {
							lobbyItem.querySelector('.join-lobby-btn').addEventListener('click', () => {
								document.getElementById('join-code-input').value = lobby.code;
								joinLobbyByCode();
								// Скрываем контейнер с активными лобби сразу после нажатия
								document.getElementById('active-lobbies-container').style.display = 'none';
							});
						}

						// Добавляем обработчик для кнопки "Вернуться в игру" (для активных лобби)
						if (lobby.status !== 'waiting' && lobby.participants && lobby.participants[currentUser.uid]) {
							lobbyItem.querySelector('.spectate-lobby-btn').addEventListener('click', () => {
								document.getElementById('join-code-input').value = lobby.code;
								joinLobbyByCode();
								// Скрываем контейнер с активными лобби сразу после нажатия
								document.getElementById('active-lobbies-container').style.display = 'none';
							});
						}

						// Добавляем элемент в список
						activeLobbiesList.appendChild(lobbyItem);
					});
				});
			});
		}

		// Проверяем, ответили ли все участники на текущий вопрос
		function checkAllParticipantsAnswered() {
			// Получаем актуальные данные ответов
			get(ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}`)).then((snapshot) => {
				if (snapshot.exists()) {
					const answers = snapshot.val();
					participantsAnswers = answers;

					// Обновляем состояние кнопок на основе ответов участников
					updateButtonsAfterAnswer();

					// Проверяем, все ли ответили
					const allAnswered = Object.values(participants).every(participant =>
						(participant.hasLeft === true) ||
						(answers[participant.uid] && answers[participant.uid].answered)
					);

					if (allAnswered && !everyoneAnswered) {
						console.log("Все участники ответили!");
						everyoneAnswered = true;

						// Останавливаем таймер
						stopTimer();

						// Обновляем статус ответов участников
						updateParticipantsAnswerStatus();

						// Отображаем аватары участников рядом с их ответами
						displayParticipantAvatarsOnAnswers();
					}
				}
			}).catch(error => {
				console.error("Ошибка при проверке ответов всех участников:", error);
			});
		}

		// Обработка подтверждения ответа в совместном режиме
		function confirmAnswer() {
			if (!userAnswers[currentQuestionIndex] && !Array.isArray(userAnswers[currentQuestionIndex])) {
				alert('Пожалуйста, выберите ответ перед подтверждением');
				return;
			}

			// Сохраняем ответ в Firebase для совместного режима
			const userAnswerData = {
				answer: userAnswers[currentQuestionIndex],
				timestamp: firebase.database.ServerValue.TIMESTAMP
			};

			update(ref(db, `test_lobbies/${lobbyCode}/answers/${currentQuestionIndex}/${userId}`), userAnswerData)
				.then(() => {
					console.log('Ответ успешно сохранен');

					// Обновляем текст кнопок в зависимости от роли пользователя
					updateButtonsAfterAnswer();

					// Проверяем, ответили ли все участники
					checkAllParticipantsAnswered();
				}).catch(error => {
					console.error('Ошибка при отправке ответа:', error);
					alert('Ошибка при отправке ответа. Попробуйте еще раз.');
				});
		}

		// Функция для отображения модального окна подтверждения
		function showLeaveConfirmationModal() {
			const modal = document.getElementById('leave-confirmation-modal');
			modal.classList.add('active');

			return new Promise((resolve) => {
				// Кнопка "Да"
				document.getElementById('leave-confirm-yes').onclick = () => {
					modal.classList.remove('active');
					resolve(true);
				};

				// Кнопка "Нет"
				document.getElementById('leave-confirm-no').onclick = () => {
					modal.classList.remove('active');
					resolve(false);
				};
			});
		}

		// Функция запуска таймера закрытия лобби
		function startLobbyCloseTimer(lobbyCode) {
			if (!lobbyCode) return;

			const timerElement = document.getElementById('lobby-close-timer');
			timerElement.style.display = 'block';

			let secondsLeft = 30;

			// Обновляем текст таймера
			function updateTimer() {
				timerElement.textContent = `Лобби будет автоматически закрыто через ${secondsLeft} секунд...`;

				if (secondsLeft <= 0) {
					// Время вышло, останавливаем таймер
					clearInterval(timerInterval);

					// Убираем обработчик beforeunload для всех пользователей
					window.removeEventListener('beforeunload', beforeUnloadHandler);

					// Если пользователь хост, то удаляем лобби из базы данных
					if (isHost) {
						safeDeleteLobby(lobbyCode)
							.then(() => {
								console.log("Лобби успешно удалено из базы данных");

								// Сбрасываем состояние лобби после успешного удаления
								isCooperativeMode = false;
								isHost = false;
								lobbyCode = null;

								// Перенаправляем на главную страницу только после удаления лобби
								window.location.href = 'home.html';
							})
							.catch(error => {
								console.error("Ошибка при удалении лобби:", error);
								// В случае ошибки всё равно перенаправляем на главную
								isCooperativeMode = false;
								isHost = false;
								lobbyCode = null;
								window.location.href = 'home.html';
							});
					} else {
						// Если пользователь не хост, просто перенаправляем на главную
						isCooperativeMode = false;
						isHost = false;
						lobbyCode = null;
						window.location.href = 'home.html';
					}
				}

				secondsLeft--;
			}

			// Сразу обновляем текст таймера
			updateTimer();

			// Запускаем интервал
			const timerInterval = setInterval(updateTimer, 1000);
		}

		// Функция для обработки нажатия кнопки "На главную"
		window.handleHomeButtonClick = function () {
			// Если пользователь является хостом и есть активное лобби
			if (isCooperativeMode && isHost && lobbyCode) {
				// Сначала проверяем, существует ли еще лобби
				get(ref(db, `test_lobbies/${lobbyCode}`))
					.then((snapshot) => {
						if (snapshot.exists()) {
							// Лобби существует, удаляем его безопасно
							return safeDeleteLobby(lobbyCode);
						} else {
							console.log("Лобби уже удалено, переходим на главную");
							return Promise.resolve();
						}
					})
					.then(() => {
						console.log("Обработка перехода на главную завершена");
						// Сбрасываем переменные лобби
						isCooperativeMode = false;
						isHost = false;
						lobbyCode = null;
						// Переходим на главную
						window.location.href = 'home.html';
					})
					.catch(error => {
						console.error("Ошибка при обработке перехода на главную:", error);
						// В случае ошибки всё равно переходим на главную
						window.location.href = 'home.html';
					});
			} else {
				// Если пользователь не хост или нет активного лобби, просто переходим на главную
				window.location.href = 'home.html';
			}
		};

		// Функция для безопасного удаления лобби с отменой onDisconnect
		function safeDeleteLobby(lobbyCode) {
			return get(ref(db, `test_lobbies/${lobbyCode}/participants`))
				.then((participantsSnapshot) => {
					if (participantsSnapshot.exists()) {
						const participantsData = participantsSnapshot.val();

						// Отменяем все onDisconnect обработчики
						const cancelPromises = Object.keys(participantsData).map(uid => {
							const userStatusRef = ref(db, `test_lobbies/${lobbyCode}/participants/${uid}`);
							return onDisconnect(userStatusRef).cancel();
						});

						// После отмены всех обработчиков, удаляем лобби
						return Promise.all(cancelPromises)
							.then(() => {
								return set(ref(db, `test_lobbies/${lobbyCode}`), null);
							});
					} else {
						// Если участников нет, просто удаляем лобби
						return set(ref(db, `test_lobbies/${lobbyCode}`), null);
					}
				});
		}

		// Функция для установки всех слушателей лобби
		function setupLobbyListeners(code) {
			if (!code) return;

			console.log("Устанавливаем слушателей для лобби:", code);

			// Сначала отключаем все существующие слушатели, если они есть
			if (lobbyCode) {
				off(ref(db, `test_lobbies/${lobbyCode}/participants`));
				off(ref(db, `test_lobbies/${lobbyCode}/systemMessages`));
				off(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants/${currentUser.uid}`));
				off(ref(db, `test_lobbies/${lobbyCode}/status`));
				off(ref(db, `test_lobbies/${lobbyCode}/currentQuestion`));
			}

			// Слушатель для списка участников
			const participantsRef = ref(db, `test_lobbies/${code}/participants`);
			onValue(participantsRef, (snapshot) => {
				if (snapshot.exists()) {
					const newParticipants = snapshot.val();

					// Проверяем, есть ли текущий пользователь в списке участников
					if (!newParticipants[currentUser.uid]) {
						// Если пользователя нет в списке, но lobbyCode все еще установлен,
						// значит его исключили из лобби или он был удален по другой причине
						// (не через нашу функцию leaveLobby)
						if (lobbyCode && !voluntaryLeaving) {
							console.log("Вы больше не участник этого лобби");

							// Показываем уведомление
							const notification = document.createElement('div');
							notification.className = 'notification error-notification';
							notification.innerHTML = '<div class="notification-content">Вы были исключены из лобби</div>';
							document.body.appendChild(notification);

							setTimeout(() => {
								notification.classList.add('show');
							}, 100);

							setTimeout(() => {
								notification.classList.remove('show');
								setTimeout(() => {
									notification.remove();
								}, 500);
							}, 2000);

							// Отключаем всех слушателей Firebase
							off(ref(db, `test_lobbies/${lobbyCode}/participants`));
							off(ref(db, `test_lobbies/${lobbyCode}/systemMessages`));
							off(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants/${currentUser.uid}`));
							off(ref(db, `test_lobbies/${lobbyCode}/status`));
							off(ref(db, `test_lobbies/${lobbyCode}/currentQuestion`));

							// Сбрасываем состояние лобби
							resetLobbyState();

							// Прекращаем дальнейшее выполнение функции
							return;
						} else if (lobbyCode && voluntaryLeaving) {
							// Если это добровольный выход, просто выходим из функции обработчика
							// и позволяем функции leaveLobby завершить работу
							return;
						}
					}

					// Проверяем, не стал ли текущий пользователь хостом
					const userWasHost = isHost;
					const currentParticipant = newParticipants[currentUser.uid];

					if (currentParticipant && currentParticipant.isHost && !userWasHost) {
						// Пользователь стал новым хостом
						isHost = true;
						console.log("Вы стали новым хостом лобби");

						// Показываем кнопку начала теста, если тест еще не начался
						get(ref(db, `test_lobbies/${code}/status`)).then((statusSnapshot) => {
							if (statusSnapshot.exists() && statusSnapshot.val() === 'waiting') {
								document.getElementById('start-cooperative-test-btn').style.display = 'block';
							}
						});

						// Показываем уведомление о том, что пользователь стал хостом
						const notification = document.createElement('div');
						notification.className = 'notification';
						notification.innerHTML = '<div class="notification-content">Вы стали хостом лобби</div>';
						document.body.appendChild(notification);

						setTimeout(() => {
							notification.classList.add('show');
						}, 100);

						setTimeout(() => {
							notification.classList.remove('show');
							setTimeout(() => {
								notification.remove();
							}, 500);
						}, 3000);
					} else if (currentParticipant && !currentParticipant.isHost && userWasHost) {
						// Пользователь был хостом, но перестал им быть
						isHost = false;
						console.log("Вы больше не являетесь хостом лобби");

						// Скрываем кнопку начала теста
						document.getElementById('start-cooperative-test-btn').style.display = 'none';

						// Показываем уведомление
						const notification = document.createElement('div');
						notification.className = 'notification';
						notification.innerHTML = '<div class="notification-content">Вы больше не являетесь хостом лобби</div>';
						document.body.appendChild(notification);

						setTimeout(() => {
							notification.classList.add('show');
						}, 100);

						setTimeout(() => {
							notification.classList.remove('show');
							setTimeout(() => {
								notification.remove();
							}, 500);
						}, 3000);
					}

					participants = newParticipants;
					updateParticipantsList();

					// Обновляем статусы ответов участников при изменении списка участников
					if (isCooperativeMode) {
						updateParticipantsAnswerStatus();
					}

					// Проверяем, остался ли только один участник
					if (Object.keys(newParticipants).length === 1 && isHost) {
						// Если остался только один участник и это хост, показываем предупреждение
						showNotification('Вы остались одни в лобби', 'info', 2000);
					}
				} else {
					// Если участников больше нет или лобби было удалено
					if (lobbyCode) {
						console.log("Лобби больше не существует");

						// Показываем уведомление через менеджер уведомлений
						showNotification('Лобби было закрыто', 'info', 2000);

						resetLobbyState();
					}
				}
			});

			// Слушатель для статуса лобби
			const lobbyStatusRef = ref(db, `test_lobbies/${code}/status`);
			onValue(lobbyStatusRef, (snapshot) => {
				if (snapshot.exists()) {
					const status = snapshot.val();
					if (status === 'started') {
						// Если статус изменился на "started", начинаем тест для всех (и хоста, и участников)
						startCooperativeTestAsParticipant();
					} else if (status === 'finished' && !isHost) {
						// Если статус изменился на "finished", завершаем тест для участника
						console.log("Тест завершен хостом, показываем результаты");
						testTakingContainer.classList.remove('active');
						resultsContainer.classList.add('active');
						checkResults();

						// Участник тоже видит таймер обратного отсчета
						startLobbyCloseTimer(lobbyCode);
					} else if (status === 'countdown' && !isHost) {
						// Если статус изменился на "countdown" и пользователь не хост, 
						// показываем синхронизированный обратный отсчет
						showSynchronizedCountdown();
					}
				}
			});

			// Слушатель для текущего вопроса
			const currentQuestionRef = ref(db, `test_lobbies/${code}/currentQuestion`);
			onValue(currentQuestionRef, (snapshot) => {
				if (snapshot.exists()) {
					const question = parseInt(snapshot.val());
					if (question !== currentQuestionIndex) {
						// Получаем текущий статус лобби
						get(ref(db, `test_lobbies/${code}/status`)).then((statusSnapshot) => {
							if (statusSnapshot.exists() && statusSnapshot.val() === 'started') {
								// Сбрасываем все состояния предыдущего вопроса
								console.log("Переход к новому вопросу (для не-хоста):", question);

								// Сбрасываем флаг что все ответили и очищаем ответы для старого вопроса
								everyoneAnswered = false;
								participantsAnswers = {};

								// Удаляем все аватары участников и подсветки ответов
								const existingAvatarContainers = document.querySelectorAll('.answer-participants');
								existingAvatarContainers.forEach(container => {
									container.remove();
								});

								// Обновляем индекс текущего вопроса и отображаем его
								currentQuestionIndex = question;
								displayCurrentQuestion();
							}
						});
					}
				}
			});

			// Слушатель для системных сообщений
			const systemMessagesRef = ref(db, `test_lobbies/${code}/systemMessages`);
			onValue(systemMessagesRef, (snapshot) => {
				if (snapshot.exists()) {
					const messages = snapshot.val();

					// Получаем только новые сообщения (за последние 5 секунд)
					const now = Date.now();
					const recentMessages = Object.values(messages).filter(msg =>
						msg.timestamp && (now - msg.timestamp < 5000)
					);

					// Обрабатываем новые сообщения
					recentMessages.forEach(msg => {
						// Проверяем, что это сообщение об исключении участника
						if (msg.type === 'participant_kicked' && msg.participantId !== currentUser.uid) {
							// Показываем уведомление всем участникам, кроме исключенного, через менеджер уведомлений
							showNotification(`Участник ${msg.participantName} был исключен из лобби`, 'info', 2000);
							// Для хоста обновляем список исключенных участников
							if (isHost) {
								updateKickedParticipantsList();
							}
						} else if (msg.type === 'participant_unbanned') {
							// Показываем уведомление о разблокировке участника
							showNotification(`Участник ${msg.participantName} разблокирован`, 'info', 2000);
							// Для хоста обновляем список исключенных участников
							if (isHost) {
								updateKickedParticipantsList();
							}
							// Если текущий пользователь - тот, кого разблокировали
							if (msg.participantId === currentUser.uid) {
								showNotification('Вас разблокировали. Хорошей игры!', 'info', 3000);
							}
						} else if (msg.type === 'participant_left' && msg.participantId !== currentUser.uid) {
							// Показываем уведомление о выходе участника
							showNotification(`Участник ${msg.participantName} покинул лобби`, 'info', 2000);
						}
					});
				}
			});

			// Слушатель для проверки исключения участника
			const kickedRef = ref(db, `test_lobbies/${code}/kickedParticipants/${currentUser.uid}`);
			onValue(kickedRef, (snapshot) => {
				if (snapshot.exists() && snapshot.val() === true) {
					// Пользователь был выгнан из лобби
					console.log("Вы были исключены из лобби");

					// Показываем уведомление через новую функцию
					showNotification('Вы были исключены из лобби', 'error', 2000);

					// Отключаем всех слушателей Firebase, связанных с лобби
					off(ref(db, `test_lobbies/${code}/participants`));
					off(ref(db, `test_lobbies/${code}/systemMessages`));
					off(ref(db, `test_lobbies/${code}/currentQuestion`));
					off(ref(db, `test_lobbies/${code}/status`));
					off(ref(db, `test_lobbies/${code}/kickedParticipants/${currentUser.uid}`));

					// Сбрасываем состояние лобби вместо перенаправления на главную страницу
					resetLobbyState();
				}
			});
		}

		// Функция для обновления списка исключенных участников
		function updateKickedParticipantsList() {
			if (!isHost || !lobbyCode) return;

			console.log("Обновление списка исключенных пользователей для лобби:", lobbyCode);

			const kickedParticipantsList = document.getElementById('kicked-participants-list');
			if (!kickedParticipantsList) {
				console.error("Элемент kicked-participants-list не найден");
				return;
			}

			kickedParticipantsList.innerHTML = ''; // Очищаем список перед обновлением

			// Получаем список исключенных участников
			get(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants`)).then((snapshot) => {
				if (snapshot.exists()) {
					const kickedParticipants = snapshot.val();
					const kickedIds = Object.keys(kickedParticipants).filter(id => kickedParticipants[id] === true);

					console.log("Исключенные пользователи:", kickedIds);

					if (kickedIds.length === 0) {
						kickedParticipantsList.innerHTML = '<div class="no-kicked-participants">Нет исключенных участников</div>';
						return;
					}

					// Отображаем количество исключенных участников
					const kickedCountBadge = document.createElement('div');
					kickedCountBadge.className = 'kicked-count-badge';
					kickedCountBadge.textContent = `Всего: ${kickedIds.length}`;
					kickedParticipantsList.appendChild(kickedCountBadge);

					// Для каждого исключенного участника получаем информацию о пользователе из Firebase
					// Используем Set для хранения уже добавленных ID пользователей
					const addedUsers = new Set();

					Promise.all(kickedIds.map(uid =>
						get(ref(db, `users/${uid}`)).then(userSnapshot => {
							return {
								uid,
								userData: userSnapshot.exists() ? userSnapshot.val() : null
							};
						})
					)).then(usersData => {
						kickedParticipantsList.innerHTML = ''; // Очищаем список еще раз перед добавлением пользователей

						if (kickedIds.length === 0) {
							kickedParticipantsList.innerHTML = '<div class="no-kicked-participants">Нет исключенных участников</div>';
							return;
						}

						usersData.forEach(({ uid, userData }) => {
							// Проверяем, не добавляли ли мы уже этого пользователя
							if (addedUsers.has(uid)) {
								console.log(`Пользователь ${uid} уже добавлен в список, пропускаем`);
								return;
							}

							// Добавляем ID в множество добавленных пользователей
							addedUsers.add(uid);

							const participantItem = document.createElement('div');
							participantItem.className = 'kicked-participant-item';
							participantItem.dataset.uid = uid; // Добавляем data-атрибут для идентификации

							// Используем данные пользователя, если они доступны
							const name = userData?.name || 'Пользователь';
							const photoURL = userData?.photoURL || null;
							const avatarInitial = name.charAt(0).toUpperCase();

							let avatarContent = avatarInitial;
							if (photoURL) {
								avatarContent = `<img src="${photoURL}" alt="${name}">`;
							}

							participantItem.innerHTML = `
                <div class="participant-avatar">
                  ${avatarContent}
                </div>
                <div class="participant-name">${name}</div>
                <button class="unban-btn" data-uid="${uid}">
                  <i class="fas fa-unlock"></i> Разблокировать
                </button>
              `;

							kickedParticipantsList.appendChild(participantItem);

							// Добавляем обработчик события для кнопки разблокировки
							const unbanBtn = participantItem.querySelector('.unban-btn');
							unbanBtn.addEventListener('click', () => unbanParticipant(uid, name));
						});

						if (addedUsers.size === 0) {
							kickedParticipantsList.innerHTML = '<div class="no-kicked-participants">Нет исключенных участников</div>';
						} else {
							console.log(`Добавлено ${addedUsers.size} исключенных пользователей`);
						}
					}).catch(error => {
						console.error("Ошибка при получении данных исключенных участников:", error);
						kickedParticipantsList.innerHTML = '<div class="no-kicked-participants">Ошибка при загрузке данных</div>';
					});
				} else {
					kickedParticipantsList.innerHTML = '<div class="no-kicked-participants">Нет исключенных участников</div>';
				}
			}).catch(error => {
				console.error("Ошибка при получении списка исключенных участников:", error);
				kickedParticipantsList.innerHTML = '<div class="no-kicked-participants">Ошибка при загрузке данных</div>';
			});
		}

		// Функция для разблокировки исключенного участника
		function unbanParticipant(participantId, participantName) {
			if (!isHost || !lobbyCode) return;

			// Показываем подтверждение
			if (confirm(`Разблокировать пользователя ${participantName || 'Пользователь'}? Он сможет снова присоединиться к лобби.`)) {
				// Удаляем участника из списка исключенных
				set(ref(db, `test_lobbies/${lobbyCode}/kickedParticipants/${participantId}`), null)
					.then(() => {
						console.log(`Участник ${participantName} разблокирован`);

						// Добавляем системное сообщение о разблокировке
						const systemMessageData = {
							type: 'participant_unbanned',
							participantId: participantId,
							participantName: participantName || 'Пользователь',
							byHostId: currentUser.uid,
							byHostName: currentUser.name || 'Хост',
							timestamp: Date.now()
						};

						// Добавляем это сообщение в специальный узел лобби
						return push(ref(db, `test_lobbies/${lobbyCode}/systemMessages`), systemMessageData);
					})
					.then(() => {
						// Показываем уведомление
						showNotification(`Пользователь ${participantName} разблокирован`, 'info', 2000);

						// Обновляем список исключенных участников
						updateKickedParticipantsList();
					})
					.catch(error => {
						console.error("Ошибка при разблокировке участника:", error);
						alert("Произошла ошибка при разблокировке участника");
					});
			}
		}

		// Переменная для хранения выбранной оценки
		let selectedRating = 0;

		// Инициализация функциональности отзывов
		function initFeedbackFunctionality() {
			const ratingStars = document.querySelectorAll('.star-rating');
			const submitFeedbackBtn = document.getElementById('submit-feedback-btn');
			const feedbackComment = document.getElementById('feedback-comment');

			// Добавляем обработчики для звезд рейтинга
			ratingStars.forEach(star => {
				star.addEventListener('click', () => {
					const rating = parseInt(star.getAttribute('data-rating'));
					selectedRating = rating;

					// Обновляем отображение звезд
					ratingStars.forEach(s => {
						const starRating = parseInt(s.getAttribute('data-rating'));
						if (starRating <= selectedRating) {
							s.classList.remove('far');
							s.classList.add('fas', 'selected');
						} else {
							s.classList.remove('fas', 'selected');
							s.classList.add('far');
						}
					});

					// Активируем кнопку отправки
					submitFeedbackBtn.disabled = selectedRating === 0;
				});
			});

			// Обработчик для кнопки отправки отзыва
			submitFeedbackBtn.addEventListener('click', submitFeedback);
		}

		// Функция для отправки отзыва
		function submitFeedback() {
			if (selectedRating === 0) {
				showNotification('Пожалуйста, выберите оценку', 'error');
				return;
			}

			const comment = document.getElementById('feedback-comment').value.trim();

			// Создаем объект отзыва
			const feedbackData = {
				testId: testId,
				userId: currentUser.uid,
				userName: currentUser.name || currentUser.email || 'Пользователь',
				userPhotoURL: currentUser.photoURL || currentUser.avatarUrl || null,
				rating: selectedRating,
				comment: comment,
				timestamp: serverTimestamp()
			};

			// Сохраняем отзыв в Firebase
			push(ref(db, 'test_feedback'), feedbackData)
				.then(() => {
					// Показываем сообщение об успехе в форме
					const feedbackContainer = document.getElementById('feedback-container');
					feedbackContainer.innerHTML = `
        <div class="feedback-success" style="display: block;">
          <i class="fas fa-check-circle"></i> Благодарим за оценку!
        </div>
      `;

					// Показываем уведомление
					showNotification('Ваш отзыв успешно отправлен', 'info');
				})
				.catch(error => {
					console.error('Ошибка при отправке отзыва:', error);
					showNotification('Ошибка при отправке отзыва', 'error');
				});
		}

		// Добавляем инициализацию функциональности отзывов при загрузке результатов теста
		document.addEventListener('DOMContentLoaded', () => {
			// Инициализируем функциональность отзывов
			initFeedbackFunctionality();
		});

		// Глобальная переменная для хранения функции отписки от слушателя отзывов
		let reviewsListenerUnsubscribe = null;

		// Функция для загрузки отзывов о тесте в реальном времени
		function loadTestReviews(testId) {
			// Удаляем предыдущий слушатель, если он был
			if (reviewsListenerUnsubscribe) {
				reviewsListenerUnsubscribe(); // Вызываем функцию отписки напрямую
			}

			const reviewsRef = ref(db, 'test_feedback');

			// Устанавливаем слушатель на изменения отзывов и сохраняем функцию отписки
			reviewsListenerUnsubscribe = onValue(reviewsRef, (snapshot) => {
				if (snapshot.exists()) {
					const reviewsData = snapshot.val();
					// Преобразуем объект в массив с сохранением ключей
					const allReviews = Object.entries(reviewsData)
						.map(([key, review]) => ({
							...review,
							key // Добавляем ключ в объект отзыва
						}))
						.filter(review => review.testId === testId)
						.sort((a, b) => {
							// Сортируем по timestamp в обратном порядке (новые сначала)
							const timeA = a.timestamp ? a.timestamp : 0;
							const timeB = b.timestamp ? b.timestamp : 0;
							return timeB - timeA;
						});

					// Проверяем, оставлял ли текущий пользователь отзыв для этого теста
					const currentUserReview = allReviews.find(review => review.userId === currentUser.uid);

					// Скрываем или показываем форму отзыва в зависимости от того, оставлял ли пользователь отзыв
					const feedbackContainer = document.getElementById('feedback-container');
					if (feedbackContainer) {
						if (currentUserReview) {
							// Пользователь уже оставлял отзыв

							// Проверяем, есть ли уже сообщение о благодарности
							const existingThankYouMessage = feedbackContainer.querySelector('.feedback-success');

							if (!existingThankYouMessage) {
								// Если сообщения о благодарности нет, показываем стандартное сообщение
								feedbackContainer.innerHTML = `
              <div class="feedback-message">
                <i class="fas fa-info-circle"></i> Вы уже оставляли оценку этому тесту
              </div>
            `;
							}
							// Если сообщение благодарности уже есть, оставляем его как есть

							feedbackContainer.style.display = 'block';
						} else {
							// Пользователь еще не оставлял отзыв - показываем форму
							feedbackContainer.style.display = 'block';

							// Убеждаемся, что содержимое формы осталось неизменным (если оно было заменено)
							if (!feedbackContainer.querySelector('#rating-stars')) {
								feedbackContainer.innerHTML = `
              <h3 class="feedback-title">Оставьте отзыв о тесте</h3>
              <div class="rating-container">
                <p>Оценка:</p>
                <div class="stars-container" id="rating-stars">
                  <i class="far fa-star star-rating" data-rating="1"></i>
                  <i class="far fa-star star-rating" data-rating="2"></i>
                  <i class="far fa-star star-rating" data-rating="3"></i>
                  <i class="far fa-star star-rating" data-rating="4"></i>
                  <i class="far fa-star star-rating" data-rating="5"></i>
                </div>
              </div>
              <div class="comment-container">
                <p>Комментарий (необязательно):</p>
                <textarea id="feedback-comment" class="feedback-comment" placeholder="Напишите ваше мнение о тесте..."></textarea>
              </div>
              <button id="submit-feedback-btn" class="submit-feedback-btn" disabled>
                <i class="fas fa-paper-plane"></i> Отправить отзыв
              </button>
            `;

								// Переинициализируем функциональность отзывов
								initFeedbackFunctionality();
							}
						}
					}

					// Показываем блок отзывов, если есть отзывы
					const reviewsContainer = document.getElementById('test-reviews-container');
					if (allReviews.length > 0) {
						reviewsContainer.style.display = 'block';

						// Обновляем средний рейтинг
						updateAverageRating(allReviews);

						// Очищаем список отзывов
						const reviewsList = document.getElementById('reviews-list');
						reviewsList.innerHTML = '';

						// Отображаем первые 5 отзывов
						const reviewsToShow = allReviews.slice(0, 5);
						renderReviews(reviewsToShow, reviewsList);

						// Показываем кнопку "Показать больше", если есть больше 5 отзывов
						const showMoreBtn = document.getElementById('show-more-reviews');
						if (allReviews.length > 5) {
							showMoreBtn.style.display = 'block';

							// Удаляем предыдущие обработчики (чтобы избежать дублирования)
							const newShowMoreBtn = showMoreBtn.cloneNode(true);
							showMoreBtn.parentNode.replaceChild(newShowMoreBtn, showMoreBtn);

							// Добавляем обработчик для кнопки "Показать больше"
							newShowMoreBtn.addEventListener('click', () => {
								// Очищаем список и отображаем все отзывы
								reviewsList.innerHTML = '';
								renderReviews(allReviews, reviewsList);

								// Скрываем кнопку "Показать больше"
								newShowMoreBtn.style.display = 'none';
							});
						} else {
							showMoreBtn.style.display = 'none';
						}
					} else {
						reviewsContainer.style.display = 'none';
					}
				} else {
					// Если отзывов нет, скрываем блок отзывов
					document.getElementById('test-reviews-container').style.display = 'none';
				}
			}, (error) => {
				console.error("Ошибка при загрузке отзывов в реальном времени:", error);
			});

			// Отключаем слушатель при уходе со страницы
			window.addEventListener('beforeunload', () => {
				if (reviewsListenerUnsubscribe) {
					reviewsListenerUnsubscribe();
				}
			});
		}

		// Функция для отображения отзывов
		function renderReviews(reviews, container) {
			if (reviews.length === 0) {
				container.innerHTML = '<div class="no-reviews">Отзывов пока нет</div>';
				return;
			}

			// Проверяем, является ли текущий пользователь автором теста
			const isTestAuthor = currentUser.uid === currentTest.createdBy;

			reviews.forEach(review => {
				const reviewElement = document.createElement('div');
				reviewElement.className = 'review-item';

				// Проверяем, является ли текущий пользователь автором отзыва
				const isReviewAuthor = review.userId === currentUser.uid;

				// Форматируем дату и время более точно
				const reviewDate = review.timestamp ? new Date(review.timestamp) : new Date();
				const formattedDate = reviewDate.toLocaleDateString('ru-RU', {
					year: 'numeric',
					month: 'long',
					day: 'numeric'
				});
				const formattedTime = reviewDate.toLocaleTimeString('ru-RU', {
					hour: '2-digit',
					minute: '2-digit'
				});

				// Формируем строку даты с информацией о редактировании
				let dateDisplay = `${formattedDate} в ${formattedTime}`;
				if (review.editedAt) {
					const editedDate = new Date(review.editedAt);
					const formattedEditedDate = editedDate.toLocaleDateString('ru-RU', {
						year: 'numeric',
						month: 'long',
						day: 'numeric'
					});
					const formattedEditedTime = editedDate.toLocaleTimeString('ru-RU', {
						hour: '2-digit',
						minute: '2-digit'
					});
					dateDisplay += ` <span class="edited-info">(изм. ${formattedEditedDate} в ${formattedEditedTime})</span>`;
				}

				// Создаем строку звезд для рейтинга
				const stars = Array(5).fill().map((_, i) =>
					`<i class="${i < review.rating ? 'fas' : 'far'} fa-star"></i>`
				).join('');

				// Создаем аватар пользователя
				const avatarInitial = review.userName ? review.userName.charAt(0).toUpperCase() : 'U';
				let avatarHtml = '';

				if (review.userPhotoURL) {
					avatarHtml = `<img src="${review.userPhotoURL}" alt="${review.userName}">`;
				} else {
					// Генерируем цвет фона на основе имени пользователя
					const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#4a6ee0', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
					const colorIndex = Math.abs(review.userName.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) % colors.length;
					avatarHtml = `<div style="background-color: ${colors[colorIndex]}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">${avatarInitial}</div>`;
				}

				// Добавляем кнопки удаления и редактирования, если пользователь является автором отзыва
				const reviewActions = isReviewAuthor
					? `<div class="review-actions">
          <div class="review-rating">${stars}</div>
          <button class="delete-review-btn" data-review-id="${review.key || ''}">
            <i class="fas fa-trash-alt"></i>
          </button>
          <button class="edit-review-btn" data-review-id="${review.key || ''}">
            <i class="fas fa-edit"></i>
          </button>
        </div>`
					: `<div class="review-actions">
          <div class="review-rating">${stars}</div>
        </div>`;

				// Начинаем формировать содержимое отзыва
				let reviewContent = `
      <div class="review-header">
        <div class="reviewer-info">
          <div class="reviewer-avatar">
            ${avatarHtml}
          </div>
          <div>
            <div class="reviewer-name">${review.userName || 'Пользователь'}</div>
            <div class="review-date">${dateDisplay}</div>
          </div>
        </div>
        ${reviewActions}
      </div>
      <div class="review-comment" id="review-comment-${review.key}">${review.comment || ''}</div>
    `;

				// Добавляем форму для редактирования отзыва, если пользователь - автор отзыва
				if (isReviewAuthor) {
					reviewContent += `
        <div class="edit-form" id="edit-review-form-${review.key}" style="display: none;">
          <textarea id="edit-review-text-${review.key}">${review.comment || ''}</textarea>
          <div class="edit-form-actions">
            <button class="cancel-edit-btn" data-review-id="${review.key}">Отмена</button>
            <button class="save-edit-btn" data-review-id="${review.key}">Сохранить</button>
          </div>
        </div>
      `;
				}

				// Добавляем существующий ответ автора, если он есть
				if (review.authorReply) {
					const replyDate = new Date(review.authorReply.timestamp);
					const formattedReplyDate = replyDate.toLocaleDateString('ru-RU', {
						year: 'numeric',
						month: 'long',
						day: 'numeric'
					});

					// Добавляем форматирование времени
					const formattedReplyTime = replyDate.toLocaleTimeString('ru-RU', {
						hour: '2-digit',
						minute: '2-digit'
					});

					// Формируем строку даты ответа с информацией о редактировании
					let replyDateDisplay = `${formattedReplyDate} в ${formattedReplyTime}`;
					if (review.authorReply.editedAt) {
						const editedReplyDate = new Date(review.authorReply.editedAt);
						const formattedEditedReplyDate = editedReplyDate.toLocaleDateString('ru-RU', {
							year: 'numeric',
							month: 'long',
							day: 'numeric'
						});
						const formattedEditedReplyTime = editedReplyDate.toLocaleTimeString('ru-RU', {
							hour: '2-digit',
							minute: '2-digit'
						});
						replyDateDisplay += ` <span class="edited-info">(изм. ${formattedEditedReplyDate} в ${formattedEditedReplyTime})</span>`;
					}

					// Проверяем, является ли текущий пользователь автором ответа
					const isAuthorReplyCreator = currentUser.uid === currentTest.createdBy;

					// Добавляем кнопки для ответа автора
					const replyActions = isAuthorReplyCreator
						? `<button class="delete-reply-btn" id="delete-reply-${review.key}" data-review-id="${review.key}">
            <i class="fas fa-trash-alt"></i>
          </button>
          <button class="edit-reply-btn" id="edit-reply-${review.key}" data-review-id="${review.key}">
            <i class="fas fa-edit"></i>
          </button>`
						: '';

					reviewContent += `
        <div class="author-reply">
          <div class="author-reply-header">
            <span class="author-badge">Автор</span>
            <span>${replyDateDisplay}</span>
            ${replyActions}
          </div>
          <div class="author-reply-text" id="reply-text-${review.key}">${review.authorReply.text}</div>
      `;

					// Добавляем форму для редактирования ответа, если пользователь - автор теста
					if (isAuthorReplyCreator) {
						reviewContent += `
          <div class="edit-form" id="edit-reply-form-${review.key}" style="display: none;">
            <textarea id="edit-reply-text-${review.key}">${review.authorReply.text}</textarea>
            <div class="edit-form-actions">
              <button class="cancel-edit-reply-btn" data-review-id="${review.key}">Отмена</button>
              <button class="save-edit-reply-btn" data-review-id="${review.key}">Сохранить</button>
            </div>
          </div>
        `;
					}

					reviewContent += `</div>`;
				}
				// Добавляем кнопку для ответа, если текущий пользователь - автор теста и еще нет ответа
				else if (isTestAuthor && !review.authorReply) {
					reviewContent += `
        <button class="reply-button" data-review-id="${review.key}">
          <i class="fas fa-reply"></i> Ответить на отзыв
        </button>
        <div class="reply-form" id="reply-form-${review.key}" style="display: none;">
          <textarea placeholder="Ваш ответ на отзыв..." id="reply-text-${review.key}"></textarea>
          <div class="reply-form-actions">
            <button class="cancel-reply-btn" data-review-id="${review.key}">Отмена</button>
            <button class="submit-reply-btn" data-review-id="${review.key}">Отправить</button>
          </div>
        </div>
      `;
				}

				reviewElement.innerHTML = reviewContent;
				container.appendChild(reviewElement);

				// Добавляем все обработчики событий

				// Обработчики для удаления отзыва
				if (isReviewAuthor) {
					const deleteButton = reviewElement.querySelector('.delete-review-btn');
					if (deleteButton) {
						deleteButton.addEventListener('click', () => {
							deleteReview(review.key, reviewElement);
						});
					}

					// Обработчики для редактирования отзыва
					const editButton = reviewElement.querySelector('.edit-review-btn');
					const editForm = reviewElement.querySelector(`#edit-review-form-${review.key}`);
					const reviewCommentEl = reviewElement.querySelector(`#review-comment-${review.key}`);
					const cancelEditBtn = reviewElement.querySelector(`.cancel-edit-btn`);
					const saveEditBtn = reviewElement.querySelector(`.save-edit-btn`);

					if (editButton && editForm) {
						// Обработчик для кнопки редактирования
						editButton.addEventListener('click', () => {
							editForm.style.display = 'block';
							if (reviewCommentEl) reviewCommentEl.style.display = 'none';
						});

						// Обработчик для кнопки отмены
						if (cancelEditBtn) {
							cancelEditBtn.addEventListener('click', () => {
								editForm.style.display = 'none';
								if (reviewCommentEl) reviewCommentEl.style.display = 'block';
							});
						}

						// Обработчик для кнопки сохранения
						if (saveEditBtn) {
							saveEditBtn.addEventListener('click', () => {
								const newComment = document.getElementById(`edit-review-text-${review.key}`).value.trim();
								editReview(review.key, newComment);
							});
						}
					}
				}

				// Обработчики для ответа автора
				if (review.authorReply && currentUser.uid === currentTest.createdBy) {
					// Обработчик для удаления ответа
					const deleteReplyBtn = document.getElementById(`delete-reply-${review.key}`);
					if (deleteReplyBtn) {
						deleteReplyBtn.addEventListener('click', (event) => {
							event.stopPropagation();
							deleteAuthorReply(review.key);
						});
					}

					// Обработчики для редактирования ответа
					const editReplyBtn = document.getElementById(`edit-reply-${review.key}`);
					const editReplyForm = document.getElementById(`edit-reply-form-${review.key}`);
					const replyTextEl = document.getElementById(`reply-text-${review.key}`);
					const cancelEditReplyBtn = reviewElement.querySelector(`.cancel-edit-reply-btn`);
					const saveEditReplyBtn = reviewElement.querySelector(`.save-edit-reply-btn`);

					if (editReplyBtn && editReplyForm) {
						// Обработчик для кнопки редактирования ответа
						editReplyBtn.addEventListener('click', (event) => {
							event.stopPropagation();
							editReplyForm.style.display = 'block';
							if (replyTextEl) replyTextEl.style.display = 'none';
						});

						// Обработчик для кнопки отмены
						if (cancelEditReplyBtn) {
							cancelEditReplyBtn.addEventListener('click', () => {
								editReplyForm.style.display = 'none';
								if (replyTextEl) replyTextEl.style.display = 'block';
							});
						}

						// Обработчик для кнопки сохранения
						if (saveEditReplyBtn) {
							saveEditReplyBtn.addEventListener('click', () => {
								const newReplyText = document.getElementById(`edit-reply-text-${review.key}`).value.trim();
								editAuthorReply(review.key, newReplyText);
							});
						}
					}
				}

				// Обработчики для формы ответа на отзыв
				if (isTestAuthor && !review.authorReply) {
					const replyButton = reviewElement.querySelector('.reply-button');
					const replyForm = reviewElement.querySelector(`#reply-form-${review.key}`);
					const cancelReplyBtn = reviewElement.querySelector('.cancel-reply-btn');
					const submitReplyBtn = reviewElement.querySelector('.submit-reply-btn');

					if (replyButton) {
						replyButton.addEventListener('click', () => {
							replyForm.style.display = 'block';
							replyButton.style.display = 'none';
						});
					}

					if (cancelReplyBtn) {
						cancelReplyBtn.addEventListener('click', () => {
							replyForm.style.display = 'none';
							replyButton.style.display = 'inline-block';
						});
					}

					if (submitReplyBtn) {
						submitReplyBtn.addEventListener('click', () => {
							const replyText = document.getElementById(`reply-text-${review.key}`).value.trim();
							if (replyText) {
								submitReplyToReview(review.key, replyText);
							} else {
								showNotification('Введите текст ответа', 'error');
							}
						});
					}
				}
			});
		}

		// Функция для редактирования отзыва
		function editReview(reviewKey, newComment) {
			if (!newComment) {
				showNotification('Комментарий не может быть пустым', 'error');
				return;
			}

			update(ref(db, `test_feedback/${reviewKey}`), {
				comment: newComment,
				editedAt: Date.now()
			})
				.then(() => {
					showNotification('Отзыв успешно обновлен', 'info');
					// Скрываем форму редактирования
					const editForm = document.getElementById(`edit-review-form-${reviewKey}`);
					const reviewComment = document.getElementById(`review-comment-${reviewKey}`);

					if (editForm) editForm.style.display = 'none';
					if (reviewComment) {
						reviewComment.style.display = 'block';
					}
				})
				.catch(error => {
					console.error('Ошибка при обновлении отзыва:', error);
					showNotification('Не удалось обновить отзыв', 'error');
				});
		}

		// Функция для редактирования ответа автора
		function editAuthorReply(reviewKey, newReplyText) {
			if (!newReplyText) {
				showNotification('Ответ не может быть пустым', 'error');
				return;
			}

			// Получаем текущий ответ, чтобы сохранить остальные поля
			get(ref(db, `test_feedback/${reviewKey}/authorReply`))
				.then((snapshot) => {
					if (snapshot.exists()) {
						const currentReply = snapshot.val();

						// Обновляем только текст и добавляем метку времени редактирования
						update(ref(db, `test_feedback/${reviewKey}/authorReply`), {
							text: newReplyText,
							editedAt: Date.now(),
							// Сохраняем оригинальные поля
							authorId: currentReply.authorId,
							authorName: currentReply.authorName,
							timestamp: currentReply.timestamp
						})
							.then(() => {
								showNotification('Ответ успешно обновлен', 'info');

								// Скрываем форму редактирования
								const editReplyForm = document.getElementById(`edit-reply-form-${reviewKey}`);
								const replyTextEl = document.getElementById(`reply-text-${reviewKey}`);

								if (editReplyForm) editReplyForm.style.display = 'none';
								if (replyTextEl) replyTextEl.style.display = 'block';
							})
							.catch(error => {
								console.error('Ошибка при обновлении ответа:', error);
								showNotification('Не удалось обновить ответ', 'error');
							});
					} else {
						showNotification('Не удалось найти ответ для редактирования', 'error');
					}
				})
				.catch(error => {
					console.error('Ошибка при получении данных ответа:', error);
					showNotification('Ошибка при редактировании ответа', 'error');
				});
		}

		// Функция для удаления ответа автора
		function deleteAuthorReply(reviewKey) {
			if (confirm('Вы уверены, что хотите удалить свой ответ?')) {
				// Удаляем поле authorReply из отзыва
				update(ref(db, `test_feedback/${reviewKey}`), {
					authorReply: null
				})
					.then(() => {
						showNotification('Ваш ответ удален', 'info');
						// Обновлять список отзывов не нужно, так как у нас есть realtime слушатель
					})
					.catch(error => {
						console.error('Ошибка при удалении ответа:', error);
						showNotification('Не удалось удалить ответ', 'error');
					});
			}
		}

		// Функция для отправки ответа на отзыв
		function submitReplyToReview(reviewKey, replyText) {
			const replyData = {
				text: replyText,
				timestamp: Date.now(),
				authorId: currentUser.uid,
				authorName: currentUser.name || currentUser.email || 'Автор'
			};

			// Обновляем отзыв в Firebase, добавляя ответ автора
			update(ref(db, `test_feedback/${reviewKey}`), {
				authorReply: replyData
			})
				.then(() => {
					showNotification('Ваш ответ добавлен', 'info');

					// Обновлять список отзывов не нужно, так как у нас есть realtime слушатель
				})
				.catch(error => {
					console.error('Ошибка при добавлении ответа:', error);
					showNotification('Не удалось добавить ответ', 'error');
				});
		}

		// Функция для удаления отзыва
		function deleteReview(reviewKey, reviewElement) {
			if (!reviewKey) {
				// Если у отзыва нет ключа, нам нужно найти его
				get(ref(db, 'test_feedback'))
					.then((snapshot) => {
						if (snapshot.exists()) {
							const reviews = snapshot.val();
							for (const key in reviews) {
								const review = reviews[key];
								if (review.userId === currentUser.uid && review.testId === testId) {
									// Нашли отзыв пользователя
									confirmAndDeleteReview(key, reviewElement);
									return;
								}
							}
							showNotification('Не удалось найти ваш отзыв', 'error');
						}
					})
					.catch(error => {
						console.error('Ошибка при поиске отзыва:', error);
						showNotification('Ошибка при удалении отзыва', 'error');
					});
			} else {
				// Если ключ есть, сразу удаляем
				confirmAndDeleteReview(reviewKey, reviewElement);
			}
		}

		// Функция для подтверждения и удаления отзыва
		function confirmAndDeleteReview(reviewKey, reviewElement) {
			if (confirm('Вы уверены, что хотите удалить свой отзыв?')) {
				// Удаляем отзыв из Firebase
				set(ref(db, `test_feedback/${reviewKey}`), null)
					.then(() => {
						// Показываем уведомление
						showNotification('Отзыв успешно удален', 'info');

						// Возвращаем форму для нового отзыва
						const feedbackContainer = document.getElementById('feedback-container');
						if (feedbackContainer) {
							feedbackContainer.innerHTML = `
            <h3 class="feedback-title">Оставьте отзыв о тесте</h3>
            <div class="rating-container">
              <p>Оценка:</p>
              <div class="stars-container" id="rating-stars">
                <i class="far fa-star star-rating" data-rating="1"></i>
                <i class="far fa-star star-rating" data-rating="2"></i>
                <i class="far fa-star star-rating" data-rating="3"></i>
                <i class="far fa-star star-rating" data-rating="4"></i>
                <i class="far fa-star star-rating" data-rating="5"></i>
              </div>
            </div>
            <div class="comment-container">
              <p>Комментарий (необязательно):</p>
              <textarea id="feedback-comment" class="feedback-comment" placeholder="Напишите ваше мнение о тесте..."></textarea>
            </div>
            <button id="submit-feedback-btn" class="submit-feedback-btn" disabled>
              <i class="fas fa-paper-plane"></i> Отправить отзыв
            </button>
          `;

							feedbackContainer.style.display = 'block';

							// Переинициализируем функциональность отзывов
							initFeedbackFunctionality();
							selectedRating = 0;
						}
					})
					.catch(error => {
						console.error('Ошибка при удалении отзыва:', error);
						showNotification('Ошибка при удалении отзыва', 'error');
					});
			}
		}

		// Функция для обновления среднего рейтинга
		function updateAverageRating(reviews) {
			if (!reviews || reviews.length === 0) {
				document.getElementById('avg-rating-badge').textContent = '0.0';
				return;
			}

			// Вычисляем средний рейтинг
			const totalRating = reviews.reduce((sum, review) => sum + review.rating, 0);
			const avgRating = (totalRating / reviews.length).toFixed(1);

			// Обновляем бейдж со средним рейтингом
			const avgRatingBadge = document.getElementById('avg-rating-badge');
			avgRatingBadge.textContent = avgRating;

			// Добавляем звезду к бейджу
			avgRatingBadge.innerHTML = `${avgRating} <i class="fas fa-star"></i>`;
		}
	</script>

	<!-- Подключаем скрипт для всплывающего окна лобби -->
	<script src="js/lobby-popup.js"></script>
</body>

</html>